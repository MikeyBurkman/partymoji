// TODO Varargs
import { buildTransform } from '../types';
import { mapImage, isTransparent, repeat } from '../utils';
import { positiveIntParam, colorParam } from './params';

const DEFAULT_COLORS = [
  '0xFF0000',
  '0xFF9600',
  '0xFFFF00',
  '0x00FF00',
  '0x00FF96',
  '0x00FFFF',
  '0x0000FF',
  '0xB400FF',
];

export const radiance = buildTransform({
  name: 'radiance',
  // validateParams: (args) => {
  //   if (args.length === 0) {
  //     return {
  //       groups: 2,
  //       colors: DEFAULT_COLORS.map(fromHexColor),
  //     };
  //   }

  //   assert(
  //     args.length >= 2,
  //     'radiance requires either no arguments, or at least two arguments'
  //   );

  //   const groups = parseInt(args[0], 10);
  //   assert(
  //     groups > 0,
  //     'radiance groups first argument must be a positive integer'
  //   );

  //   const rawColors = args.slice(1);
  //   const colors = rawColors.map((c, idx) => {
  //     assert(
  //       isHexColor(c),
  //       `radiance color ${idx} must be a valid hex number in the format 0xRRGGBB`
  //     );
  //     return fromHexColor(c);
  //   });
  //   return { groups, colors };
  // },
  params: [
    positiveIntParam('Number of Groups'),
    colorParam('Color 1'),
    colorParam('Color 2'),
  ] as const,
  fn: mapImage(
    ({
      coord,
      dimensions,
      frameCount,
      frameIndex,
      getSrcPixel,
      parameters,
    }) => {
      const [groups, ...colors] = parameters;
      const srcPixel = getSrcPixel(coord);

      const colorList = repeat(groups).flatMap(() => colors);

      // Make the transparent parts colorful
      if (isTransparent(srcPixel)) {
        const [width, height] = dimensions;
        const centerX = width / 2;
        const centerY = height / 2;
        const [x, y] = coord;
        const xRelCenter = x - centerX;
        const yRelCenter = y - centerY;

        const maxDist = Math.sqrt(
          (width / 2) * (width / 2) + (height / 2) * (height / 2)
        );
        const distFromCenter = Math.sqrt(
          yRelCenter * yRelCenter + xRelCenter * xRelCenter
        );

        const colorIdx =
          Math.floor((1 - distFromCenter / maxDist) * colorList.length) %
          colorList.length;

        // Increment colorIdx based on current frame progress
        const frameProgress = frameIndex / frameCount;
        const idx =
          (Math.floor(frameProgress * colorList.length) + colorIdx) %
          colorList.length;
        return colorList[idx];
      }

      return srcPixel;
    }
  ),
});
