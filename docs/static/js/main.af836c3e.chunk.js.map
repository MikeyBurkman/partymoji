{"version":3,"sources":["components/Expandable.tsx","components/Help.tsx","domain/importImageFromUrl.ts","domain/utils/misc.ts","components/ImagePicker.tsx","domain/types.ts","domain/utils/isWorker.ts","domain/utils/canvas.ts","domain/utils/color.ts","domain/utils/image.ts","components/HelpTooltip.tsx","params/intParam.tsx","params/sliderParam.tsx","useDebounce.tsx","effects/adjust-image.ts","params/colorPickerParam.tsx","effects/background-color.ts","params/checkboxParam.tsx","params/imagePickerParam.tsx","params/radioParam.tsx","effects/background-image.ts","effects/blur.ts","effects/bounce.ts","effects/bounce-animation.ts","effects/circle.ts","params/variableLengthParam.tsx","effects/colors.ts","effects/colors-background.ts","params/floatParam.tsx","effects/double-vision.ts","effects/expand.ts","effects/fill.ts","effects/fisheye.ts","effects/grid.ts","params/huePickerParam.tsx","effects/hue-change.ts","effects/hue-shift.ts","effects/hue-shift-pulse.ts","effects/hue-wave.ts","params/textParam.tsx","effects/lightning.ts","effects/mirror.ts","effects/nuke.ts","effects/opacity.ts","effects/party.ts","effects/party-background.ts","effects/party-harder.ts","effects/pinwheel-colors.ts","effects/pinwheel-rainbow.ts","effects/pinwheel-rainbow-background.ts","effects/radiance-colors.ts","effects/radiance-rainbow.ts","effects/radiance-rainbow-background.ts","effects/reduce-color-palette.ts","effects/repeat-animation.ts","effects/resize-image.ts","effects/reverse-animation.ts","effects/ripple.ts","effects/rotate.ts","effects/roxbury.ts","effects/scale-image.ts","effects/set-animation-length.ts","effects/shake.ts","effects/slow-animation.ts","effects/spin.ts","effects/static.ts","params/dropdownParam.tsx","effects/text.ts","effects/transparency.ts","effects/transpose.ts","effects/index.ts","domain/run.ts","components/Gif.tsx","domain/env.ts","components/useProcessingQueue.tsx","domain/effect.worker.ts","domain/runAsync.ts","domain/computeGifs.ts","components/ImageEffectDialog.tsx","components/ImageEffectList.tsx","localStorage.ts","AlertContext.tsx","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["Expandable","mainEle","children","React","useState","collapsed","setCollapsed","ClickAwayListener","onClickAway","Stack","Button","variant","onClick","style","color","size","direction","alignItems","spacing","Icon","Collapse","in","Help","Typography","Divider","Group","Section","width","SectionHeader","paddingLeft","SectionText","sx","fontSize","marginRight","getImageFromUrl","url","a","Promise","resolve","reject","img","Image","setAttribute","onload","canvas","document","createElement","height","ctx","getContext","Error","drawImage","toDataURL","onerror","src","assert","condition","message","replaceIndex","arr","index","newValueFn","map","x","i","ImagePicker","currentImageUrl","onChange","error","setError","TextField","label","helperText","onBlur","e","text","target","value","undefined","test","dataUrl","Box","startIcon","maxWidth","component","type","hidden","accept","name","event","files","Array","from","file","readFile","baseImage","maxHeight","alt","reader","FileReader","result","readAsDataURL","toParamFunction","buildEffect","args","params","description","secondaryDescription","fn","disabled","IS_WORKER","window","createCanvas","OffscreenCanvas","frameToCanvas","dimensions","frame","putImageData","ImageData","canvasToFrame","canvasData","getImageData","data","applyCanvasFromFrame","preEffect","postEffect","save","restore","combineImages","background","foreground","backgroundCanvas","foregroundCanvas","applyFilter","blur","brightness","contrast","opacity","saturation","filters","filter","length","join","applyTransform","horizontalScale","verticalScale","horizontalSkew","verticalSkew","horizontalTranslation","verticalTranslation","transform","applyRotation","degrees","offsetX","offsetY","radians","Math","PI","rotate","weightedValue","percent","v1","v2","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","floor","int32","clamp","n","min","max","clampColor","TRANSPARENT_COLOR","shiftTowardsHue","hue","amount","convert","hsl","l","rgb","newR","newG","newB","shiftHue","h","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","colorFromHue","colorDiff","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","sqrt","getPixelFromSource","image","coord","y","idx","getImageIndex","mapFrames","cb","frames","mapCoords","transformedImageData","Uint8ClampedArray","mapImage","parameters","imageData","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","resizeImage","newWidth","newHeight","keepScale","newFrames","rootCanvas","imgCanvas","setPixel","HelpTooltip","Tooltip","title","IntParam","parse","val","setVal","invalidText","setInvalidText","FormControl","valid","reason","FormHelperText","intParam","defaultValue","isNaN","SliderParam","step","initial","callback","waitMillis","onChangeDebounce","useDebounceCallback","useCallback","arg","useDebounce","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","sliderParam","adjustImage","resizeToWidth","resizeToHeight","oldWidth","oldHeight","hasScaleChange","ceil","isBiggerImage","currImage","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","CheckboxParam","paddingTop","Checkbox","checked","checkboxParam","DEFAULT_IMAGE","RadioParam","options","RadioGroup","t","FormControlLabel","control","Radio","radioParam","backgroundImage","readImage","otherImagePreResize","otherImage","thisFrameCanvas","otherImageFrameIndex","otherFrameCanvas","bounce","speed","yOffset","round","sin","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","cos","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","p","oldP","IconButton","newParams","visibility","vals","variableLengthParam","DEFAULT_COLORS","colors","brightnessIncrease","chosenColor","srcPixel","gray","getAveragePixelValue","d","adjustBrightness","colorsBackground","bgColor","FloatParam","floatParam","parseFloat","doubleVision","dir","expand","dist","centerX","centerY","xRatio","yRatio","fill","oldImage","colorToReplace","tolerance","f","duplicateImage","floodFill","newColor","visited","set","Set","add","has","stack","push","pop","currColor","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","abs","newSat","adjustSaturation","HuePickerParam","hexColor","useMemo","huePickerParam","hueChange","newHue","hueShift","hueShiftPulse","hueWave","shift","amplitude","period","TextParam","textParam","lightningIntensities","lightning","seed","seedrandom","flashIntensity","icf","mirror","nuke","party","newH","partyBackground","shiftSpeed","partyHarder","pinwheelColors","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","slice","center","pointAngle","colorIdx","pinwheelRainbow","strength","pinwheelRainbowBackground","radianceColors","colorList","range","flatMap","maxDist","distFromCenter","radianceRainbow","radianceRainbowBackground","reduceColorPalette","percentReduction","allColorsSet","px","allColors","numColors","colorMap","numClosestColors","closestColorIdx","closetsColorDist","k","colorPalette","sortBy","minBy","top","repeatAnimation","numRepeats","resizeImageUtil","reverseAnimation","ripple","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","scaleImage","scale","scaleImageUtil","setAnimationLength","currentFrames","frameToCopy","changeFrameCount","shake","slowAnimation","ogFrameIdx","r1","g1","b1","a1","spin","staticc","isBackground","inverse","grey","isStatic","DropdownParam","Select","autoWidth","MenuItem","FONTS","font","fillStyle","fillText","transparency","matchesTransparent","selectedColor","withinTolerance","transpose","otherEffects","POSSIBLE_EFFECTS","effectByName","find","runEffects","effectInput","randomSeed","fps","effect","effectName","transparentColor","getTransparentColor","createGif","encodeTransparency","gif","gifEncoder","setFrameRate","setRepeat","writeHeader","setTransparent","on","chunk","URL","createObjectURL","Blob","forEach","addFrame","finish","res","rej","getPixels","err","results","shape","numFrames","sliceSize","subarray","hasTransparent","seenPixels","attempt","findRandomColorNotInSet","attempts","col","calculateDimensions","aspectRatio","Gif","IS_MOBILE","MobileDetect","navigator","userAgent","mobile","ENV","debugLog","console","log","useProcessingQueue","onComplete","onError","latestRunId","useRef","runId","current","then","onFinish","catch","Worker_fn","Worker","computationMap","Map","handleError","computationId","computation","get","delete","computeGif","worker","RunEffectWorker","Date","now","addEventListener","onmessage","status","handleSuccess","postMessage","computeGifsForState","state","startEffectIndex","onCompute","prevEffectState","effects","start","paramsValues","ga","hitType","timingCategory","timingVar","timingValue","ImageEffectDialog","open","initialImage","currentEffect","possibleEffects","currFps","currRandomSeed","onChangeEffect","onCancel","computing","setImage","onImageChange","initialLoaded","setInitialLoaded","editingEffect","setEditingEffect","dirty","setDirty","useEffect","closeDialog","Dialog","fullWidth","DialogTitle","marginTop","Autocomplete","disableClearable","newEffectName","renderOption","props","option","marginLeft","renderInput","DialogContent","divider","Fragment","CircularProgress","DialogActions","autoFocus","effectKey","substring","ImageEffectList","appState","onEffectsChange","currentEffects","effectDialogOpen","setEffectDialogOpen","setBaseImage","getInitialImage","prevEffect","onMoveUp","nextT","newIdx","onMoveDown","tIdx","previousEffect","isNew","border","fontWeight","marginBottom","newEffect","computedImage","lastEffect","FxDivider","LOCAL_STORAGE_KEY","saveAppState","localStorage","setItem","serializeAppState","clearAppState","removeItem","toStore","JSON","stringify","alertContext","createContext","alert","setAlert","AlertProvider","alertValue","setAlertValue","Provider","AlertSnackbar","useContext","Snackbar","Alert","severity","onClose","fpsParam","DEFAULT_STATE","version","Inner","setStateRaw","doCompute","setDoCompute","computeTimer","setComputeTimer","stored","getItem","savedState","isArray","startIndex","setState","oldState","newState","STATE","clearTimeout","effectsDiff","currState","prevState","diff","currEffects","prevEffects","currE","prevE","ei","currEParam","prevEP","getEffectsDiff","setTimeout","computeIdx","ScopedCssBaseline","Container","justifyContent","pt","href","rel","padding","App","TopLevelErrorBoundary","hasError","errorInfo","this","endIcon","onClearLocalStorage","Component","theme","createTheme","typography","fontFamily","ReactDOM","render","StrictMode","ThemeProvider","location","reload","getElementById"],"mappings":"+XAaaA,EAAwC,SAAC,GAG/C,IAFLC,EAEI,EAFJA,QACAC,EACI,EADJA,SACI,EAC8BC,IAAMC,UAAS,GAD7C,mBACGC,EADH,KACcC,EADd,KAGJ,OACE,cAACC,EAAA,EAAD,CAAmBC,YAAa,kBAAMF,GAAa,IAAnD,SACE,eAACG,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CACEC,QAAQ,OACRC,QAAS,kBAAMN,GAAcD,IAC7BQ,MAAO,CAAEC,MAAO,SAChBC,KAAK,QAJP,SAME,eAACN,EAAA,EAAD,CAAOO,UAAU,MAAMC,WAAW,SAASC,QAAS,EAApD,UACE,8BAAMjB,IACN,cAACkB,EAAA,EAAD,UAAOd,EAAY,MAAQ,gBAG/B,cAACe,EAAA,EAAD,CAAUC,IAAKhB,EAAf,SAA2BH,UC7BtBoB,EAAiB,kBAC5B,cAAC,EAAD,CACErB,QAAS,cAACsB,EAAA,EAAD,CAAYZ,QAAQ,KAApB,iCADX,SAGE,eAAC,EAAD,WACE,cAAC,EAAD,CACEV,QAAS,cAACsB,EAAA,EAAD,CAAYZ,QAAQ,KAApB,6BADX,SAGE,eAAC,EAAD,WACE,cAAC,EAAD,2DAGA,cAAC,EAAD,gDACA,cAAC,EAAD,sFAMJ,cAAC,EAAD,CACEV,QAAS,cAACsB,EAAA,EAAD,CAAYZ,QAAQ,KAApB,4BADX,SAGE,eAAC,EAAD,WACE,cAAC,EAAD,UACE,eAAC,EAAD,WACE,cAAC,EAAD,+DAGA,cAAC,EAAD,6GAIA,cAAC,EAAD,8GAOJ,cAACa,EAAA,EAAD,IAEA,eAAC,EAAD,WACE,cAAC,EAAD,iEAGA,cAAC,EAAD,sEAGA,cAAC,EAAD,uGAIA,cAAC,EAAD,qGAIA,cAAC,EAAD,8GAMF,cAACA,EAAA,EAAD,IAEA,eAAC,EAAD,WACE,cAAC,EAAD,2CACA,cAAC,EAAD,oEAGA,cAAC,EAAD,4DAGA,cAAC,EAAD,8EAGA,cAAC,EAAD,6KASN,cAAC,EAAD,CAAYvB,QAAS,cAACsB,EAAA,EAAD,CAAYZ,QAAQ,KAApB,2BAArB,SACE,eAAC,EAAD,WACE,eAAC,EAAD,WACE,cAAC,EAAD,8CACA,cAAC,EAAD,0GAIA,cAAC,EAAD,oGAMF,cAACa,EAAA,EAAD,IAEA,eAAC,EAAD,WACE,cAAC,EAAD,6BACA,cAAC,EAAD,+GAWNC,EAAkB,SAAC,GAAD,IAAGvB,EAAH,EAAGA,SAAH,OAAkB,cAACO,EAAA,EAAD,CAAOS,QAAS,EAAhB,SAAoBhB,KAExDwB,EAAoB,SAAC,GAAD,IAAGxB,EAAH,EAAGA,SAAH,OACxB,cAACO,EAAA,EAAD,CAAOkB,MAAM,KAAKT,QAAS,EAA3B,SACGhB,KAIC0B,EAA0B,SAAC,GAAD,IAAG1B,EAAH,EAAGA,SAAH,OAC9B,cAACqB,EAAA,EAAD,CAAYZ,QAAQ,QAAQkB,YAAY,SAAxC,SACG3B,KAIC4B,EAAwB,SAAC,GAAD,IAAG5B,EAAH,EAAGA,SAAH,OAC5B,eAACqB,EAAA,EAAD,CAAYZ,QAAQ,QAAQkB,YAAY,SAAxC,UACE,cAACV,EAAA,EAAD,CAAMY,GAAI,CAAEC,SAAU,EAAGC,YAAa,GAAtC,oBADF,IAC4D/B,M,kBCpIjDgC,EAAe,uCAAG,WAAOC,GAAP,SAAAC,EAAA,+EACtB,IAAIC,SAAgB,SAACC,EAASC,GACnC,IAAMC,EAAM,IAAIC,MAChBD,EAAIE,aAAa,cAAe,aAChCF,EAAIG,OAAS,WACX,IAAMC,EAASC,SAASC,cAAc,UACtCF,EAAOjB,MAAQa,EAAIb,MACnBiB,EAAOG,OAASP,EAAIO,OACpB,IAAMC,EAAMJ,EAAOK,WAAW,MAC9B,IAAKD,EACH,MAAM,IAAIE,MAAM,wBAElBF,EAAIG,UAAUX,EAAK,EAAG,GACtBF,EAAQM,EAAOQ,cAGjBZ,EAAIa,QAAU,WACZd,EAAO,IAAIW,MAAM,uBAGnBV,EAAIc,IAAMnB,MApBiB,2CAAH,sDCSrB,SAASoB,EACdC,GAEoB,IADpBC,EACmB,uDADT,yBAEV,IAAKD,EACH,MAAM,IAAIN,MAAJ,4BAA+BO,IAKlC,IAAMC,EAAe,SAC1BC,EACAC,EACAC,GAH0B,OAIlBF,EAAIG,KAAI,SAACC,EAAGC,GAAJ,OAAWJ,IAAUI,EAAIH,EAAWE,GAAKA,MCX9CE,EAA0C,SAAC,GAGjD,IAFLC,EAEI,EAFJA,gBACAC,EACI,EADJA,SACI,EACsBhE,IAAMC,WAD5B,mBACGgE,EADH,KACUC,EADV,KAEJ,OACE,eAAC5D,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,cAACT,EAAA,EAAD,CAAOO,UAAU,MAAjB,SACE,cAACsD,EAAA,EAAD,CACEC,MAAM,MACN5D,QAAQ,WACRyD,QAASA,EACTI,WAAU,OAAEJ,QAAF,IAAEA,IAAS,8BACrBK,OAAM,uCAAE,WAAOC,GAAP,iBAAAtC,EAAA,yDACAuC,EAAOD,EAAEE,OAAOC,MADhB,SAGJR,OAASS,GDFrB,sGAAsGC,KCG/EJ,GAJP,iEAOkBzC,EAAgByC,GAPlC,OAOEK,EAPF,OAQJb,EAASa,GARL,kDAUJX,EAAS,uBAVL,0DAAF,0DAeV,cAACY,EAAA,EAAD,iBACA,eAACvE,EAAA,EAAD,CACEwE,UAAW,cAAC/D,EAAA,EAAD,oBACXY,GAAI,CAAEoD,SAAU,SAChBxE,QAAQ,YACRyE,UAAU,QAJZ,4BAOE,uBACEC,KAAK,OACLC,QAAM,EACNC,OAAO,2CACPC,KAAK,aACLrB,SAAQ,uCAAE,WAAOsB,GAAP,qBAAArD,EAAA,yDACFsD,EAAQC,MAAMC,KAAN,UAAWH,EAAMb,OAAOc,aAAxB,QAAiC,MACzCG,EAAOH,EAAM,IAFX,gCAKkBI,EAASD,GAL3B,OAKAE,EALA,OAMN5B,EAAS4B,GANH,2CAAF,2DAWX7B,GACC,qBACErD,MAAO,CAAEsE,SAAU,QAASa,UAAW,QACvC1C,IAAKY,EACL+B,IAAI,eAORH,EAAW,SAACD,GAAD,OACf,IAAIxD,SAAgB,SAACC,GACnB,IAAM4D,EAAS,IAAIC,WACnBD,EAAOvD,OAAS,kBAAML,EAAQ4D,EAAOE,SACrCF,EAAOG,cAAcR,O,oHCcZS,EAAkB,SAC7BvC,GAEA,MAAiB,oBAANA,EACFA,EAEF,kBAAMA,IA0BFwC,EAAc,SAA0CC,GAA1C,YAOT,CAChBhB,KAAMgB,EAAKhB,KACXiB,OAAQD,EAAKC,OACbC,YAAaF,EAAKE,YAClBC,qBAAsBH,EAAKG,qBAC3BC,GAAIJ,EAAKI,GACTC,SAAQ,UAAEL,EAAKK,gBAAP,WC1IGC,EAA8B,qBAAXC,OCGnBC,GAAe,SAAC,GAA6C,IAAD,mBAA3CrF,EAA2C,KAApCoB,EAAoC,KACvE,GAAI+D,EAAW,CAGb,IAAMlE,EAAS,IAAIqE,gBAAgBtF,EAAOoB,GACpCC,EAAMJ,EAAOK,WAAW,MAE9B,OADAM,EAAOP,EAAK,wBACL,CAAEJ,SAAQI,OAEjB,IAAMJ,EAASC,SAASC,cAAc,UACtCF,EAAOjB,MAAQA,EACfiB,EAAOG,OAASA,EAChB,IAAMC,EAAMJ,EAAOK,WAAW,MAE9B,OADAM,EAAOP,EAAK,wBACL,CAAEJ,SAAQI,QAKRkE,GAAgB,SAAC,GAMX,IALjBC,EAKgB,EALhBA,WACAC,EAIgB,EAJhBA,MAIgB,cACQD,EADR,GACTxF,EADS,KACFoB,EADE,OAEQiE,GAAaG,GAA7BvE,EAFQ,EAERA,OAAQI,EAFA,EAEAA,IAIhB,OAFAA,EAAIqE,aAAa,IAAIC,UAAUF,EAAOzF,EAAOoB,GAAS,EAAG,GAElD,CAAEH,SAAQI,QAINuE,GAAgB,SAACC,GAO5B,OANkBA,EAAWxE,IAAIyE,aAC/B,EACA,EACAD,EAAW5E,OAAOjB,MAClB6F,EAAW5E,OAAOG,QAEH2E,MAQNC,GAAuB,SAAC,GAYnB,IAXhBR,EAWe,EAXfA,WACAC,EAUe,EAVfA,MACAQ,EASe,EATfA,UACAC,EAQe,EARfA,WAWML,EAAaR,GAAaG,GAQhC,OANAK,EAAWxE,IAAI8E,OACN,OAATF,QAAS,IAATA,KAAYJ,GACZA,EAAWxE,IAAIG,UAAU+D,GAAc,CAAEC,aAAYC,UAASxE,OAAQ,EAAG,GACzE4E,EAAWxE,IAAI+E,UACL,OAAVF,QAAU,IAAVA,KAAaL,GAENA,EAAWxE,IAAIyE,aAAa,EAAG,EAAGN,EAAW,GAAIA,EAAW,IAAIO,MAI5DM,GAAgB,SAAC,GAQZ,IAPhBb,EAOe,EAPfA,WACAc,EAMe,EANfA,WACAC,EAKe,EALfA,WAMMC,EACJ,WAAYF,EACRA,EACAf,GAAc,CACZC,WAAYA,EACZC,MAAOa,IAGTG,EACJ,WAAYF,EACRA,EACAhB,GAAc,CACZC,WAAYA,EACZC,MAAOc,IAKf,OAFAC,EAAiBnF,IAAIG,UAAUiF,EAAiBxF,OAAQ,EAAG,GAEpD2E,GAAcY,IAGVE,GAAc,SACzBzF,EADyB,GAeT,IAZd0F,EAYa,EAZbA,KACAC,EAWa,EAXbA,WACAC,EAUa,EAVbA,SACAC,EASa,EATbA,QACAC,EAQa,EARbA,WASIC,EAAU,CACN,MAARL,EAAe,GAAf,eAA4BA,EAA5B,OACc,MAAdC,EAAqB,GAArB,qBAAwCA,EAAxC,MACY,MAAZC,EAAmB,GAAnB,mBAAoCA,EAApC,MACW,MAAXC,EAAkB,GAAlB,kBAAkCA,EAAlC,MACc,MAAdC,EAAqB,GAArB,mBAAsCA,EAAtC,OACAE,QAAO,SAAC7E,GAAD,OAAOA,EAAE8E,OAAS,KAI3B,OAFAjG,EAAOI,IAAI4F,OAASD,EAAQG,KAAK,KAE1BlG,GAGImG,GAAiB,SAC5BnG,EAD4B,GAiBZ,IAddoG,EAca,EAdbA,gBACAC,EAaa,EAbbA,cACAC,EAYa,EAZbA,eACAC,EAWa,EAXbA,aACAC,EAUa,EAVbA,sBACAC,EASa,EATbA,oBAkBF,OARAzG,EAAOI,IAAIsG,UAAX,OACEN,QADF,IACEA,IAAmB,EADrB,OAEEG,QAFF,IAEEA,IAAgB,EAFlB,OAGED,QAHF,IAGEA,IAAkB,EAHpB,OAIED,QAJF,IAIEA,IAAiB,EAJnB,OAKEG,QALF,IAKEA,IAAyB,EAL3B,OAMEC,QANF,IAMEA,IAAuB,GAElBzG,GAOI2G,GAAgB,SAC3B3G,EACA4G,GAEA,IAAMC,EAAU7G,EAAOA,OAAOjB,MAAQ,EAChC+H,EAAU9G,EAAOA,OAAOG,OAAS,EACvCgG,GAAenG,EAAQ,CACrBwG,sBAAuBK,EACvBJ,oBAAqBK,IAEvB,IAAMC,GAAYH,EAAUI,KAAKC,GAAM,IAMvC,OALAjH,EAAOI,IAAI8G,OAAOH,GAClBZ,GAAenG,EAAQ,CACrBwG,uBAAwBK,EACxBJ,qBAAsBK,IAEjB9G,G,mBCtLHmH,GAAgB,SAACC,EAAiBC,EAAYC,GAA9B,OACnB,EAAIF,EAAU,KAAOC,EAAMD,EAAU,IAAOE,GAKlCC,GAAa,SAAC,GAAsB,IAAD,mBAApBC,EAAoB,KAAjBC,EAAiB,KAAdC,EAAc,KACxCC,EAAa,SAACC,GAClB,IAAMC,EAAID,EAAEE,SAAS,IAAIC,cACzB,OAAoB,IAAbF,EAAE5B,OAAe4B,EAAI,IAAMA,GAGpC,MAAM,IAAN,OAAWF,EAAWH,IAAtB,OAA2BG,EAAWF,IAAtC,OAA2CE,EAAWD,KAG3CM,GAAe,SAACC,GAAD,MAAwB,CAClDC,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzC,MAUWC,GAAgB,SAACC,GAAD,OAAkBA,EAAM,GAAK,IAE7CC,GAAc,SAACC,GAAD,MAAoC,CAC7DvB,KAAKwB,MAAuB,IAAjBD,EAAOE,SAClBzB,KAAKwB,MAAuB,IAAjBD,EAAOE,SAClBzB,KAAKwB,MAAuB,IAAjBD,EAAOE,SAClB,MAMWC,GAAQ,SAACC,EAAWC,EAAaC,GAAzB,OACnB7B,KAAK6B,IAAI7B,KAAK4B,IAAID,EAAGE,GAAMD,IAEhBE,GAAa,SAAC,GAAD,uBAAEtB,EAAF,KAAKC,EAAL,KAAQC,EAAR,KAAWlI,EAAX,WAAgC,CACxDkJ,GAAMlB,EAAG,EAAG,KACZkB,GAAMjB,EAAG,EAAG,KACZiB,GAAMhB,EAAG,EAAG,KACZgB,GAAMlJ,EAAG,EAAG,OAGDuJ,GAA2B,CAAC,EAAG,EAAG,EAAG,GAOrCC,GAAkB,SAAC,EAE9BC,EACAC,GACW,IAAD,mBAHT1B,EAGS,KAHNC,EAGM,KAHHC,EAGG,KAHAlI,EAGA,OACO2J,OAAYC,IAAI,CAAC5B,EAAGC,EAAGC,IAD9B,mBACDG,EADC,KACEwB,EADF,OAEiBF,OAAYG,IAAI,CACzCL,EACA9B,GAAc+B,EAAQrB,EAAG,KACzBwB,IALQ,mBAEHE,EAFG,KAEGC,EAFH,KAESC,EAFT,KAOV,MAAO,CACLtC,GAAc+B,EAAQ1B,EAAG+B,GACzBpC,GAAc+B,EAAQzB,EAAG+B,GACzBrC,GAAc+B,EAAQxB,EAAG+B,GACzBjK,IAQSkK,GAAW,SAAC,EAAqBR,GAA2B,IAAD,mBAA9C1B,EAA8C,KAA3CC,EAA2C,KAAxCC,EAAwC,KAArClI,EAAqC,OACpD2J,OAAYC,IAAI,CAAC5B,EAAGC,EAAGC,IAD6B,mBAC/DiC,EAD+D,KAC5D9B,EAD4D,KACzDwB,EADyD,OAE3CF,OAAYG,IAAI,EAAEK,EAAIT,GAAU,IAAKrB,EAAGwB,IAFG,mBAGtE,MAAO,CAH+D,eAG5C7J,IAMfoK,GAAiB,SAACC,EAAWC,GACxC,IAAMC,EAAaD,EAAG,GAAKD,EAAG,GACxBG,EAAaF,EAAG,GAAKD,EAAG,GAC9B,OAAQ,IAA4C,IAArC7C,KAAKiD,MAAMD,EAAYD,GAAqB/C,KAAKC,IAAM,KAY3DiD,GAAe,SAACjB,GAAD,4BACvBE,OAAYG,IAAI,CAACL,EAAK,IAAK,MADJ,CAE1B,OAiCWkB,GAAY,SAACN,EAAWC,GAGnC,IAAMM,EAAWP,EAAG,GAAKC,EAAG,GACtBO,EAAYR,EAAG,GAAKC,EAAG,GACvBQ,EAAaT,EAAG,GAAKC,EAAG,GACxBS,GAAcV,EAAG,GAAKC,EAAG,IAAM,EAE/BU,GAAc,EAAID,EAAa,KAAOH,EAAWA,EACjDK,GAAc,GAAK,IAAMF,GAAc,KAAOF,EAAYA,EAC1DK,EAAa,EAAIJ,EAAaA,EAEpC,OAAOtD,KAAK2D,KAAKH,EAAaC,EAAaC,GAAc,KC3I9CE,GAAqB,SAChCrG,EACAsG,EACAC,GACW,IAAD,cACcvG,EADd,GACHxF,EADG,KACIoB,EADJ,mBAEK2K,EAFL,GAEH3J,EAFG,KAEA4J,EAFA,KAGV,GAAI5J,EAAI,GAAKA,GAAKpC,GAASgM,EAAI,GAAKA,GAAK5K,EACvC,OAAO4I,GAGT,IAAMiC,EAAMC,GAAc1G,EAAYpD,EAAG4J,GACzC,MAAO,CAACF,EAAMG,GAAMH,EAAMG,EAAM,GAAIH,EAAMG,EAAM,GAAIH,EAAMG,EAAM,KAMrDE,GAAY,SACvBL,EACAM,GAFuB,MAOZ,CACX5G,WAAYsG,EAAMtG,WAClB6G,OAAQP,EAAMO,OAAOlK,KAAI,SAACsD,EAAOwG,GAAR,OAAgBG,EAAG3G,EAAOwG,EAAKH,EAAMO,OAAOnF,aAM1DoF,GAAY,SACvB9G,EACA4G,GAIA,IAHe,IAAD,cACU5G,EADV,GACPxF,EADO,KACAoB,EADA,KAERmL,EAAuB,IAAIC,kBAAkBxM,EAAQoB,EAAS,GAC3D4K,EAAI,EAAGA,EAAI5K,EAAQ4K,GAAK,EAC/B,IAAK,IAAI5J,EAAI,EAAGA,EAAIpC,EAAOoC,GAAK,EAAG,CACjC,IAAMyG,EAAIkB,GAAWqC,EAAG,CAAChK,EAAG4J,KACtBC,EAAMC,GAAc1G,EAAYpD,EAAG4J,GACzCO,EAAqBN,GAAOpD,EAAE,GAC9B0D,EAAqBN,EAAM,GAAKpD,EAAE,GAClC0D,EAAqBN,EAAM,GAAKpD,EAAE,GAClC0D,EAAqBN,EAAM,GAAKpD,EAAE,GAGtC,OAAO0D,GAOIE,GAAW,SACtBL,GAaA,OAAO,gBAAGN,EAAH,EAAGA,MAAOtC,EAAV,EAAUA,OAAQkD,EAAlB,EAAkBA,WAAlB,OACLP,GAAUL,GAAO,SAACa,EAAWC,EAAYC,GAAxB,OACfP,GAAUR,EAAMtG,YAAY,SAACuG,GAAD,OAC1BK,EAAG,CACDN,QACAtG,WAAYsG,EAAMtG,WAClBgE,SACAkD,aACAX,QACAc,aACAD,aACAE,kBAAmBF,EAAaC,EAChCE,YAAa,SAAClE,GAAD,OACXgD,GAAmBC,EAAMtG,WAAYmH,EAAW9D,cAY/CmE,GAAyB,SACpCC,EAUAb,GAcA,OAAO,gBAAGN,EAAH,EAAGA,MAAOtC,EAAV,EAAUA,OAAQkD,EAAlB,EAAkBA,WAAlB,OACLP,GAAUL,GAAO,SAACa,EAAWC,EAAYC,GACvC,IAAMC,EAAoBF,EAAaC,EACjCK,EAAWD,EAAQ,CACvBnB,QACAtG,WAAYsG,EAAMtG,WAClBgE,SACAkD,aACAG,aACAD,aACAE,sBAGF,OAAOR,GAAUR,EAAMtG,YAAY,SAACuG,GAAD,OACjCK,EAAG,CACDc,WACApB,QACAtG,WAAYsG,EAAMtG,WAClBgE,SACAkD,aACAX,QACAc,aACAD,aACAE,oBACAC,YAAa,SAAClE,GAAD,OACXgD,GAAmBC,EAAMtG,WAAYmH,EAAW9D,cAM/CqD,GAAgB,SAAC,EAAqB9J,EAAW4J,GAAjC,OACT,GAAjB5J,EAAI4J,EADsB,sBA4ChBmB,GAAc,SAAC,GAUd,IATZrB,EASW,EATXA,MACAsB,EAQW,EARXA,SACAC,EAOW,EAPXA,UACAC,EAMW,EANXA,UAOMC,EAAYpB,GAAUL,GAAO,SAACrG,GAClC,IAAM+H,EAAanI,GAAa,CAAC+H,EAAUC,IACrCI,EAAYlI,GAAc,CAAEC,WAAYsG,EAAMtG,WAAYC,UAEhE,GAAI6H,EAEFE,EAAWnM,IAAIG,UAAUiM,EAAUxM,OAAQ,EAAG,EAAGmM,EAAUC,OACtD,CAEL,IAAMvF,EAAUsF,EAAW,EAAItB,EAAMtG,WAAW,GAAK,EAC/CuC,EAAUsF,EAAY,EAAIvB,EAAMtG,WAAW,GAAK,EACtDgI,EAAWnM,IAAIG,UACbiM,EAAUxM,OACV6G,EACAC,EACA+D,EAAMtG,WAAW,GACjBsG,EAAMtG,WAAW,IAIrB,OAAOI,GAAc4H,MAGvB,MAAO,CACLhI,WAAY,CAAC4H,EAAUC,GACvBhB,OAAQkB,EAAUlB,SA+BTqB,GAAW,SAAC7I,GAMvB,IAAMoH,EAAMC,GACVrH,EAAKiH,MAAMtG,WACXX,EAAKkH,MAAM,GACXlH,EAAKkH,MAAM,IAEPtG,EAAQZ,EAAKiH,MAAMO,OAAOxH,EAAK+H,YACrCnH,EAAMwG,GAAOpH,EAAK1F,MAAM,GACxBsG,EAAMwG,EAAM,GAAKpH,EAAK1F,MAAM,GAC5BsG,EAAMwG,EAAM,GAAKpH,EAAK1F,MAAM,GAC5BsG,EAAMwG,EAAM,GAAKpH,EAAK1F,MAAM,I,oBClSjBwO,GAAsC,SAAC,GAAD,IAAG5I,EAAH,EAAGA,YAAH,OACjDA,EACE,cAAC6I,EAAA,EAAD,CAASC,MAAO9I,EAAhB,SACE,cAACvF,EAAA,EAAD,CAAMa,SAAS,QAAQlB,MAAM,SAA7B,oBAIA,MCKA2O,GAMD,SAAC,GAAmD,IAAjDjK,EAAgD,EAAhDA,KAAMX,EAA0C,EAA1CA,MAAO6B,EAAmC,EAAnCA,YAAagJ,EAAsB,EAAtBA,MAAOvL,EAAe,EAAfA,SAAe,EAChChE,IAAMC,SAASyE,EAAM6F,YADW,mBAC/CiF,EAD+C,KAC1CC,EAD0C,OAEhBzP,IAAMC,SAAS,IAFC,mBAE/CyP,EAF+C,KAElCC,EAFkC,KAiBtD,OACE,eAACrP,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,eAACqJ,GAAA,EAAD,WACE,cAACzL,EAAA,EAAD,CACEF,QAASyL,EACThL,MAAO8K,EACPlL,OAvBO,WACb,GAAIkL,IAAQ9K,EAAM6F,WAAlB,CAGA,IAAMa,EAAImE,EAAMC,GACZpE,EAAEyE,OACJF,EAAe,IACf3L,EAASoH,EAAE1G,QAEXiL,EAAevE,EAAE0E,UAeb9L,SAAU,SAACO,GACTkL,EAAOlL,EAAEE,OAAOC,UAGnBgL,GAAe,cAACK,GAAA,EAAD,UAAiBL,WAM5BM,GAAW,SAAC3J,GAAD,MAMM,CAC5BhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GAAY,IACP+E,EAAahF,EAAbgF,IAAKC,EAAQjF,EAARiF,IAkBb,OACE,cAAC,GAAD,CACEjG,KAAMgB,EAAKhB,KACXkB,YAAaF,EAAKE,YAClBgJ,MArBU,SAACjF,GACb,IAAMc,EAAIT,SAASL,EAAG,IACtB,OAAI4F,MAAM9E,IAAMA,EAAEb,aAAeD,EACxB,CAAEuF,OAAO,EAAOC,OAAQ,2BAErBnL,IAAR0G,GAAqBD,EAAIC,EACpB,CACLwE,OAAO,EACPC,OAAO,oCAAD,OAAsCzE,SAGpC1G,IAAR2G,GAAqBF,EAAIE,EACpB,CAAEuE,OAAO,EAAOC,OAAO,iCAAD,OAAmCxE,IAE3D,CAAEuE,OAAO,EAAMnL,MAAO0G,IAQ3BpH,SAAUsC,EAAOtC,SACjBU,MAAO4B,EAAO5B,W,oBCvFtB,IAAMyL,GAQD,SAAC,GAA4D,IAA1D9K,EAAyD,EAAzDA,KAAMX,EAAmD,EAAnDA,MAAO2G,EAA4C,EAA5CA,IAAKC,EAAuC,EAAvCA,IAAK8E,EAAkC,EAAlCA,KAAM7J,EAA4B,EAA5BA,YAA4B,ECP1D,YAAsE,IAA5C8J,EAA2C,EAA3CA,QAASC,EAAkC,EAAlCA,SAAUC,EAAwB,EAAxBA,WAAwB,EACpDvQ,IAAMC,SAASoQ,GADqC,mBACnEb,EADmE,KAC9DC,EAD8D,KAEpEe,EAAmBC,aACvBH,EAD0C,OAE1CC,QAF0C,IAE1CA,IAZiB,KA+BnB,MAAO,CAACf,EAhBaxP,IAAM0Q,aACzB,SAACC,GACClB,EAAOkB,GACPH,EAAiBG,KAEnB,CAACH,IAGkBxQ,IAAM0Q,aACzB,SAACC,GACClB,EAAOkB,GACPL,EAASK,KAEX,CAACL,KDZmBM,CAAY,CAChCP,QAAS3L,EACT4L,SAH6D,EAAftM,WAAe,mBACxDwL,EADwD,KACnDC,EADmD,KAM/D,OACE,eAACnP,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,eAACjG,EAAA,EAAD,CACEO,UAAU,MACVE,QAAS,EACTa,GAAI,CAAEF,YAAa,MAAOmP,aAAc,OAH1C,UAKE,cAACC,GAAA,EAAD,CACEC,aAAY1L,EACZX,MAAO8K,EACPY,KAAMA,EACNY,kBAAkB,MAClBC,iBAAkB,SAACrN,GAAD,OAAOA,EAAE2G,YAC3Bc,IAAKA,EACLC,IAAKA,EACLtH,SAAU,SAACO,EAAGG,GACZ+K,EAAO/K,MAGX,cAACtD,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6BgP,WAM9B,SAAS0B,GAAY7K,GAQ1B,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXX,MAAO4B,EAAO5B,MACdV,SAAUsC,EAAOtC,SACjBqH,IAAKhF,EAAKgF,IACVC,IAAKjF,EAAKiF,IACV8E,KAAM/J,EAAK+J,KACX7J,YAAaF,EAAKE,gBEnErB,IAAM4K,GAAc/K,EAAY,CACrCf,KAAM,eACNkB,YAAa,mDACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,QACNkB,YACE,qGACF0J,aAAc,SAAC3C,GAAD,OAAYA,EAAQA,EAAMtG,WAAW,GAAK,GACxDqE,IAAK,IAEP2E,GAAS,CACP3K,KAAM,SACNkB,YACE,qGACF0J,aAAc,SAAC3C,GAAD,OAAYA,EAAQA,EAAMtG,WAAW,GAAK,GACxDqE,IAAK,IAEP6F,GAAY,CACV7L,KAAM,aACNgG,KAAM,IACNC,IAAK,IACL8E,KAAM,EACNH,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,WACNgG,KAAM,IACNC,IAAK,IACL8E,KAAM,EACNH,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,aACNgG,KAAM,IACNC,IAAK,IACL8E,KAAM,EACNH,aAAc,KAGlBxJ,GAAI,YASG,IARL6G,EAQI,EARJA,MAQI,gBAPJY,WAOI,GANFkD,EAME,KALFC,EAKE,KAJFjJ,EAIE,KAHFC,EAGE,KAFFE,EAEE,mBAC0B+E,EAAMtG,WADhC,GACGsK,EADH,KACaC,EADb,KAGEC,EAAiBJ,EAAgB,GAAKC,EAAiB,EAGvDzC,EACJ4C,GAAoC,IAAlBJ,EACd3H,KAAKgI,KAAMH,EAAWC,EAAaF,GACnCD,EACAvC,EACJ2C,GAAqC,IAAnBH,EACd5H,KAAKgI,KAAMF,EAAYD,EAAYF,GACnCC,EAGAK,EAAgB9C,EAAWC,EAAYyC,EAAWC,EAEpDI,EAAYrE,EAmChB,OAhCIkE,IAAmBE,IACrBC,EAAYhD,GAAY,CACtBrB,MAAOqE,EACP/C,WACAC,YACAC,WAAW,KAIf6C,EAAYhE,GAAUgE,GAAW,SAACxD,GAAD,OAC/B3G,GAAqB,CACnBR,WAAY2K,EAAU3K,WACtBC,MAAOkH,EACP1G,UAAW,SAACJ,GAAD,OACTa,GAAYb,EAAY,CACtBe,WAAYA,EAAa,IACzBC,SAAUA,EAAW,IACrBE,WAAYA,EAAa,YAM7BiJ,GAAkBE,IACpBC,EAAYhD,GAAY,CACtBrB,MAAOqE,EACP/C,WACAC,YACAC,WAAW,KAIR6C,K,UC/FLC,GAAuC,SAAC,GAAD,IAAGjR,EAAH,EAAGA,MAAH,OAC3C,qBACED,MAAO,CACLc,MAAO,QACPoB,OAAQ,QACRiP,gBAAiB7H,GAAWrJ,OAK5BmR,GAKD,SAAC,GAA4C,IAA1CzM,EAAyC,EAAzCA,KAAMX,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SAChC,OACE,cAAC,EAAD,CACElE,QACE,eAACQ,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,IACzB7B,GAAS,cAAC,GAAD,CAAU/D,MAAO+D,OALjC,SASE,cAAC,KAAD,CACEqN,cAAc,EACdC,aAAc,GACdrR,MAAOqJ,GAAWtF,GAClBuN,iBAAkB,SAAC5H,GACjBrG,EAASyG,GAAaJ,EAAEK,YAO3B,SAASwH,GAAiB7L,GAK/B,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXX,MAAO4B,EAAO5B,MACdV,SAAUsC,EAAOtC,SACjBuC,YAAaF,EAAKE,gBCtDrB,IAAMsL,GAAkBzL,EAAY,CACzCf,KAAM,mBACNkB,YAAa,mDACbD,OAAQ,CACN4L,GAAiB,CACf7M,KAAM,QACN4K,aAAcxF,GAAa,aAE7ByG,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuBvN,EAAvB,KAA8B2H,EAA9B,YACFqF,GAAUL,GAAO,SAACrG,GAChB,IAAMc,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,WAAYgG,GAAUR,EAAMtG,YAAY,kBAAMrG,KAC9CoH,qB,UC/BFoK,GAKD,SAAC,GAA4C,IAA1C9M,EAAyC,EAAzCA,KAAMX,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SAChC,OACE,cAAC1D,EAAA,EAAD,CAAOS,QAAS,EAAhB,SACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAAQ4R,WAAW,SAAvC,SACG/M,IAEH,sBAAM3E,MAAO,CAAE0R,WAAY,UAA3B,SACE,cAAC,GAAD,CAAa7L,YAAaA,MAE5B,cAAC8L,GAAA,EAAD,CACEtB,aAAY1L,EACZiN,QAAS5N,EACTV,SAAU,SAACO,GAAD,OAAOP,EAASO,EAAEE,OAAO6N,kBAOtC,SAASC,GAAclM,GAK5B,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXX,MAAO4B,EAAO5B,MACdV,SAAUsC,EAAOtC,SACjBuC,YAAaF,EAAKE,gBCjC5B,IAAMiM,GAA2B,CAC/B3N,QACE,shCACFyI,MAAO,CACLtG,WAAY,CAAC,EAAG,GAChB6G,OAAQ,CAAC,IAAIG,kBAAkB,CAAC,EAAG,EAAG,EAAG,S,kCCJvCyE,GAMD,SAAC,GAAqD,IAAnDpN,EAAkD,EAAlDA,KAAMqN,EAA4C,EAA5CA,QAAShO,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SACzC,OACE,eAAC1D,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,cAACqJ,GAAA,EAAD,CAAa3K,UAAU,WAAvB,SACE,cAAC0N,GAAA,EAAD,CACE5B,aAAY1L,EACZ4K,aAAcvL,EACdV,SAAU,SAACsB,GAAD,OAAWtB,EAASsB,EAAMb,OAAOC,QAH7C,SAKGgO,EAAQ/O,KAAI,SAACiP,GAAD,OACX,cAACC,GAAA,EAAD,CACEnO,MAAOkO,EAAElO,MACToO,QAAS,cAACC,GAAA,EAAD,IACT3O,MAAOwO,EAAEvN,MACJuN,EAAElO,kBASd,SAASsO,GAA6B3M,GAM3C,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXX,MAAO4B,EAAO5B,MACdgO,QAASrM,EAAKqM,QACdnM,YAAaF,EAAKE,YAClBvC,SAAU,SAACsG,GAAD,OAAOhE,EAAOtC,SAASsG,QC1DpC,IFiBA,GEjBM2I,GAAkB7M,EAAY,CACzCf,KAAM,mBACNkB,YAAa,gEACbC,qBACE,4GAEFF,OAAQ,EFWH,GEVc,CACfjB,KAAM,SFYH,CACLA,KAFiD,GADnDA,KAIE4K,aAAc,kBAAMuC,IACpB/L,GAAI,SAACH,GAAD,OACF,cAAC,EAAD,CACEvC,gBAAiBuC,EAAO5B,MAAMG,QAC9BrD,MAAO,GACPoB,OAAQ,GACRoB,SAAQ,uCAAE,WAAOa,GAAP,eAAA5C,EAAA,sEACYiR,GAAUrO,GADtB,OACFyI,EADE,OAERhH,EAAOtC,SAAS,CAAEa,UAASyI,UAFnB,2CAAF,2DElBZ0F,GAAwC,CACtC3N,KAAM,OACN4K,aAAc,aACdyC,QAAS,CACP,CACErN,KAAM,aACNX,MAAO,cAET,CACEW,KAAM,aACNX,MAAO,iBAIb6N,GAAc,CACZlN,KAAM,cACN4K,cAAc,EACd1J,YACE,uFAGNE,GAAI,YAAoE,IAAjE6G,EAAgE,EAAhEA,MAAgE,gBAAzDY,WAAyD,GAA5CiF,EAA4C,KAAvBjO,EAAuB,KAAjB4J,EAAiB,KAC/DsE,EAAazE,GAAY,CAC7BrB,MAAO6F,EAAoB7F,MAC3BsB,SAAUtB,EAAMtG,WAAW,GAC3B6H,UAAWvB,EAAMtG,WAAW,GAC5B8H,cAGF,OAAOnB,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GAC1C,IAAMC,EAAoBF,EAAaC,EAEjCgF,EAAkBtM,GAAc,CACpCC,WAAYsG,EAAMtG,WAClBC,UAGIqM,EAAuB7J,KAAKwB,MAChCqD,EAAoB8E,EAAWvF,OAAOnF,QAElC6K,EAAmBxM,GAAc,CACrCC,WAAYoM,EAAWpM,WACvBC,MAAOmM,EAAWvF,OAAOyF,KAG3B,OAAOzL,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,WAAqB,eAAT5C,EAAwBqO,EAAmBF,EACvDtL,WAAqB,eAAT7C,EAAwBmO,EAAkBE,UC5DjDpL,GAAO/B,EAAY,CAC9Bf,KAAM,OACNkB,YAAa,kBACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,SACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,MAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAoB3B,EAAvB,cAAUuC,WAAV,aACFP,GAAUL,GAAO,SAACrG,GAAD,OACfO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEc,KAAMwD,aCjBtD6H,GAASpN,EAAY,CAChCf,KAAM,SACNkB,YAAa,oCACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,eACNkB,YAAa,kBACb0J,aAAc,SAAC3C,GAAD,OACZA,EAAQ7D,KAAKwB,MAAMqC,EAAMtG,WAAW,GAAK,IAAM,IACjDqE,IAAK,KAGT5E,GAAI+H,IACF,gBAAGF,EAAH,EAAGA,kBAAgCmF,EAAnC,cAAsBvF,WAAtB,YAAiD,CAC/CwF,QAASjK,KAAKkK,MAAMF,EAAQhK,KAAKmK,IAAwB,EAApBtF,EAAwB7E,KAAKC,SAEpE,gBAAegK,EAAf,EAAGhF,SAAYgF,QAAf,gBAA0BnG,MAA1B,GAAkC3J,EAAlC,KAAqC4J,EAArC,YACEe,EADF,EAAyCA,aAC3B,CAAC3K,EAAG4J,EAAIkG,S,8BClBbG,GAAkBzN,EAAY,CACzCf,KAAM,mBACNkB,YAAa,8DACbC,qBAAsB,+CACtBF,OAAQ,GACRG,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,MAAgB,CAClBtG,WAAYsG,EAAMtG,WAClB6G,OAAQiG,aACNxG,EAAMO,OACNkG,YAAKzG,EAAMO,OAAQmG,aAAK,GAAIC,eAAWD,aAAK,SCRrCE,GAAS9N,EAAY,CAChCf,KAAM,SACNkB,YAAa,4CACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,SACNkB,YAAa,kBACb0J,aAAc,SAAC3C,GAAD,OACZA,EAAQ7D,KAAKwB,MAAMqC,EAAMtG,WAAW,GAAK,IAAM,IACjDqE,IAAK,KAGT5E,GAAI+H,IACF,gBAAGF,EAAH,EAAGA,kBAAgC6F,EAAnC,cAAsBjG,WAAtB,YAAkD,CAChDkG,QAAS3K,KAAKkK,MAAMQ,EAAS1K,KAAKmK,KAAK,EAAInK,KAAKC,GAAK4E,IACrDoF,QAASjK,KAAKkK,MAAMQ,EAAS1K,KAAK4K,KAAK,EAAI5K,KAAKC,GAAK4E,QAEvD,oBAAGI,SAAY0F,EAAf,EAAeA,QAASV,EAAxB,EAAwBA,QAAxB,gBAAmCnG,MAAnC,GAA2C3J,EAA3C,KAA8C4J,EAA9C,YACEe,EADF,EAAkDA,aACpC,CAAC3K,EAAIwQ,EAAS5G,EAAIkG,SCM9BY,GAA0D,SAAC,GAO1D,IANLjP,EAMI,EANJA,KACAkP,EAKI,EALJA,aACAC,EAII,EAJJA,eACA9P,EAGI,EAHJA,MACA6B,EAEI,EAFJA,YACAvC,EACI,EADJA,SACI,EACwBhE,IAAMC,SAChCyE,EAAMf,KAAI,SAAC8Q,GAAD,MAAQ,CAAEC,MAAOF,IAAkBG,OAAQF,OAFnD,mBACGnO,EADH,KACWsO,EADX,KAIJ,OACE,cAACC,EAAA,EAAD,UACE,eAACvU,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE3BD,EAAO3C,KAAI,WAAoB8J,GAAS,IAA1BiH,EAAyB,EAAzBA,MAAOC,EAAkB,EAAlBA,OACdG,EAAMJ,EAAMjO,GAAG,CACnB/B,MAAOiQ,EACP3Q,SAAU,SAAC+Q,GACT,IAAMC,EAAI1O,EAAO3C,KAAI,SAACsR,EAAMpR,GAC1B,OAAI4J,IAAQ5J,EACH,CACL6Q,QACAC,OAAQI,GAGLE,KAETL,EAAUI,GACVhR,EAASgR,EAAErR,KAAI,SAACyH,GAAD,OAAOA,EAAEuJ,cAI5B,OACE,eAACrU,EAAA,EAAD,CAAOO,UAAU,MAAjB,UACE,cAACqU,EAAA,EAAD,CACEzU,QAAS,WACP,IAAM0U,EAAY7O,EAAOmC,QAAO,SAAC7E,EAAGC,GAAJ,OAAUA,IAAM4J,KAChDmH,EAAUO,GACVnR,EAASmR,EAAUxR,KAAI,SAACyH,GAAD,OAAOA,EAAEuJ,YAElCjU,MAAO,CACL0U,WACU,IAAR3H,EACI,cACA9I,GAVV,SAaE,cAAC3D,EAAA,EAAD,uBAED8T,IAhBH,UAA+BzP,EAA/B,YAAuCoI,OAoB3C,cAAClN,EAAA,EAAD,CACEC,QAAQ,YACRC,QAAS,WACP,IAAMuU,EAAIR,IACJW,EAAuB,sBACxB7O,GADwB,CAE3B,CACEoO,MAAOM,EACPL,OAAQK,EAAE/E,kBAGd2E,EAAUO,GACV,IAAME,EAAOF,EAAUxR,KAAI,SAACyH,GAAD,OAAOA,EAAEuJ,UACpC3Q,EAASqR,IAbb,SAgBGd,UAOJ,SAASe,GAAwCjP,GAOtD,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXkP,aAAclO,EAAKkO,aACnB7P,MAAO4B,EAAO5B,MACd8P,eAAgBnO,EAAKmO,eACrBjO,YAAaF,EAAKE,YAClBvC,SAAUsC,EAAOtC,aClH3B,IAAMuR,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA5R,IAAI8G,IAEO+K,GAASpP,EAAY,CAChCf,KAAM,SACNkB,YAAa,yDACbC,qBAAsB,iDACtBF,OAAQ,CACN4K,GAAY,CACV7L,KAAM,sBACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,IACL8E,KAAM,IAERkF,GAAoB,CAClBjQ,KAAM,SACNkP,aAAc,YACdtE,aAAcsF,GACdf,eAAgB,kBACdtC,GAAiB,CACf7M,KAAM,QACN4K,aAAcsF,GAAe,SAIrC9O,GAAI+H,IACF,gBAAGF,EAAH,EAAGA,kBAAH,gBAAsBJ,WAAtB,GAAmCuH,EAAnC,KAAuDD,EAAvD,WAAsE,CACpEC,qBACAC,YAAaF,EAAO/L,KAAKwB,MAAMqD,EAAoBkH,EAAO9M,aAE5D,YAA4E,IAAD,IAAxEgG,SAAY+G,EAA4D,EAA5DA,mBAAoBC,EAAwC,EAAxCA,YAAenI,EAAyB,EAAzBA,MAC1CoI,GAAWpH,EADwD,EAAlBA,aAC1BhB,GAE7B,GAAI1C,GAAc8K,GAChB,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAIMC,ElBnBwB,SAAC,GAAD,uBAAE3L,EAAF,KAAKC,EAAL,KAAQC,EAAR,YAClCV,KAAKkK,OAAO1J,EAAIC,EAAIC,GAAK,GkBkBR0L,CAHXJ,EAAqB,ElBiEG,SAAC9U,EAAcgL,GAC7C,IAAMmK,EAAKnK,EAAS,IAAO,IAD4C,cAElDhL,EAFkD,GAEhEsJ,EAFgE,KAE7DC,EAF6D,KAE1DC,EAF0D,KAEvDlI,EAFuD,KAGvE,OAAOsJ,GAAW,CAACtB,EAAI6L,EAAG5L,EAAI4L,EAAG3L,EAAI2L,EAAG7T,IkBnE9B8T,CAAiBJ,EAAUF,GAC3BE,GAGN,MAAO,CACJC,EAAOF,EAAY,GAAM,IACzBE,EAAOF,EAAY,GAAM,IACzBE,EAAOF,EAAY,GAAM,IAC1B,UC1DFH,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA5R,IAAI8G,IAEOuL,GAAmB5P,EAAY,CAC1Cf,KAAM,oBACNkB,YACE,kEACFD,OAAQ,CACNgP,GAAoB,CAClBjQ,KAAM,SACNkP,aAAc,YACdtE,aAAcsF,GACdf,eAAgB,kBACdtC,GAAiB,CACf7M,KAAM,QACN4K,aAAcsF,GAAe,QAGnCrE,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuBsH,EAAvB,KAA+BlN,EAA/B,YACFqF,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GACnC,IAAMC,EAAoBF,EAAaC,EACjC4H,EAAUT,EAAO/L,KAAKwB,MAAMqD,EAAoBkH,EAAO9M,SAEvDX,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,WAAYgG,GAAUR,EAAMtG,YAAY,kBAAMiP,KAC9ClO,qBC7CFmO,GAMD,SAAC,GAAmD,IAAjD7Q,EAAgD,EAAhDA,KAAMX,EAA0C,EAA1CA,MAAO6B,EAAmC,EAAnCA,YAAagJ,EAAsB,EAAtBA,MAAOvL,EAAe,EAAfA,SAAe,EAChChE,IAAMC,SAASyE,EAAM6F,YADW,mBAC/CiF,EAD+C,KAC1CC,EAD0C,OAEhBzP,IAAMC,SAAS,IAFC,mBAE/CyP,EAF+C,KAElCC,EAFkC,KAkBtD,OACE,eAACrP,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,eAACqJ,GAAA,EAAD,WACE,cAACzL,EAAA,EAAD,CACEF,QAASyL,EACThL,MAAO8K,EACPlL,OAxBO,WACb,GAAIkL,IAAQ9K,EAAM6F,WAAlB,CAIA,IAAMa,EAAImE,EAAMC,GACZpE,EAAEyE,OACJF,EAAe,IACf3L,EAASoH,EAAE1G,QAEXiL,EAAevE,EAAE0E,UAeb9L,SAAU,SAACO,GACTkL,EAAOlL,EAAEE,OAAOC,UAGnBgL,GAAe,cAACK,GAAA,EAAD,UAAiBL,WAM5ByG,GAAa,SAAC9P,GAAD,MAMI,CAC5BhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GAAY,IACP+E,EAAahF,EAAbgF,IAAKC,EAAQjF,EAARiF,IAkBb,OACE,cAAC,GAAD,CACEjG,KAAMgB,EAAKhB,KACXkB,YAAaF,EAAKE,YAClBgJ,MArBU,SAACjF,GACb,IAAMc,EAAIgL,WAAW9L,GACrB,OAAI4F,MAAM9E,IAAMA,EAAEb,aAAeD,EACxB,CAAEuF,OAAO,EAAOC,OAAQ,yBAErBnL,IAAR0G,GAAqBD,EAAIC,EACpB,CACLwE,OAAO,EACPC,OAAO,oCAAD,OAAsCzE,SAGpC1G,IAAR2G,GAAqBF,EAAIE,EACpB,CAAEuE,OAAO,EAAOC,OAAO,iCAAD,OAAmCxE,IAE3D,CAAEuE,OAAO,EAAMnL,MAAO0G,IAQ3BpH,SAAUsC,EAAOtC,SACjBU,MAAO4B,EAAO5B,WC9FT2R,GAAejQ,EAAY,CACtCf,KAAM,gBACNkB,YAAa,aACbD,OAAQ,CACN6P,GAAW,CAAE9Q,KAAM,YAAa4K,aAAc,GAAI5E,IAAK,KAEzD5E,GAAI+H,IACF,gBAAGF,EAAH,EAAGA,kBAAH,MAAqD,CACnD8F,QADF,cAAsBlG,WAAtB,MACuBzE,KAAKmK,KAAK,EAAInK,KAAKC,GAAK4E,OAE/C,YAA4D,IAA7C8F,EAA4C,EAAxD1F,SAAY0F,QAA4C,gBAAjC7G,MAAiC,GAAzB3J,EAAyB,KAAtB4J,EAAsB,KACnD8I,EAAM1S,EAAI,IAAM,GAAK,EAAI,EAC/B,OAAO2K,EAFkD,EAAlBA,aAEpB,CAAC3K,EAAI6F,KAAKkK,MAAM2C,EAAMlC,GAAU5G,SCZ5C+I,GAASnQ,EAAY,CAChCf,KAAM,SACNkB,YAAa,iCACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,SACNkB,YAAa,kBACb0J,aAAc,SAAC3C,GAAD,OACZA,EAAQ7D,KAAKwB,MAAMqC,EAAMtG,WAAW,GAAK,GAAK,IAChDqE,IAAK,KAGT5E,GAAI+H,IACF,gCACExH,WADF,GACexF,EADf,KACsBoB,EADtB,KAEE0L,EAFF,EAEEA,kBACa6F,EAHf,cAGEjG,WAHF,YAIO,CACLsI,KAAM/M,KAAK4K,IAAwB,EAApB/F,EAAwB7E,KAAKC,IAAMyK,EAClDsC,QAASjV,EAAQ,EACjBkV,QAAS9T,EAAS,MAEpB,YAKO,IAAD,IAJJ8L,SAAY+H,EAIR,EAJQA,QAASC,EAIjB,EAJiBA,QAASF,EAI1B,EAJ0BA,KAI1B,gBAHJxP,WAGI,GAHSxF,EAGT,KAHgBoB,EAGhB,qBAFJ2K,MAEI,GAFI3J,EAEJ,KAFO4J,EAEP,KAEEmJ,GAAU/S,EAAI6S,GAAWjV,EACzBoV,GAAUpJ,EAAIkJ,GAAW9T,EAI/B,OAAO2L,EAPH,EADJA,aAQmB,CAAC3K,EAFJ6F,KAAKwB,MAAMuL,EAAOG,GAEDnJ,EADjB/D,KAAKkK,MAAM6C,EAAOI,UC1B3BC,GAAOzQ,EAAY,CAC9BM,UAAU,EACVrB,KAAM,mBACNkB,YACE,oEACFD,OAAQ,CACN4L,GAAiB,CACf7M,KAAM,4BACN4K,aAAc,CAAC,EAAG,EAAG,EAAG,OAE1BiB,GAAY,CACV7L,KAAM,YACN4K,aAAc,GACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,YAGF,IAHqE,IAAzDqQ,EAAwD,EAA/DxJ,MAA+D,gBAA9CY,WAA8C,GAAjC6I,EAAiC,KAAjBC,EAAiB,KAC9D1J,EtB6OoB,SAACA,GAAD,MAA0B,CACtDtG,WAAYsG,EAAMtG,WAClB6G,OAAQP,EAAMO,OAAOlK,KAAI,SAACsT,GAAD,OAAO,IAAIjJ,kBAAkBiJ,OsB/OtCC,CAAeJ,GAGvB1I,EAAa,EACjBA,EAAad,EAAMO,OAAOnF,OAC1B0F,GAAc,EAEd+I,GAAU,CACR7J,QACAc,aACA2I,iBACAK,SAAU5L,GACVwL,cAIJ,OAAO1J,KAKL6J,GAAY,SAAC,GA8BjB,IAlBK,IAXL7J,EAWI,EAXJA,MACAc,EAUI,EAVJA,WACA2I,EASI,EATJA,eACAK,EAQI,EARJA,SACAJ,EAOI,EAPJA,UAQMK,EAAW,WACf,IAAMC,EAAM,IAAIC,IAChB,MAAO,CACLC,IAAK,YAAoB,IAAD,mBAAjB5T,EAAiB,KAAd4J,EAAc,KACtB8J,EAAIE,IAAJ,UAAW5T,EAAX,YAAgB4J,KAElBiK,IAAK,mCAAE7T,EAAF,KAAK4J,EAAL,YAAmB8J,EAAIG,IAAJ,UAAW7T,EAAX,YAAgB4J,MAN3B,GASXkK,EAAiB,CAAC,CAAC,EAAGpK,EAAMtG,WAAW,GAAK,IAC5C2Q,EAAO,SAACpK,GACP8J,EAAQI,IAAIlK,KACf8J,EAAQG,IAAIjK,GACZmK,EAAMC,KAAKpK,KAIRmK,EAAMhP,OAAS,GAAG,CACvB,IAAM6E,EAAQmK,EAAME,MADG,cAERrK,EAFQ,GAEhB3J,EAFgB,KAEb4J,EAFa,KAGvB,KACE5J,EAAI,GACJA,GAAK0J,EAAMtG,WAAW,IACtBwG,EAAI,GACJA,GAAKF,EAAMtG,WAAW,IAJxB,CAUA,IAAM6Q,EAAYxK,GAChBC,EAAMtG,WACNsG,EAAMO,OAAOO,GACbb,GAEyC,IAAvCX,GAAUiL,EAAWd,GAAwBC,IAIjD9H,GAAS,CACP5B,QACAc,aACAzN,MAAOyW,EACP7J,MAAOA,IAGToK,EAAK,CAAC/T,EAAI,EAAG4J,IACbmK,EAAK,CAAC/T,EAAI,EAAG4J,IACbmK,EAAK,CAAC/T,EAAG4J,EAAIA,IACbmK,EAAK,CAAC/T,EAAG4J,EAAI,QC3GJsK,GAAU1R,EAAY,CACjCf,KAAM,UACNkB,YAAa,wDACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,SACNkB,YAAa,kBACb0J,aAAc,SAAC3C,GAAD,OACZA,EAAQ7D,KAAKwB,MAAMqC,EAAMtG,WAAW,GAAK,GAAK,IAChDqE,IAAK,KAGT5E,GAAI+H,IACF,YAIO,IAHLF,EAGI,EAHJA,kBAGI,gBAFJtH,WAEI,GAFSxF,EAET,KAFgBoB,EAEhB,KAEJ,MAAO,CACL4T,MAFgBlI,EAAoB,GAEjBA,EAAoB,EAAIA,GAHzC,cADJJ,WACI,MAIFuI,QAASjV,EAAQ,EACjBkV,QAAS9T,EAAS,MAGtB,YAA2E,IAAD,IAAvE8L,SAAY8H,EAA2D,EAA3DA,KAAMC,EAAqD,EAArDA,QAASC,EAA4C,EAA5CA,QAA4C,gBAAjCnJ,MAAiC,GAAzB3J,EAAyB,KAAtB4J,EAAsB,KAAlBe,EAAkB,EAAlBA,YAChDwJ,EAAQtO,KAAKiD,MAAMgK,EAAUlJ,EAAGiJ,EAAU7S,GAIhD,OAAO2K,EAAY,CAAC3K,EAFJ6F,KAAKkK,MAAM6C,EAAO/M,KAAK4K,IAAI0D,IAEVvK,EADjB/D,KAAKkK,MAAM6C,EAAO/M,KAAKmK,IAAImE,WC3BpCC,GAAO5R,EAAY,CAC9Bf,KAAM,OACNkB,YAAa,4DACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,YACNkB,YAAa,wCACb0J,aAAc,GACd5E,IAAK,EACLC,IAXgB,GAYhB8E,KAAM,IAERc,GAAY,CACV7L,KAAM,aACN4K,aAAc,GACd5E,IAAK,EACLC,IAAK,MAGT7E,GAAIwH,IAAS,YAAgE,IAA7DV,EAA4D,EAA5DA,MAAOgB,EAAqD,EAArDA,YAAqD,gBAAxCL,WAAwC,GAA3B+J,EAA2B,KAAjBC,EAAiB,KACpElD,EAAIzG,EAAYhB,GADoD,cAE3DA,EAF2D,GAEnE3J,EAFmE,KAEhE4J,EAFgE,KAItE2K,GAAW,EACf,GAAID,EAAY,KAAO,EAErBC,EAAWvU,EAAIqU,IAAa,GAAKzK,EAAIyK,IAAa,MAC7C,CAGL,IAAMG,GAhCU,GAiCIH,GAjCJ,GAiCiC,GAAM,IAEjDI,EAAS,SAACC,GACd,IAAMlN,EAAK,EAAI6M,GAAazK,EAAI/D,KAAK8O,IAAIC,GAAMF,IAAiB1U,GAChE,OAAO6F,KAAKgP,IAAIhP,KAAKkK,MAAMvI,GAAKA,GAAKgN,GAGvCD,EAAWE,EAAOH,IAAcG,EAAOH,EAAY,IAGrD,OAAOC,EAAWnD,EzBqEU,SAACrU,EAAcgL,GAA2B,IAAD,cAClDhL,EADkD,GAChEsJ,EADgE,KAC7DC,EAD6D,KAC1DC,EAD0D,KACvDlI,EADuD,OAErD2J,OAAYC,IAAI5B,EAAGC,EAAGC,GAF+B,mBAEhEiC,EAFgE,KAE7D9B,EAF6D,KAE1DwB,EAF0D,KAGjE4M,EAAS9O,GAAcH,KAAKgP,IAAI9M,GAASrB,EAAGqB,GAAU,EAAI,IAAM,GAHC,EAI5CC,OAAYG,IAAI,CAACK,EAAGsM,EAAQ5M,IAJgB,mBAKvE,MAAO,CALgE,eAK7C7J,GyB1EF0W,CAAiB3D,GAAI,UAIzCwD,GAAQ,SAACnP,GAAD,OAAsBA,EAAUI,KAAKC,GAAM,KCxCnDkP,GAKD,SAAC,GAA4C,IAA1CvT,EAAyC,EAAzCA,KAAMX,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SAC1B6U,EAAW7Y,IAAM8Y,SACrB,uBACYnU,IAAVD,OACIC,EACAqF,GAAW,GAAD,mBAAK4B,OAAYG,IAAI,CAACrH,EAAO,IAAK,MAAlC,CAAwC,SACxD,CAACA,IAEH,OACE,eAACpE,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,cAAC,KAAD,CACE5F,MAAOkY,EAEP5G,iBAAkB,gBAAGpG,EAAH,EAAGA,IAAH,OAAa7H,EAAS6H,EAAIO,UAM7C,SAAS2M,GAAe1S,GAK7B,MAAO,CACLhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXX,MAAO4B,EAAO5B,MACdV,SAAUsC,EAAOtC,aC/CpB,IAAMgV,GAAY5S,EAAY,CACnCf,KAAM,aACNkB,YAAa,wDACbD,OAAQ,CACNyS,GAAe,CACb1T,KAAM,MACN4K,aAAc,MAEhBiB,GAAY,CACV7L,KAAM,SACNkB,YAAa,4BACb8E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACNH,aAAc,MAGlBxJ,GAAIwH,IAAS,gBAAGV,EAAH,EAAGA,MAAOgB,EAAV,EAAUA,YAAV,gBAAuBL,WAAvB,GAAoC+K,EAApC,KAA4CtN,EAA5C,YACXF,GAAgB8C,EAAYhB,GAAQ0L,EAAQtN,QCnBnCuN,GAAW9S,EAAY,CAClCf,KAAM,YACNkB,YAAa,0DACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,SACNkB,YAAa,0CACb8E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACNH,aAAc,MAGlBxJ,GAAIwH,IAAS,gBAAGV,EAAH,EAAGA,MAAOgB,EAAV,EAAUA,YAA0B5C,EAApC,cAAuBuC,WAAvB,aACX/B,GAASoC,EAAYhB,GAAS5B,EAAS,IAAO,UCdrCwN,GAAgB/S,EAAY,CACvCf,KAAM,kBACNkB,YAAa,yDACbD,OAAQ,CACNyS,GAAe,CACb1T,KAAM,MACN4K,aAAc,OAGlBxJ,GAAIwH,IACF,YAAwE,IAArEV,EAAoE,EAApEA,MAAOgB,EAA6D,EAA7DA,YAAaF,EAAgD,EAAhDA,WAAYD,EAAoC,EAApCA,WAAyB1C,EAAW,cAAxBwC,WAAwB,MAC/DvC,EAASlC,KAAKgP,IAAIhP,KAAKmK,IAAInK,KAAKC,IAAM0E,EAAaC,KACzD,OAAO5C,GAAgB8C,EAAYhB,GAAQ7B,EAAc,IAATC,QCZzCyN,GAAUhT,EAAY,CACjCf,KAAM,WACNkB,YAAa,yDACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,YACN4K,aAAc,GACd5E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACN7J,YAAa,8CAEf2K,GAAY,CACV7L,KAAM,SACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,GACL/E,YAAa,6BAGjBE,GAAI+H,IACF,kBAA4B,CAC1B6K,OAAQ,EADV,EAAG/K,kBAC+B,EAAI7E,KAAKC,OAE3C,YAMO,IALO2P,EAKR,EALJ3K,SAAY2K,MACZ9L,EAII,EAJJA,MACe3K,EAGX,cAHJoE,WAGI,sBAFJkH,WAEI,GAFSoL,EAET,KAFoBC,EAEpB,KADJhL,EACI,EADJA,YAESf,EADL,YACUD,EADV,MAEE5B,EAASlC,KAAKkK,MAClB2F,EAAY7P,KAAKmK,IAAKpG,EAAI5K,EAAU2W,EAAS9P,KAAKC,GAAK2P,IAGzD,OAAOlN,GAASoC,EAAYhB,GAAS5B,EAAS,IAAO,UChCrD6N,GAKD,SAAC,GAA4C,IAA1CnU,EAAyC,EAAzCA,KAAMX,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SAAe,EACzBhE,IAAMC,SAASyE,GADU,mBACxC8K,EADwC,KACnCC,EADmC,KAG/C,OACE,eAACnP,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,cAACqJ,GAAA,EAAD,UACE,cAACzL,EAAA,EAAD,CACEO,MAAO8K,EACPxL,SAAU,SAACO,GAAD,OAAOkL,EAAOlL,EAAEE,OAAOC,QACjCJ,OAAQ,WACFkL,EAAI9G,OAAS,GACf1E,EAASwL,YASViK,GAAY,SAACpT,GAAD,MAIK,CAC5BhB,KAAMgB,EAAKhB,KACX4K,aAAc9J,EAAgBE,EAAK4J,cACnCxJ,GAAI,SAACH,GAAD,OACF,cAAC,GAAD,CACEjB,KAAMgB,EAAKhB,KACXkB,YAAaF,EAAKE,YAClBvC,SAAUsC,EAAOtC,SACjBU,MAAO4B,EAAO5B,WCxCdgV,GAAgC,CACpC,CAAC,EAAG,GAAI,GAAI,KACZ,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,MAGLC,GAAYvT,EAAY,CACnCf,KAAM,YACNkB,YAAa,+CACbD,OAAQ,CACNmT,GAAU,CACRpU,KAAM,cACNkB,YACE,mEACF0J,aAAc,eAGlBxJ,GAAI,YAAoC,IAAjC6G,EAAgC,EAAhCA,MAAoBsM,EAAY,cAAzB1L,WAAyB,MAC/BlD,EAAS6O,IAAWD,GAC1B,OAAOjM,GAAUL,GAAO,SAAC/F,GACvB,IAAM1D,EAAImH,IACJ8O,EAAiBjW,EAAI,GAAM,EAAIA,EAAI,IAAO,EAAIA,EAAI,IAAO,EAAI,EAEnE,OAAOiK,GAAUR,EAAMtG,YAAY,SAACuG,GAClC,IAAMpK,EAAMkK,GAAmBC,EAAMtG,WAAYO,EAAMgG,GAEvD,GAAI1C,GAAc1H,GAChB,OAAOuW,GAAqBI,GAG9B,GAAIA,EAAiB,EAAG,CAEtB,IAAMC,EAAM,KAAOD,EACnB,MAAO,CAAC3W,EAAI,GAAK4W,EAAK5W,EAAI,GAAK4W,EAAK5W,EAAI,GAAK4W,EAAK5W,EAAI,IAIxD,OAAOA,WC5CF6W,GAAS5T,EAAY,CAChCf,KAAM,SACNkB,YAAa,oBACbD,OAAQ,GACRG,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,OACFK,GAAUL,GAAO,SAACrG,GAAD,OACfO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OACTuB,GAAevB,EAAY,CACzBwB,iBAAkB,EAClBI,sBAAuBqE,EAAMtG,WAAW,cCZvCiT,GAAO7T,EAAY,CAC9Bf,KAAM,OACNkB,YAAa,WACbD,OAAQ,GACRG,GAAIwH,IAAS,YAAgD,IAA7CV,EAA4C,EAA5CA,MAAOgB,EAAqC,EAArCA,YACf6J,EAAgC,IADoB,EAAxB9J,kBAAwB,EAErCC,EAAYhB,GAFyB,mBAEnDtD,EAFmD,KAEhDC,EAFgD,KAE7CC,EAF6C,KAE1ClI,EAF0C,OAGxC2J,OAAYC,IAAI5B,EAAGC,EAAGC,GAHkB,mBAGnDiC,EAHmD,KAGhD9B,EAHgD,KAG7CwB,EAH6C,OAI/BF,OAAYG,IAAI,CAACK,EAAG9B,EAAGwB,EAAIsM,EAAYtM,EAAI,IAJZ,mBAK1D,MAAO,CALmD,eAKhCA,EAAIsM,EAAYnW,EAAI,QCRrCqG,GAAUlC,EAAY,CACjCf,KAAM,UACNkB,YAAa,gCACbC,qBACE,wJAGFF,OAAQ,CACN4K,GAAY,CACV7L,KAAM,SACN4K,aAAc,GACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAoB3B,EAAvB,cAAUuC,WAAV,aACFP,GAAUL,GAAO,SAACrG,GAAD,OACfO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,QAASqD,aCpBzDuO,GAAQ9T,EAAY,CAC/Bf,KAAM,QACNkB,YAAa,8DACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,SACNkB,YAAa,2BACb8E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACNH,aAAc,KAEhBiB,GAAY,CACV7L,KAAM,cACNkB,YAAa,4DACb8E,IAAK,EACLC,IAAK,GACL2E,aAAc,KAGlBxJ,GAAIwH,IACF,YAKO,IAJLV,EAII,EAJJA,MACAgB,EAGI,EAHJA,YACAD,EAEI,EAFJA,kBAEI,gBADJJ,WACI,GADSvC,EACT,KACEwO,EAAQ7L,EADV,KAC2C,IAAO,IAChDqH,EAAWpH,EAAYhB,GAC7B,OAAO9B,GAAgBkK,EAAUwE,EAAMxO,QCxBhCyO,GAAkBhU,EAAY,CACzCf,KAAM,mBACNkB,YACE,6EACFD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,4DACb8E,IAAK,EACLC,IAAK,GACL2E,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuBmM,EAAvB,KAAmC/R,EAAnC,YACFqF,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GACnC,IAEM4H,EAAUtJ,GAFUyB,EAAaC,EACLgM,EAAa,IAAO,KAGhDtS,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,WAAYgG,GAAUR,EAAMtG,YAAY,kBAAMiP,KAC9ClO,qBC3CKuS,GAAclU,EAAY,CACrCf,KAAM,eACNkB,YACE,0EACFD,OAAQ,GACRG,GAAIwH,IAAS,gBAAGV,EAAH,EAAGA,MAAOgB,EAAV,EAAUA,YAAaD,EAAvB,EAAuBA,kBAAvB,OACXnC,GAASoC,EAAYhB,GAA4B,IAApBe,QCG3BiH,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA5R,IAAI8G,IAEO8P,GAAiBnU,EAAY,CACxCf,KAAM,kBACNkB,YAAa,0DACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,wCACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEPgK,GAAoB,CAClBjQ,KAAM,SACNkP,aAAc,YACdhO,YAAa,0BACb0J,aAAcsF,GACdf,eAAgB,kBACdtC,GAAiB,CACf7M,KAAM,QACN4K,aAAcsF,GAAe,QAGnCvF,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,YAYF,IATK,IAFL6G,EAEI,EAFJA,MAEI,gBADJY,WACI,GADSsM,EACT,KADqBhF,EACrB,KAD6BlM,EAC7B,KADsCC,EACtC,KAD+CjB,EAC/C,mBACoBgF,EAAMtG,WAD1B,GACGxF,EADH,KACUoB,EADV,KAGE6X,EAAcjF,EAAO9M,OAAS8R,EAC9BE,EAAmBjR,KAAKkK,MAAM,IAAM8G,GAItCE,EAAenF,EAAO9M,OACmC,QAArD+R,EAAcE,GAAcC,QAAQ,GAAGC,OAAO,IACpDF,GAAgB,EAGlB,IAAMG,EAAgB,CAACtZ,EAAQ,EAAI8H,EAAS1G,EAAS,EAAI2G,GAEzD,OAAOoE,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GAC1C,IAAMC,EAAoBF,EAAaC,EAEjCvG,EAAagG,GAAUR,EAAMtG,YAAY,SAACuG,GAC9C,IAAMwN,EAAa1O,GAAekB,EAAOuN,GAEnCE,EACJvR,KAAKwB,MAAM8P,EAAaL,GAAoBC,EAGxClN,GACHhE,KAAKwB,MAAMqD,EAAoBqM,GAAgBK,GAChDL,EACF,OAAOnF,EAAO/H,MAGV1F,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,aACAC,qBCvGKkT,GAAkB7U,EAAY,CACzCf,KAAM,mBACNkB,YAAa,8CACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,0CACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEP4F,GAAY,CACV7L,KAAM,WACNgG,IAAK,EACLC,IAAK,IACL8E,KAAM,EACNH,aAAc,KAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,KAGlBxJ,GAAI+H,IACF,YAGO,IAAD,gBAFJxH,WAEI,GAFSxF,EAET,KAFgBoB,EAEhB,qBADJsL,WACI,aAEJ,MAAO,CAAE4M,OADa,CAACtZ,EAAQ,EAD3B,KACwCoB,EAAS,EADjD,UAIN,YAMO,IALOkY,EAKR,EALJpM,SAAYoM,OACZvN,EAII,EAJJA,MACAe,EAGI,EAHJA,kBACAC,EAEI,EAFJA,YAEI,gBADJL,WACI,GADSsM,EACT,KADqBU,EACrB,KACEvF,EAAWpH,EAAYhB,GAEvBwN,EAAa1O,GAAekB,EAAOuN,GAGzC,OAAOrP,GAAgBkK,GAFToF,EAAaP,EAAiC,IAApBlM,GAA2B,IAE5B4M,QC5ChCC,GAA4B/U,EAAY,CACnDf,KAAM,8BACNkB,YAAa,iDACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,0CACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEP0E,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuBsM,EAAvB,KAAmClR,EAAnC,KAA4CC,EAA5C,KAAqDjB,EAArD,YACFqF,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GACnC,IAAMC,EAAoBF,EAAaC,EADW,cAE1Bf,EAAMtG,WAFoB,GAE3CxF,EAF2C,KAEpCoB,EAFoC,KAG5CkY,EAAgB,CAACtZ,EAAQ,EAAI8H,EAAS1G,EAAS,EAAI2G,GAEnDzB,EAAagG,GAAUR,EAAMtG,YAAY,SAACuG,GAC9C,IAAMwN,EAAa1O,GAAekB,EAAOuN,GAEzC,OAAOnO,IADOoO,EAAaP,EAAiC,IAApBlM,GAA2B,QAI/DvG,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,aACAC,qBCjDFwN,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA5R,IAAI8G,IAEO2Q,GAAiBhV,EAAY,CACxCf,KAAM,kBACNkB,YAAa,0DACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,wCACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEPgK,GAAoB,CAClBjQ,KAAM,SACNkP,aAAc,YACdhO,YAAa,oCACb0J,aAAcsF,GACdf,eAAgB,kBACdtC,GAAiB,CACf7M,KAAM,QACN4K,aAAcsF,GAAe,QAGnCvF,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,YAGG,IAFL6G,EAEI,EAFJA,MAEI,gBADJY,WACI,GADSsM,EACT,KADqBhF,EACrB,KAD6BlM,EAC7B,KADsCC,EACtC,KAD+CjB,EAC/C,KACJ,OAAOqF,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GAC1C,IAAMC,EAAoBF,EAAaC,EADkB,cAEjCf,EAAMtG,WAF2B,GAElDxF,EAFkD,KAE3CoB,EAF2C,KAInDyY,EAAYC,aAAM,EAAGd,GAAYe,SAAQ,kBAAM/F,KAC/CiB,EAAUjV,EAAQ,EAClBkV,EAAU9T,EAAS,EAEnBkF,EAAagG,GAAUR,EAAMtG,YAAY,YAAa,IAAD,mBAAVpD,EAAU,KAAP4J,EAAO,KACnDhB,EAAa5I,EAAI6S,EAAUnN,EAC3BmD,EAAae,EAAIkJ,EAAUnN,EAE3BiS,EAAU/R,KAAK2D,KAClB5L,EAAQ,GAAMA,EAAQ,GAAMoB,EAAS,GAAMA,EAAS,IAEjD6Y,EAAiBhS,KAAK2D,KAC1BX,EAAaA,EAAaD,EAAaA,GAGnCwO,EACJvR,KAAKwB,OAAO,EAAIwQ,EAAiBD,GAAWH,EAAU3S,QACtD2S,EAAU3S,OAGN+E,GACHhE,KAAKwB,MAAMqD,EAAoB+M,EAAU3S,QAAUsS,GACpDK,EAAU3S,OACZ,OAAO2S,EAAU5N,MAGb1F,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,aACAC,qBCxGK2T,GAAkBtV,EAAY,CACzCf,KAAM,mBACNkB,YAAa,sCACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,0CACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEP4F,GAAY,CACV7L,KAAM,WACNgG,IAAK,EACLC,IAAK,IACL8E,KAAM,EACNH,aAAc,KAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,KAGlBxJ,GAAI+H,IACF,gCAAGxH,WAAH,GAAgBxF,EAAhB,KAAuBoB,EAAvB,WAAsC,CACpC6T,QAASjV,EAAQ,EACjBkV,QAAS9T,EAAS,EAClB4Y,QAAS/R,KAAK2D,KACX5L,EAAQ,GAAMA,EAAQ,GAAMoB,EAAS,GAAMA,EAAS,QAGzD,YAMO,IAAD,IALJ8L,SAAY+H,EAKR,EALQA,QAASC,EAKjB,EALiBA,QAAS8E,EAK1B,EAL0BA,QAC9BjO,EAII,EAJJA,MACAe,EAGI,EAHJA,kBAGI,gBAFJJ,WAEI,GAFSsM,EAET,KAFqBU,EAErB,KAF+B5R,EAE/B,KAFwCC,EAExC,KACEpG,GAAMoL,EADR,EADJA,aAEwBhB,GADpB,cAGWA,EAHX,GAIEf,EAJF,KAImBiK,EAAUnN,EAC3BmD,EALF,KAKmBiK,EAAUnN,EAE3BkS,EAAiBhS,KAAK2D,KAC1BX,EAAaA,EAAaD,EAAaA,GAQzC,OAAOf,GAAgBtI,GAJa,KAAhC,EAAIsY,EAAiBD,GAAiBhB,EACtC,IAAMlM,GACR,IAEgC4M,QCtD3BS,GAA4BvV,EAAY,CACnDf,KAAM,8BACNkB,YAAa,sCACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,cACNkB,YAAa,0CACb0J,aAAc,EACd5E,IAAK,EACLC,IAAK,KAEP0E,GAAS,CACP3K,KAAM,WACNkB,YAAa,+CACb0J,aAAc,IAEhBD,GAAS,CACP3K,KAAM,WACNkB,YAAa,6CACb0J,aAAc,IAEhBiB,GAAY,CACV7L,KAAM,qBACN4K,aAAc,IACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuBsM,EAAvB,KAAmClR,EAAnC,KAA4CC,EAA5C,KAAqDjB,EAArD,YACFqF,GAAUL,GAAO,SAACrG,EAAOmH,EAAYC,GACnC,IAAMC,EAAoBF,EAAaC,EADW,cAE1Bf,EAAMtG,WAFoB,GAE3CxF,EAF2C,KAEpCoB,EAFoC,KAG5C6T,EAAUjV,EAAQ,EAClBkV,EAAU9T,EAAS,EACnB4Y,EAAU/R,KAAK2D,KAClB5L,EAAQ,GAAMA,EAAQ,GAAMoB,EAAS,GAAMA,EAAS,IAGjDkF,EAAagG,GAAUR,EAAMtG,YAAY,YAAa,IAAD,mBAAVpD,EAAU,KAAP4J,EAAO,KACnDhB,EAAa5I,EAAI6S,EAAUnN,EAC3BmD,EAAae,EAAIkJ,EAAUnN,EAE3BkS,EAAiBhS,KAAK2D,KAC1BX,EAAaA,EAAaD,EAAaA,GAQzC,OAAOG,IAJ6B,KAAhC,EAAI8O,EAAiBD,GAAiBhB,EACtC,IAAMlM,GACR,QAKEvG,EACQ,MAAZO,EACIrB,EACAO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgBa,GAAYb,EAAY,CAAEiB,eAG7D,OAAOT,GAAc,CACnBb,WAAYsG,EAAMtG,WAClBc,aACAC,qB,UC7DK6T,GAAqBxV,EAAY,CAC5Cf,KAAM,uBACNkB,YACE,0EACFC,qBACE,uEACFF,OAAQ,CACN4K,GAAY,CACV7L,KAAM,oBACNkB,YACE,kFACF0J,aAAc,GACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAI+H,IACF,YAAgD,IAA7ClB,EAA4C,EAA5CA,MAAoBuO,EAAwB,cAArC3N,WAAqC,MAGvC4N,EAAe,IAAIvE,IACzB5J,GAAUL,GAAO,SAACrG,GAAD,OACf6G,GAAUR,EAAMtG,YAAY,SAACuG,GAC3B,IAAMwO,EAAK1O,GAAmBC,EAAMtG,WAAYC,EAAOsG,GAEvD,OADAuO,EAAatE,IAAIxN,GAAW+R,IACrBvQ,SAqBX,IAjBA,IAAMwQ,EAAYxW,MAAMC,KAAKqW,GAAcnY,IAAI8G,IACzCwR,EAAYxS,KAAK6B,IACrB7B,KAAKwB,MAAO+Q,EAAUtT,QAAU,IAAMmT,GAAqB,KAC3D,GAQIK,EACJF,EAAUrY,KAAI,SAAC0G,GAAD,MAAQ,CACpB1J,MAAO0J,EACP8R,iBAAkB,MAGbtY,EAAI,EAAGA,EAAImY,EAAUtT,OAAQ7E,GAAK,EAAG,CAO5C,IANA,IAAIuY,EAAkB,EAClBC,EAAmBzP,GACrBoP,EAAUnY,GACVmY,EAAUI,IAGHE,EAAI,EAAGA,EAAIN,EAAUtT,OAAQ4T,GAAK,EACzC,GAAIA,IAAMzY,EAAV,CAIA,IAAM2S,EAAO5J,GAAUoP,EAAUM,GAAIN,EAAUnY,IAC3C2S,EAAO6F,IACTD,EAAkBE,EAClBD,EAAmB7F,GAGvB0F,EAASE,GAAiBD,kBAAoB,EAOhD,MAAO,CAAEI,aAJYC,YAAON,EAAU,CAAC,SAAC7R,GAAD,OAAOA,EAAE8R,kBAAkB,SAC/DtB,MAAM,EAAGoB,GACTtY,KAAI,qBAAGhD,aAIZ,YAAyD,IAAtD4M,EAAqD,EAArDA,MAAOgB,EAA8C,EAA9CA,YAAyBgO,EAAqB,EAAjC7N,SAAY6N,aAC3BR,EAAKxN,EAAYhB,GAGvB,OADqBkP,aAAMF,GAAc,SAACG,GAAD,OAAS9P,GAAU8P,EAAKX,WCxF1DY,GAAkBvW,EAAY,CACzCf,KAAM,mBACNkB,YAAa,qDACbC,qBAAsB,iDACtBF,OAAQ,CACN4K,GAAY,CACV7L,KAAM,oBACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,MAGT7E,GAAI,gBAAG6G,EAAH,EAAGA,MAAoBsP,EAAvB,cAAU1O,WAAV,YAA0C,CAC5ClH,WAAYsG,EAAMtG,WAClB6G,OAAQyN,aAAM,EAAGhO,EAAMO,OAAOnF,QAAUkU,EAAa,IAAIjZ,KACvD,SAACE,GAAD,OAAOyJ,EAAMO,OAAOhK,EAAIyJ,EAAMO,OAAOnF,eCd9BiG,GAAcvI,EAAY,CACrCf,KAAM,eACNkB,YAAa,+CACbD,OAAQ,CACN0J,GAAS,CACP3K,KAAM,QACNkB,YACE,wEACF0J,aAAc,SAAC3C,GAAD,OAAYA,EAAQA,EAAMtG,WAAW,GAAK,GACxDqE,IAAK,IAEP2E,GAAS,CACP3K,KAAM,SACNkB,YACE,uEACF0J,aAAc,SAAC3C,GAAD,OAAYA,EAAQA,EAAMtG,WAAW,GAAK,GACxDqE,IAAK,IAEPkH,GAAc,CACZlN,KAAM,aACNkB,YACE,oEACF0J,cAAc,KAGlBxJ,GAAI,YAAwE,IAArE6G,EAAoE,EAApEA,MAAoE,gBAA7DY,WAA6D,GAAhDkD,EAAgD,KAAjCC,EAAiC,KAAjBvC,EAAiB,mBAC3CxB,EAAMtG,WADqC,GAClEsK,EADkE,KACxDC,EADwD,KAEnE3C,EACc,IAAlBwC,EACI3H,KAAKgI,KAAMH,EAAWC,EAAaF,GACnCD,EACAvC,EACe,IAAnBwC,EACI5H,KAAKgI,KAAMF,EAAYD,EAAYF,GACnCC,EACN,OAAOwL,GAAgB,CACrBvP,QACAsB,WACAC,YACAC,iBCzCOgO,GAAmB1W,EAAY,CAC1Cf,KAAM,oBACNkB,YAAa,yBACbD,OAAQ,GACRG,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,MAAgB,CAClBtG,WAAYsG,EAAMtG,WAClB6G,OAAQoG,aAAQ3G,EAAMO,YCLbkP,GAAS3W,EAAY,CAChCf,KAAM,SACNkB,YAAa,qCACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,YACN4K,aAAc,GACd5E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACN7J,YAAa,2CAEf2K,GAAY,CACV7L,KAAM,SACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,GACL/E,YAAa,+BAGjBE,GAAI+H,IACF,kBAA4B,CAC1B6K,MAA2B,EAD7B,EAAG/K,kBAC8B7E,KAAKC,OAEtC,YAMO,IALO2P,EAKR,EALJ3K,SAAY2K,MAKR,gBAJJ9L,MAII,GAJI3J,EAIJ,KAJO4J,EAIP,KAHW5K,EAGX,cAHJoE,WAGI,sBAFJkH,WAEI,GAFSoL,EAET,KAFoBC,EAEpB,KAKJ,OAAOhL,EALH,EADJA,aAMmB,CAAC3K,EAJL6F,KAAKkK,MAClB2F,EAAY7P,KAAKmK,IAAKpG,EAAI5K,EAAU2W,EAAS9P,KAAKC,GAAK2P,IAGzB7L,SClCzB7D,GAASvD,EAAY,CAChCf,KAAM,SACNkB,YAAa,mCACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,QACN4K,aAAc,EACd5E,IAAK,EACLC,IAAK,IACL8E,KAAM,EACN7J,YACE,gFAGNE,GAAI,gBAAG6G,EAAH,EAAGA,MAAoByK,EAAvB,cAAU7J,WAAV,aACFP,GAAUL,GAAO,SAACrG,GAAD,OACfO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgB+B,GAAc/B,EAAY0Q,YCrBhDiF,GAAU5W,EAAY,CACjCf,KAAM,UACNkB,YAAa,sBACbD,OAAQ,GACRG,GAAI+H,IACF,YAAyD,IAAD,gBAArDxH,WAAqD,GAAxCxF,EAAwC,KAAjCoB,EAAiC,KAAxB0L,EAAwB,EAAxBA,kBAMxB2O,EAAQxT,KAAKwB,MAA0B,EAApBqD,GACnB4O,EAA6C,GAAjC5O,EAAoB2O,EAAQ,GAExCE,EAAY1T,KAAKC,GAAK,EAAK,GAE3BqO,EACM,IAAVkF,EACI,EACU,IAAVA,EACAC,EAAWC,EACD,IAAVF,EACAE,GACC,EAAID,GAAYC,EAEvB,MAAO,CACLpF,QACA1D,IAAK5K,KAAK4K,IAAa,MAAR0D,GACfnE,IAAKnK,KAAKmK,IAAa,MAARmE,GACfqF,aAAsB,IAAR5b,EACd6b,aAAuB,GAATza,MAGlB,YAIO,IAAD,IAHJ8L,SAAYqJ,EAGR,EAHQA,MAAO1D,EAGf,EAHeA,IAAKT,EAGpB,EAHoBA,IAAKwJ,EAGzB,EAHyBA,aAAcC,EAGvC,EAHuCA,aAGvC,gBAFJ9P,MAEI,GAFI3J,EAEJ,KAFO4J,EAEP,KADJe,EACI,EADJA,YAEM/B,EAAa/C,KAAKwB,MAAMrH,EAAIwZ,EAAe,EAAI3T,KAAKmK,IAAImE,IACxDtL,EAAahD,KAAKwB,MAAMuC,EAAI6P,EAAe,EAAI5T,KAAK4K,IAAI0D,IAO9D,OAAOxJ,EALiB,CACtB9E,KAAKkK,MAAMyJ,EAAe5Q,EAAa6H,EAAM5H,EAAamH,GAC1DnK,KAAKkK,MAAM0J,EAAe5Q,EAAa4H,EAAM7H,EAAaoH,UC1CrD0J,GAAalX,EAAY,CACpCf,KAAM,cACNkB,YAAa,kDACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,QACNgG,IAAK,GACLC,IAAK,EACL8E,KAAM,GACNH,aAAc,KAGlBxJ,GAAI,gBAAG6G,EAAH,EAAGA,MAAoBiQ,EAAvB,cAAUrP,WAAV,anDoKoB,SAAC,GAQb,IAPZZ,EAOW,EAPXA,MACAzE,EAMW,EANXA,gBACAC,EAKW,EALXA,cAKW,cACawE,EAAMtG,WADnB,GACJxF,EADI,KACGoB,EADH,KAGL0G,EAAW9H,EAAQ,GAAT,OAAeqH,QAAf,IAAeA,IAAmB,GAAKrH,EAAQ,EACzD+H,EAAW3G,EAAS,GAAV,OAAgBkG,QAAhB,IAAgBA,IAAiB,GAAKlG,EAAS,EAC/D,OAAO+K,GAAUL,GAAO,SAACa,GAAD,OACtB3G,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,MAAOkH,EACP1G,UAAW,SAACJ,GAAD,OACTuB,GAAevB,EAAY,CACzBwB,kBACAC,gBACAG,uBAAwBK,EACxBJ,qBAAsBK,UmDzL5BiU,CAAe,CAAElQ,QAAOzE,gBAAiB0U,EAAOzU,cAAeyU,OCbtDE,GAAqBrX,EAAY,CAC5Cf,KAAM,uBACNkB,YAAa,sCACbD,OAAQ,CACN4K,GAAY,CACV7L,KAAM,mBACNkB,YAAa,kDACb0J,aAAc,SAAC3C,GAAD,OAAYA,EAAQA,EAAMO,OAAOnF,OAAS,GACxD2C,IAAK,EACLC,IAAK,MAGT7E,GAAI,YACF,OpD2R4B,SAAC6G,EAAce,GAC7C,IAAMqP,EAAgBpQ,EAAMO,OAM5B,MAAO,CACL7G,WAAYsG,EAAMtG,WAClB6G,OAAQyN,aAAM,EAAGjN,GAAY1K,KAAI,SAACE,GAChC,IAAM8Z,EAAclU,KAAKwB,MAAOpH,EAAIwK,EAAcqP,EAAchV,QAChE,OAAOgV,EAAcC,OoDtShBC,CADoC,EAAtCtQ,MAAsC,cAA/BY,WAA+B,UCZlC2P,GAAQzX,EAAY,CAC/Bf,KAAM,QACNkB,YAAa,sCACbD,OAAQ,CACN6P,GAAW,CACT9Q,KAAM,YACN4K,aAAc,SAAC3C,GAAD,OACZA,EAAQ7D,KAAKwB,MAAMqC,EAAMtG,WAAW,GAAK,IAAM,IACjDqE,IAAK,KAGT5E,GAAI+H,IACF,gBAAGF,EAAH,EAAGA,kBAAgCgL,EAAnC,cAAsBpL,WAAtB,YAAqD,CACnDkG,QAAS3K,KAAKkK,MACZ2F,EAAY7P,KAAK4K,IAAwB,EAApB/F,EAAwB7E,KAAKC,SAGtD,gBAAe0K,EAAf,EAAG1F,SAAY0F,QAAf,gBAA0B7G,MAA1B,GAAkC3J,EAAlC,KAAqC4J,EAArC,YACEe,EADF,EAAyCA,aAC3B,CAAC3K,EAAIwQ,EAAS5G,SCjBnBsQ,GAAgB1X,EAAY,CACvCf,KAAM,iBACNkB,YAAa,+DACbC,qBAAsB,6CACtBF,OAAQ,CACN0M,GAA+B,CAC7B3N,KAAM,qBACNqN,QAAS,CACP,CAAErN,KAAM,QAASX,MAAO,SACxB,CAAEW,KAAM,SAAUX,MAAO,WAE3BuL,aAAc,QACd1J,YACE,yJAINE,GAAI,gBAAG6G,EAAH,EAAGA,MAAoBpI,EAAvB,cAAUgJ,WAAV,YAAoC,CACtClH,WAAYsG,EAAMtG,WAClB6G,OAAQyN,aAAM,EAAyB,EAAtBhO,EAAMO,OAAOnF,OAAa,GAAG/E,KAAI,SAACE,GAKjD,GAAIA,EAAI,IAAM,EACZ,OAAOyJ,EAAMO,OAAOhK,EAAI,GAG1B,IAAMka,GAAcla,EAAI,GAAK,EAE7B,MAAa,UAATqB,EAEKoI,EAAMO,OAAOkQ,GAIfjQ,GAAUR,EAAMtG,YAAY,SAACuG,GAAW,IAAD,EACnBF,GACvBC,EAAMtG,WACNsG,EAAMO,OAAOkQ,GACbxQ,GAJ0C,mBACrCyQ,EADqC,KACjCC,EADiC,KAC7BC,EAD6B,KACzBC,EADyB,OAMnB9Q,GACvBC,EAAMtG,WACNsG,EAAMO,OAAOkQ,EAAa,GAC1BxQ,GAT0C,mBAW5C,MAAO,EAAEyQ,EAXmC,MAWxB,GAAIC,EAXoB,MAWT,GAAIC,EAXK,MAWM,GAAIC,EAXV,MAWqB,aC/C5DC,GAAOhY,EAAY,CAC9Bf,KAAM,OACNkB,YAAa,+DACbD,OAAQ,CACN0M,GAAoC,CAClC3N,KAAM,YACN4K,aAAc,YACdyC,QAAS,CACP,CAAErN,KAAM,YAAaX,MAAO,aAC5B,CAAEW,KAAM,oBAAqBX,MAAO,eAI1C+B,GAAI,gBAAG6G,EAAH,EAAGA,MAAoBzM,EAAvB,cAAUqN,WAAV,aACFP,GAAUL,GAAO,SAACrG,EAAOwG,EAAKY,GAC5B,IAAM0J,GACa,YAAdlX,EAA0B,GAAK,GAAK4M,EAAOY,EAAc,IAC9D,OAAO7G,GAAqB,CAC1BR,WAAYsG,EAAMtG,WAClBC,QACAQ,UAAW,SAACJ,GAAD,OAAgB+B,GAAc/B,EAAY0Q,YCnBhDsG,GAAUjY,EAAY,CACjCf,KAAM,SACNkB,YAAa,6CACbD,OAAQ,CACN0M,GAAwC,CACtC3N,KAAM,OACNkB,YAAa,6DACb0J,aAAc,aACdyC,QAAS,CACP,CACErN,KAAM,aACNX,MAAO,cAET,CACEW,KAAM,aACNX,MAAO,iBAIbwM,GAAY,CACV7L,KAAM,WACNkB,YAAa,sDACb0J,aAAc,GACd5E,IAAK,EACLC,IAAK,IACL8E,KAAM,KAGV3J,GAAIwH,IACF,YAAmE,IAAhEV,EAA+D,EAA/DA,MAAOgB,EAAwD,EAAxDA,YAAwD,gBAA3CL,WAA2C,GAA9BhJ,EAA8B,KAAxBgW,EAAwB,KAAblQ,EAAa,EAAbA,OAC7C7H,EAAMoL,EAAYhB,GAElB+Q,EAAezT,GAAc1H,GAEnC,GAAa,eAAT+B,EAAwBoZ,GAAgBA,EAC1C,OAAOnb,EAGT,GAAImb,GAAyB,eAATpZ,EAAuB,CACzC,IAAMqZ,EAAU9U,KAAKgI,KAAgB,IAAXzG,KAAkBkQ,EACtCsD,EAAO/U,KAAKgI,KAAgB,IAAXzG,KAEvB,OAAOuT,EAAU,CAACC,EAAMA,EAAMA,EAAM,KAAOrb,EAG7C,IAAMsb,EAAWhV,KAAKgI,KAAgB,IAAXzG,KAAkBkQ,EACvCsD,EAAO/U,KAAKgI,KAAgB,IAAXzG,KAEvB,OAAOyT,EAAW,CAACD,EAAMA,EAAMA,EAAMrb,EAAI,IAAMA,O,oBCvC/Cub,GAMD,SAAC,GAAqD,IAAnDrZ,EAAkD,EAAlDA,KAAMqN,EAA4C,EAA5CA,QAAShO,EAAmC,EAAnCA,MAAO6B,EAA4B,EAA5BA,YAAavC,EAAe,EAAfA,SACzC,OACE,eAAC1D,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,eAACT,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6E,IAC7B,cAAC,GAAD,CAAakB,YAAaA,OAE5B,cAACqJ,GAAA,EAAD,UACE,cAAC+O,GAAA,EAAD,CACEC,WAAS,EACTla,MAAOA,EACPV,SAAU,SAACsB,GAAD,OAAWtB,EAASsB,EAAMb,OAAOC,QAH7C,SAKGgO,EAAQ/O,KAAI,SAACiP,GAAD,OACX,cAACiM,GAAA,EAAD,CAAwBna,MAAOkO,EAAElO,MAAjC,SACGkO,EAAEvN,MADUuN,EAAElO,kBC1B7B,IDoC8B2B,GCpCxByY,GAAQ,CACZ,QACA,UACA,SACA,eACA,kBACA,UACA,WACA,cACA,mBAGWta,GAAO4B,EAAY,CAC9Bf,KAAM,OACNkB,YAAa,yBACbD,OAAQ,CACNmT,GAAU,CACRpU,KAAM,OACNkB,YAAa,+BACb0J,aAAc,MDiBU5J,GCfZ,CACZhB,KAAM,OACN4K,aAAc6O,GAAM,GACpBpM,QAASoM,GAAMnb,KAAI,SAACob,GAAD,MAAW,CAAE1Z,KAAM0Z,EAAMra,MAAOqa,ODkBhD,CACL1Z,KAAMgB,GAAKhB,KACX4K,aAAc9J,EAAgBE,GAAK4J,cACnCxJ,GAAI,SAACH,GACH,OACE,cAAC,GAAD,CACEjB,KAAMgB,GAAKhB,KACXX,MAAO4B,EAAO5B,MACdgO,QAASrM,GAAKqM,QACdnM,YAAaF,GAAKE,YAClBvC,SAAUsC,EAAOtC,cC1BvBgM,GAAS,CACP3K,KAAM,IACN4K,aAAc,IAEhBD,GAAS,CACP3K,KAAM,IACN4K,aAAc,IAEhBD,GAAS,CACP3K,KAAM,OACN4K,aAAc,GACd5E,IAAK,IAEP6G,GAAiB,CACf7M,KAAM,QACN4K,aAAcxF,GAAa,cAG/BhE,GAAI,gBAAG6G,EAAH,EAAGA,MAAH,gBAAUY,WAAV,GAAuB1J,EAAvB,KAA6Bua,EAA7B,KAAmCnb,EAAnC,KAAsC4J,EAAtC,KAAyC3L,EAAzC,KAAmDlB,EAAnD,YACFgN,GAAUL,GAAO,SAACrG,GAAD,OACfO,GAAqB,CACnBR,WAAYsG,EAAMtG,WAClBC,QACAS,WAAY,YAAc,IAAX7E,EAAU,EAAVA,IACbA,EAAIkc,KAAJ,UAAcld,EAAd,cAA4Bkd,GAC5Blc,EAAImc,UAAYhV,GAAWrJ,GAC3BkC,EAAIoc,SAASza,EAAMZ,EAAG4J,YCtDnB0R,GAAe9Y,EAAY,CACtCf,KAAM,eACNkB,YAAa,uCACbD,OAAQ,CACNiM,GAAc,CACZlN,KAAM,0BACNkB,YACE,6HACF0J,cAAc,IAEhBiC,GAAiB,CACf7M,KAAM,QACN4K,aAAcxF,GAAa,aAE7ByG,GAAY,CACV7L,KAAM,YACNkB,YACE,uGACF0J,aAAc,GACd5E,IAAK,EACLC,IAAK,OAGT7E,GAAIwH,IACF,YAIO,IAHLV,EAGI,EAHJA,MACAgB,EAEI,EAFJA,YAEI,gBADJL,WACI,GADSiR,EACT,KAD6BC,EAC7B,KAD4CpI,EAC5C,KACE7T,EAAMoL,EAAYhB,GAElB8R,EAAkD,IAAhCzS,GAAUzJ,EAAKic,IAAwBpI,EAE/D,OAAImI,EAAqBE,GAAmBA,GACnC,CAAClc,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAI,GAE3BA,OCvCAmc,GAAYlZ,EAAY,CACnCf,KAAM,YACNkB,YAAa,2CACbD,OAAQ,CACN0J,GAAS,CAAE3K,KAAM,IAAK4K,aAAc,IACpCD,GAAS,CAAE3K,KAAM,IAAK4K,aAAc,KAEtCxJ,GAAIwH,IAAS,gCAAGV,MAAH,GAAW3J,EAAX,KAAc4J,EAAd,KAAkBe,EAAlB,EAAkBA,YAAlB,gBAA+BL,WAA/B,UACXK,EAAY,CAAC3K,EADF,KACc4J,EADd,YCyCT+R,GAAexL,YACnB,CACElC,GACAoB,GACA9K,GACAqL,GACAK,GACAK,GACAsB,GACAQ,GACAK,GACAE,GACAM,GACAiB,GACAE,GACAgB,GACAE,GACAC,GACAC,GACAO,GACAK,GACAC,GACA3R,GACA4R,GACAE,GACAE,GACAC,GACAU,GACAE,GACAC,GACAM,GACAC,GACAC,GACAe,GACAhO,GACAmO,GACAC,GACApT,GACAqT,GACAM,GACAO,GACAC,GACAM,GACAC,GACA7Z,GACA0a,GACAI,IAEF9C,aAAO,SAAC5Y,GAAD,OAAOA,EAAEyB,QAChBjD,aAAO,SAACwB,GAAD,OAAOA,EAAE8C,aAGL8Y,GAAgB,CAE3B/B,GACAtM,IAH2B,mBAIxBoO,KAGQE,GAAe,SAC1Bpa,GAEA,IAAMuN,EAAI4M,GAAiBE,MAAK,SAAC9M,GAAD,OAAOA,EAAEvN,OAASA,KAElD,OADAjC,EAAOwP,EAAD,0CAAuCvN,IACtCuN,GCvFI+M,GAAU,uCAAG,6CAAA1d,EAAA,6DACxBqL,EADwB,EACxBA,MACAsS,EAFwB,EAExBA,YACAC,EAHwB,EAGxBA,WACAC,EAJwB,EAIxBA,IAEM9U,EAAS6O,IAAWgG,GAEpBE,EAASN,GAAaG,EAAYI,YARhB,SASHD,EAAOtZ,GAAG,CAC7B6G,QACAY,WAAY0R,EAAYtZ,OACxB0E,WAZsB,cASlB/E,EATkB,OAelBga,EAAmBC,GAAoBja,EAAQ+E,GAf7B,SAiBNmV,GAAU,CAE1B7S,MAAO8S,GAAmBna,EAAQga,GAClCA,mBACAH,QArBsB,cAiBlBO,EAjBkB,yBAwBjB,CACLA,MACA/S,MAAOrH,IA1Be,4CAAH,sDAkCjBma,GAAqB,SACzB9S,EACA2S,GAEA,IAAMlR,EAAYzB,EAAMO,OAAOlK,KAAI,SAACsD,GAElC,IADA,IAAM5E,EAAM,IAAI2L,kBAAkB/G,EAAMyB,QAC/B7E,EAAI,EAAGA,EAAIoD,EAAMyB,OAAQ7E,GAAK,EACjCoc,GAAoBhZ,EAAMpD,EAAI,GAAK,KAErCxB,EAAIwB,GAAKoc,EAAiB,GAC1B5d,EAAIwB,EAAI,GAAKoc,EAAiB,GAC9B5d,EAAIwB,EAAI,GAAKoc,EAAiB,GAC9B5d,EAAIwB,EAAI,GAAK,IAEbxB,EAAIwB,GAAKoD,EAAMpD,GACfxB,EAAIwB,EAAI,GAAKoD,EAAMpD,EAAI,GACvBxB,EAAIwB,EAAI,GAAKoD,EAAMpD,EAAI,GACvBxB,EAAIwB,EAAI,GAAK,GAGjB,OAAOxB,KAGT,MAAO,CACL2E,WAAYsG,EAAMtG,WAClB6G,OAAQkB,IAINoR,GAAS,uCAAG,iCAAAle,EAAA,6DAChBqL,EADgB,EAChBA,MACA2S,EAFgB,EAEhBA,iBACAH,EAHgB,EAGhBA,IAHgB,kBAShB,IAAI5d,SAAgB,SAACC,GAAa,IAAD,cACPmL,EAAMtG,WADC,GACxBxF,EADwB,KACjBoB,EADiB,KAEzByd,EAAM,IAAIC,IAAW9e,EAAOoB,GAQlC,GANAyd,EAAIE,aAAaT,GACjBO,EAAIG,UAAU,GAGdH,EAAII,cAEAR,EAAkB,CAEpB,IAAMpH,EAAW7O,GAAWiW,GAAkBpF,MAAM,GACpDwF,EAAIK,eAAJ,YAAwB7H,IAG1B,IAAItR,EAAc,GAClB8Y,EAAIM,GAAG,QAAQ,SAACC,GACdrZ,EAAKoQ,KAAKiJ,MAEZP,EAAIM,GAAG,OAAO,WACZ,IAAM9b,EAAUgc,IAAIC,gBAClB,IAAIC,KAAKxZ,EAAM,CAAErC,KAAM,eAEzB/C,EAAQ0C,MAGVyI,EAAMO,OAAOmT,SAAQ,SAAC/J,GACpBoJ,EAAIY,SAAShK,MAGfoJ,EAAIa,aAxCU,2CAAH,sDA2CFhO,GAAY,SAACrO,GAAD,OACvB,IAAI3C,SAAe,SAACif,EAAKC,GAAN,OACjBC,IACExc,GACA,SAACyc,EAAYC,GACX,GAAID,EACF,OAAOF,EAAIE,GAGb,GAA6B,IAAzBC,EAAQC,MAAM9Y,OAAc,CAAC,IAAD,cACN6Y,EAAQC,MADF,GACvBhgB,EADuB,KAChBoB,EADgB,KAG9B,OAAOue,EAAI,CACTtT,OAAQ,CAACG,kBAAkBvI,KAAK8b,EAAQha,OACxCP,WAAY,CAACxF,EAAOoB,KAQxB,IAlB6D,kBAe1B2e,EAAQC,MAfkB,GAetDC,EAfsD,KAe3CjgB,EAf2C,KAepCoB,EAfoC,KAgBvD8e,EAAYlgB,EAAQoB,EAAS,EAC7BiL,EAA8B,GAC3BhK,EAAI,EAAGA,EAAI4d,EAAW5d,GAAK,EAAG,CACrC,IAAMoD,EAAQsa,EAAQha,KAAKoa,SACzB9d,EAAI6d,GACH7d,EAAI,GAAK6d,GAGZ7T,EAAO8J,KAAK3J,kBAAkBvI,KAAKwB,IAErC,OAAOka,EAAI,CACTtT,SACA7G,WAAY,CAACxF,EAAOoB,YAMxBsd,GAAsB,SAC1B5S,EACAtC,GAEA,IAAI4W,GAAiB,EACfC,EAAa,IAAItK,IAFD,cAGEjK,EAAMtG,WAHR,GAGfxF,EAHe,KAGRoB,EAHQ,KAIlBkf,EAAU9X,GAAW,CAAC,EAAG,IAAK,EAAG,MAkBrC,OAjBAsD,EAAMO,OAAOmT,SAAQ,SAAC/Z,GACpB,IAAK,IAAIuG,EAAI,EAAGA,EAAI5K,EAAQ4K,GAAK,EAC/B,IAAK,IAAI5J,EAAI,EAAGA,EAAIpC,EAAOoC,GAAK,EAAG,CACjC,IAAMmY,EAAK1O,GAAmBC,EAAMtG,WAAYC,EAAO,CAACrD,EAAG4J,IAC3D,GAAI3C,GAAckR,GAChB6F,GAAiB,MACZ,CACL,IAAMlX,EAAMV,GAAW+R,GACvB8F,EAAWrK,IAAI9M,GACXA,IAAQoX,IAEVA,EAAUC,GAAwB/W,EAAQ6W,SAM7CD,EAAiBnX,GAAaqX,QAAWnd,GAG5Cod,GAA0B,SAA1BA,EACJ/W,EACAsM,GAEY,IADZ0K,EACW,uDADA,EAELC,EAAMjY,GAAWe,GAAYC,IACnC,OAAIgX,EAAW,IAENC,EAEF3K,EAAIG,IAAIwK,GACXF,EAAwB/W,EAAQsM,EAAK0K,EAAW,GAChDC,GCxMAC,GAAsB,SAAClb,GAC3B,GAAkB,MAAdA,EAGF,MAAO,CAAEhC,SAAU,QAASa,UAAW,SAJ8B,kBAO/CmB,EAP+C,GAOhExF,EAPgE,KAOzDoB,EAPyD,KAQjEuf,EAAcvf,EAASpB,EAC7B,GAAIA,EAAQoB,EAAQ,CAClB,IACMiD,EAA0B,IAAdsc,EAElB,MAAO,CAAEnd,SAAS,GAAD,OAHA,IAGA,MAAmBa,UAAU,GAAD,OAAKA,EAAL,OAG7C,IACMb,EAAY,EAAImd,EAAe,IACrC,MAAO,CAAEtc,UAAU,GAAD,OAFA,IAEA,MAAoBb,SAAS,GAAD,OAAKA,EAAL,QAIrCod,GAA0B,SAAC,GAAD,IAAGjf,EAAH,EAAGA,IAAK2C,EAAR,EAAQA,IAAKkB,EAAb,EAAaA,WAAb,OACrC,qBACE7D,IAAKA,EACL2C,IAAG,cAASA,GACZpF,MAAOwhB,GAAoBlb,M,4DClClBqb,GAC8C,MAAzD,I,QAAIC,GAAa1b,OAAO2b,UAAUC,WAAWC,SAElCC,GAAO9b,OAAe8b,IAEtBC,GAAmB,QAARD,GAAgBE,QAAQC,IAAM,aCE/C,SAASC,GAAT,GAQH,IAPFrc,EAOC,EAPDA,GACAsc,EAMC,EANDA,WACAC,EAKC,EALDA,QAMMC,EAAcjjB,IAAMkjB,OAAe,GAYzC,OAAOljB,IAAM0Q,aAAY,SAACrK,GACxB,IAAM8c,EA/Ba1Z,KAAKwB,MAAsB,IAAhBxB,KAAKuB,UAgCnC2X,GAAS,cAAe,CAAEQ,QAAO9c,SACjC4c,EAAYG,QAAUD,EACtB1c,EAAGJ,GAAMgd,KAdM,SAACF,GAAD,OAAmB,SAAC5B,GACnCoB,GAAS,WAAY,CAAEQ,QAAOF,YAAaA,EAAYG,UACnDD,IAAUF,EAAYG,QACxBL,EAAWxB,GAGXoB,GAAS,iCAQGW,CAASH,IAAQI,MAAMP,KAEpC,ICvCU,SAASQ,KACtB,OAAO,IAAIC,OAAO,IAA0B,8CCU9C,IAAMC,GAAiB,IAAIC,IAErBC,GAAc,SAACC,GAAD,OAA2B,SAAC5f,GAC9C,IAAM6f,EAAcJ,GAAeK,IAAIF,GAClCC,IAGLA,EAAY1hB,OAAO6B,GACnByf,GAAeM,OAAOH,MCTXI,GACX5B,IAAqB,QAARK,GAAgB/C,GDoBA,SAACtZ,GAAD,OAC7B,IAAInE,SAA2B,SAACC,EAASC,GACvC,IAAM8hB,EAAS,IAAIC,GAEbN,EAAa,UAAMO,KAAKC,MAAX,YAAoB5a,KAAKwB,MAAsB,IAAhBxB,KAAKuB,WACvD0Y,GAAepM,IAAIuM,EAAe,CAChC1hB,UACAC,WAGF8hB,EAAOI,iBAAiB,QAASV,GAAYC,IAC7CK,EAAOI,iBAAiB,eAAgBV,GAAYC,IAEpDK,EAAOK,UAAY,SAACjhB,GAElB,IAAMiE,EAAOjE,EAAQiE,KACD,aAAhBA,EAAKid,QAzBO,SAACX,EAAuB5d,GAC5C,IAAM6d,EAAcJ,GAAeK,IAAIF,GAClCC,IAGLA,EAAY3hB,QAAQ8D,GACpByd,GAAeM,OAAOH,IAoBhBY,CAAcZ,EAAetc,EAAKtB,SAItCie,EAAOQ,YAAYre,OCvCVse,GAAmB,uCAAG,6CAAA1iB,EAAA,yDACjC2iB,EADiC,EACjCA,MACAC,EAFiC,EAEjCA,iBACAC,EAHiC,EAGjCA,UAMA1hB,EAAOwhB,EAAMhf,UAAW,oDAGC,IAArBif,EAZ6B,gCAajB3R,GAAU0R,EAAMhf,WAbC,OAa/B0H,EAb+B,8BAgB/BlK,EAC6B,UAFvB2hB,EAAkBH,EAAMI,QAAQH,EAAmB,GAAGD,OAE1CJ,OAChB,oFAEFlX,EAAQyX,EAAgBzX,MAAMA,MApBC,QAuBxBzJ,EAAIghB,EAvBoB,aAuBFhhB,EAAI+gB,EAAMI,QAAQtc,QAvBhB,wBAwBzBuc,EAAQb,KAAKC,MAEbtE,EAAS6E,EAAMI,QAAQnhB,GA1BE,UA4BVogB,GAAW,CAC9BpE,WAAY+E,EAAMhf,UAClB0H,QACAsS,YAAa,CACXI,WAAYD,EAAOC,WACnB1Z,OAAQyZ,EAAOmF,cAEjBpF,IAAK8E,EAAM9E,MAnCkB,QA4BzB7Z,EA5ByB,OAuC/Bkf,GAAG,OAAQ,CACTC,QAAS,SACTC,eAAgB,cAChBC,UAAWvF,EAAOC,WAClBuF,YAAa9b,KAAKgI,MAAM2S,KAAKC,MAAQY,GAAS,OAGhD3X,EAAQrH,EAAOqH,MAEfwX,EAAU7e,EAAQpC,GAhDa,QAuBwBA,GAAK,EAvB7B,4DAAH,sDC6BnB2hB,GAAgD,SAAC,GASvD,IARLC,EAQI,EARJA,KACAC,EAOI,EAPJA,aACAC,EAMI,EANJA,cACAC,EAKI,EALJA,gBACAC,EAII,EAJJA,QACAC,EAGI,EAHJA,eACAC,EAEI,EAFJA,eACAC,EACI,EADJA,SACI,EACsBhmB,IAAMC,SAE9B,CAAEgmB,WAAW,IAHX,mBACG3Y,EADH,KACU4Y,EADV,KAKEC,EAAgBrD,GAAmB,CACvCrc,GAAIwd,GACJlB,WAAY,SAACxB,GAAD,OAAa2E,EAAS,CAAED,WAAW,EAAO1E,eAPpD,EAUsCvhB,IAAMC,UAAS,GAVrD,mBAUGmmB,EAVH,KAUkBC,EAVlB,OAYsCrmB,IAAMC,SAAsB,CAEpE+f,WAAY2F,EAAc3F,WAC1B1Z,OAAO,YAAKqf,EAAcrf,UAfxB,mBAYGggB,EAZH,KAYkBC,EAZlB,OAiBsBvmB,IAAMC,UAAS,GAjBrC,mBAiBGumB,EAjBH,KAiBUC,EAjBV,KAmBJzmB,IAAM0mB,WAAU,WAETjB,IACHY,GAAiB,GACjBE,EAAiB,CAEfvG,WAAY2F,EAAc3F,WAC1B1Z,OAAO,YAAKqf,EAAcrf,UAE5B4f,EAAS,CAAED,WAAW,OAGvB,CAACR,IAEJzlB,IAAM0mB,WAAU,WAEd,GAAKhB,EAIL,OAAKU,OAAL,GACEzD,GAAS,mBAETuD,EAAS,CACPD,WAAW,EACX1E,QAASmE,SAEXW,GAAiB,MAMlB,CAACX,IAEJ1lB,IAAM0mB,WAAU,WACThB,IAILQ,EAAS,CAAED,WAAW,IACtBE,EAAc,CACZrG,IAAK+F,EACLhG,WAAYiG,EACZxY,MAAOoY,EAAapY,MACpBsS,YAAa0G,OAId,CAACZ,EAAcY,EAAeT,EAASC,IAE1C,IAAMa,EAAc,SAAC,GAAgC,EAA9Bhf,MAMrBoe,EAAeO,EAAehZ,EAAM2Y,eAAYthB,EAAY2I,EAAMiU,SAClEkF,GAAS,IALPT,KAQEjG,EAASN,GAAa6G,EAActG,YAE1C,OACE,eAAC4G,GAAA,EAAD,CAAQC,WAAS,EAAC7hB,SAAS,KAAKygB,KAAMA,EAAtC,UACE,cAACqB,GAAA,EAAD,UACE,cAACxmB,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAGgmB,UAAW,EAA9C,SACE,cAACnX,GAAA,EAAD,CAAaiX,WAAS,EAAtB,SACE,cAACG,GAAA,EAAD,CACEC,kBAAgB,EAChBviB,MAAO4hB,EAActG,WACrBtN,QAASkT,EAAgBjiB,KAAI,SAACiP,GAAD,OAAOA,EAAEvN,QACtCrB,SAAU,SAACsB,EAAO4hB,GAChB,IAAMtU,EAAI6M,GAAayH,GAEvBX,EAAiB,CACfvG,WAAYpN,EAAEvN,KACdiB,OAAQsM,EAAEtM,OAAO3C,KAAI,SAACqR,GAAD,aACnBA,EAAE/E,aAAF,iBAAeyV,QAAf,IAAeA,OAAf,EAAeA,EAAcpY,aAA7B,aAAsC3I,QAG1C8hB,GAAS,IAEXU,aAAc,SAACC,EAAOC,GAAR,OACZ,8CAAQD,GAAR,aACE,eAAC9mB,EAAA,EAAD,CAAOgnB,WAAY,EAAGxlB,YAAa,EAAnC,UACE,cAACV,EAAA,EAAD,CAAYZ,QAAQ,QAApB,SAA6B6mB,IAC7B,cAACjmB,EAAA,EAAD,CAAYZ,QAAQ,UAAU8mB,WAAY,EAA1C,SACG7H,GAAa4H,GAAQ9gB,qBAK9BghB,YAAa,SAACjhB,GAAD,OAAY,cAACnC,EAAA,EAAD,2BAAemC,GAAf,IAAuBlC,MAAM,qBAK9D,cAACojB,GAAA,EAAD,UACE,eAAClnB,EAAA,EAAD,CAAOmnB,QAAS,cAACpmB,EAAA,EAAD,IAAaN,QAAS,EAAtC,UACE,eAACK,EAAA,EAAD,CAAYZ,QAAQ,QAApB,UACGuf,EAAOxZ,YACR,8BACGwZ,EAAOvZ,sBACN,cAACpF,EAAA,EAAD,CAAYZ,QAAQ,UAAU8mB,WAAY,EAA1C,SACGvH,EAAOvZ,4BAMfuZ,EAAOzZ,OAAO3C,KAIb,SAAC+Q,EAA2BjH,GAC1B,IAAMqH,EAAMJ,EAAMjO,GAAG,CACnB/B,MAAO4hB,EAAchgB,OAAOmH,GAC5BzJ,SAAU,SAACyQ,GACTgS,GAAS,GACTF,EAAiB,2BACZD,GADW,IAEdhgB,OAAQ/C,EAAa+iB,EAAchgB,OAAQmH,GAAK,kBAAMgH,WAI5D,OACE,cAAC,IAAMiT,SAAP,UAGG5S,GAHH,UACUwR,EAActG,WADxB,YACsCtL,EAAMrP,UAOlD,cAAC/E,EAAA,EAAD,CAAOsB,GAAI,CAAEgB,OAAQ,KAArB,SACG0K,EAAM2Y,UACL,cAAC0B,EAAA,EAAD,CAAkB/mB,KAAM,MAExB,cAAC,GAAD,CACEuC,IAAKmK,EAAMiU,QAAQlB,IACnBva,IAAG,iBAAYwgB,EAActG,YAC7BhZ,WAAYsG,EAAMiU,QAAQjU,MAAMtG,oBAM1C,eAAC4gB,GAAA,EAAD,WACE,cAACrnB,EAAA,EAAD,CACEC,QAAQ,WACRqnB,WAAS,EACTpnB,QAAS,WACPkmB,EAAY,CAAEhf,MAAM,KAJxB,oBASA,cAACpH,EAAA,EAAD,CACEC,QAAQ,YACRqnB,WAAS,EACTnhB,UAAW8f,EACX/lB,QAAS,WACPkmB,EAAY,CAAEhf,MAAM,KALxB,mCCtMFmgB,GAAY,SAAClV,EAAmBnF,GAApB,gBACbmF,EAAEoN,WADW,YACGvS,EADH,YAEK,SAAnBmF,EAAEgS,MAAMJ,OAAoB5R,EAAEgS,MAAMtX,MAAM+S,IAAI0H,UAAU,EAAG,IAAM,YAGxDC,GAA6C,SAAC,GAIpD,IAHLC,EAGI,EAHJA,SACArC,EAEI,EAFJA,gBACAsC,EACI,EADJA,gBAEMC,EAAiBF,EAASjD,QAD5B,EAE4ChlB,IAAMC,SAEpD,CAAEwlB,MAAM,IAJN,mBAEG2C,EAFH,KAEqBC,EAFrB,OAS8BroB,IAAMC,WATpC,mBASG2F,EATH,KASc0iB,EATd,KAYJtoB,IAAM0mB,WAAU,WACd,GAAKuB,EAASriB,YAAsB,OAATA,QAAS,IAATA,OAAA,EAAAA,EAAWya,OAAQ4H,EAASriB,UAAvD,CAIA,IAAMya,EAAM4H,EAASriB,UACrBsN,GAAUmN,GAAKgD,MAAK,SAAC/V,GAAD,OAClBgb,EAAa,CACXjI,MACA/S,gBAGH,CAAC2a,EAAUriB,IAEd,IAAM2iB,EAAkBvoB,IAAM0Q,aAC5B,SAACjD,GACC,IAAM+a,EAAaL,EAAe1a,EAAM,GACxC,OAAI+a,EACiC,SAA5BA,EAAW5D,MAAMJ,OACpBgE,EAAW5D,MAAMtX,WACjB3I,EAGCiB,IAET,CAACA,EAAWuiB,IAGRM,EAAW,SAAChb,GAAD,OACfA,EAAM,EACF,kBACEya,EACEC,EAAexkB,KAAI,SAAC+kB,EAAOC,GACzB,OAAIA,IAAWlb,EAAM,EAEZ0a,EAAeQ,EAAS,GACtBlb,IAAQkb,EAEVR,EAAe1a,EAAM,GAErBib,YAIf/jB,GAEAikB,EAAa,SAACnb,GAAD,OACjBA,EAAM0a,EAAezf,OAAS,EAC1B,kBACEwf,EACEC,EAAexkB,KAAI,SAAC+kB,EAAOC,GACzB,OAAIA,IAAWlb,EAAM,EAEZ0a,EAAeQ,EAAS,GACtBlb,IAAQkb,EAEVR,EAAe1a,EAAM,GAErBib,YAIf/jB,GAEN,OACE,eAACrE,EAAA,EAAD,CAAOS,QAAS,EAAGD,WAAW,SAA9B,UACE,cAACM,EAAA,EAAD,CAAYZ,QAAQ,KAApB,2BACC2nB,EAAe5M,SAAQ,SAAC3I,EAAGiW,GAAJ,MAAa,CACnC,qCACE,cAACtoB,EAAA,EAAD,CACEC,QAAQ,YACRuE,UAAW,cAAC/D,EAAA,EAAD,kBACXJ,KAAK,QACLH,QAAS,WACPynB,EAAgB,CACd,CACElI,WAAY4F,EAAgB,GAAGvgB,KAC/B6f,aAAcU,EAAgB,GAAGtf,OAAO3C,KACtC,SAACqR,GACC,IAAI1H,OAA2B3I,EAC/B,GAAa,IAATkkB,EACFvb,EAAK,OAAG1H,QAAH,IAAGA,OAAH,EAAGA,EAAW0H,UACd,CACL,IAAMwb,EAAiBX,EAAeU,EAAO,GACT,SAAhCC,EAAelE,MAAMJ,SACvBlX,EAAQwb,EAAelE,MAAMtX,MAAMA,OAIvC,OAAO0H,EAAE/E,aAAa3C,MAG1BsX,MAAO,CAAEJ,OAAQ,UAlBN,mBAoBV2D,KAELE,EAAoB,CAClB5C,MAAM,EACNhY,IAAKob,EACLE,OAAO,KA9Bb,+BAoCA,cAAC,GAAD,yBAA+BjB,GAAUlV,EAAGiW,KAC5C,cAACvoB,EAAA,EAAD,CAAOO,UAAU,MAA+BE,QAAS,EAAzD,SACE,eAACT,EAAA,EAAD,CAAO0oB,OAAO,QAAd,UACE,eAAC1oB,EAAA,EAAD,WACE,eAACc,EAAA,EAAD,CACEZ,QAAQ,YACRyoB,WAAW,OACX3B,WAAY,EACZ4B,aAAc,EAJhB,qBAMWtW,EAAEoN,cAEb,eAAC1f,EAAA,EAAD,CAAOO,UAAU,MAAME,QAAS,EAAhC,UACE,cAACqO,EAAA,EAAD,CAASC,MAAM,gBAAf,SACE,cAAC6F,EAAA,EAAD,CAAYnE,aAAW,SAAStQ,SA7HhCgN,EA6HkDob,EA7HlC,kBAChCX,EAAgBC,EAAe1f,QAAO,SAACigB,EAAOC,GAAR,OAAmBA,IAAWlb,QA4HpD,SACE,cAACzM,EAAA,EAAD,yBAGJ,cAACoO,EAAA,EAAD,CAASC,MAAM,sBAAf,SACE,cAAC6F,EAAA,EAAD,CACEnE,aAAW,cACXtQ,QAASgoB,EAASI,GAClBniB,SAAmB,IAATmiB,EAHZ,SAKE,cAAC7nB,EAAA,EAAD,+BAGJ,cAACoO,EAAA,EAAD,CAASC,MAAM,oBAAf,SACE,cAAC6F,EAAA,EAAD,CACEnE,aAAW,aACXtQ,QAASmoB,EAAWC,GACpBniB,SAAUmiB,IAASV,EAAezf,OAAS,EAH7C,SAKE,cAAC1H,EAAA,EAAD,uCAKY,SAAnB4R,EAAEgS,MAAMJ,QACP,cAAClkB,EAAA,EAAD,CAAOsB,GAAI,CAAEJ,MAAO,KAApB,SACE,cAAC,GAAD,CACE2B,IAAKyP,EAAEgS,MAAMtX,MAAM+S,IACnBva,IAAG,UAAK8M,EAAEoN,WAAP,YAAqB6I,GACxB7hB,WAAY4L,EAAEgS,MAAMtX,MAAMA,MAAMtG,eAIlB,cAAnB4L,EAAEgS,MAAMJ,QACP,cAACmD,EAAA,EAAD,CAAkB/mB,KAAM,MAE1B,cAACN,EAAA,EAAD,CAAOS,QAAS,EAAGgmB,UAAW,EAA9B,SACE,eAACxmB,EAAA,EAAD,CACEC,QAAQ,YACRuE,UAAW,cAAC/D,EAAA,EAAD,mBACXP,QAAS,kBACP4nB,EAAoB,CAAE5C,MAAM,EAAMhY,IAAKob,EAAME,OAAO,KAJxD,oBAOUnW,EAAEoN,WAPZ,SAUF,cAAC,GAAD,CACEyF,KAAM2C,EAAiB3C,MAAQ2C,EAAiB3a,MAAQob,EACxDjD,gBAAiBA,EACjBG,eAAgB,SAACoD,EAAWC,GAC1BlB,EACE3kB,EAAa4kB,EAAgBU,GAAM,iBAAO,CACxC7I,WAAYmJ,EAAUnJ,WACtBkF,aAAciE,EAAU7iB,OACxBse,MAAOwE,EACH,CAAE5E,OAAQ,OAAQlX,MAAO8b,GACzB,CAAE5E,OAAQ,aAGlB6D,EAAoB,CAAE5C,MAAM,KAE9BO,SAAU,WAEJoC,EAAiB3C,MAAQ2C,EAAiBW,OAG5Cb,EACEC,EAAetN,MAAM,EAAGsN,EAAezf,OAAS,IAIpD2f,EAAoB,CAAE5C,MAAM,KAE9BC,aAAc6C,EAAgBM,GAC9BlD,cAAe,CACb3F,WAAYpN,EAAEoN,WACd1Z,OAAQsM,EAAEsS,cAEZW,QAASoC,EAASnI,IAClBgG,eAAe,kBA7FOgC,GAAUlV,EAAGiW,IAiGzC,cAAC,GAAD,4BAAkCf,GAAUlV,EAAGiW,SAjNtC,IAACpb,KAoNd,cAAClN,EAAA,EAAD,CACEC,QAAQ,YACRuE,UAAW,cAAC/D,EAAA,EAAD,kBACXJ,KAAK,QACLH,QAAS,WACPynB,EAAgB,GAAD,mBACVC,GADU,CAEb,CACEnI,WAAY4F,EAAgB,GAAGvgB,KAC/B6f,aAAcU,EAAgB,GAAGtf,OAAO3C,KACtC,SAACqR,GACC,IAAI1H,OAA2B3I,EAC/B,GAA8B,IAA1BwjB,EAAezf,OACjB4E,EAAK,OAAG1H,QAAH,IAAGA,OAAH,EAAGA,EAAW0H,UACd,CACL,IAAM+b,EACJlB,EAAeA,EAAezf,OAAS,GACT,SAA5B2gB,EAAWzE,MAAMJ,SACnBlX,EAAQ+b,EAAWzE,MAAMtX,MAAMA,OAInC,OAAO0H,EAAE/E,aAAa3C,MAG1BsX,MAAO,CAAEJ,OAAQ,YAGrB6D,EAAoB,CAClB5C,MAAM,EACNhY,IAAK0a,EAAezf,OACpBqgB,OAAO,KA/Bb,mCAyCAO,GAAsB,kBAC1B,cAACjoB,EAAA,EAAD,CAASb,QAAQ,SAASoB,GAAI,CAAEJ,MAAO,QCzSnC+nB,GAAoB,kBAmBbC,GAAe,SAAC5E,GAC3B,IACEhe,OAAO6iB,aAAaC,QAAQH,GAAmBI,GAAkB/E,IACjE,MAAOtD,GAEPsB,QAAQ3e,MAAM,sCAAuCqd,EAAI5J,OAAS4J,KAIzDsI,GAAgB,WAC3B,IACEhjB,OAAO6iB,aAAaI,WAAWN,IAC/B,MAAOjI,GAEPsB,QAAQ3e,MAAM,0CAA2Cqd,EAAI5J,OAAS4J,KAIpEqI,GAAoB,SAAC/E,GACzB,IAAMkF,EAAiB,2BAClBlF,GADkB,IAErBI,QAASJ,EAAMI,QAAQrhB,KACrB,SAACiP,GAAD,mBAAC,eACIA,GADL,IAIEgS,MAAO,CAAEJ,OAAQ,eAIvB,OAAOuF,KAAKC,UAAUF,I,oBCzCXG,GAAejqB,IAAMkqB,cAA4B,CAC5DC,MAAO,KACPC,SAAU,WACR,MAAM,IAAIrnB,MAAM,8BAIPsnB,GAA0B,SAAC,GAAkB,IAAhBtqB,EAAe,EAAfA,SAAe,EACnBC,IAAMC,SAAqB,MADR,mBAChDqqB,EADgD,KACpCC,EADoC,KAGvD,OACE,cAACN,GAAaO,SAAd,CACE9lB,MAAO,CAAEylB,MAAOG,EAAYF,SAAUG,GADxC,SAGGxqB,KAKM0qB,GAA0B,WAAO,IAAD,EACfzqB,IAAM0qB,WAAWT,IAArCE,EADmC,EACnCA,MAAOC,EAD4B,EAC5BA,SACf,OACE,cAACO,GAAA,EAAD,CAAUlF,KAAe,MAAT0E,EAAhB,SACY,MAATA,OAAgBxlB,EACf,cAACimB,GAAA,EAAD,CAAOC,SAAUV,EAAMU,SAAUC,QAAS,kBAAMV,EAAS,OAAzD,SACGD,EAAM7mB,aCHXynB,GAAW7Z,GAAY,CAC3B7L,KAAM,8BACN4K,aAHkB,GAIlB5E,IAAK,EACLC,IAAK,KAGD0f,GAA0B,CAC9BC,QAXgC,EAYhCjG,QAAS,GACTpf,eAAWjB,EACXmb,IAZkB,IAedoL,GAAkB,WAAO,IAAD,EACClrB,IAAMC,SAAS+qB,IADhB,mBACrBpG,EADqB,KACduG,EADc,OAEMnrB,IAAMC,SAEtC,CAAEwO,SAAS,IAJe,mBAErB2c,EAFqB,KAEVC,EAFU,OAKYrrB,IAAMC,SAC5C,MAN0B,mBAKrBqrB,EALqB,KAKPC,EALO,KAStBnB,EDZepqB,IAAM0qB,WAAWT,IAA9BG,SCcRpqB,IAAM0mB,WAAU,WACVrE,IACF+H,EAAS,CACPS,SAAU,UACVvnB,QACE,mFAGL,CAAC8mB,IAEJpqB,IAAM0mB,WAAU,WAEd,IAAM8E,EFjEuB,WAC/B,IACE,IAAMA,EAAS5kB,OAAO6iB,aAAagC,QAAQlC,IAC3C,GAAIiC,EAAQ,CACV,IAAME,EAAa3B,KAAKxa,MAAMic,GAC9B,GAAIhmB,MAAMmmB,QAAQD,EAAW1G,SAC3B,OAAO0G,GAGX,MAAOpK,GAEPsB,QAAQ3e,MAAM,yCAA0Cqd,EAAI5J,OAAS4J,IEsDtDmI,GACX+B,IAzC0B,IA0CxBA,EAAOP,SACTE,EAAYK,GACZH,EAAa,CAAE5c,SAAS,EAAMmd,WAAY,KAG1CnC,QAGH,IAEH,IAAMoC,EAAW7rB,IAAM0Q,aACrB,SACEjK,EADF,GAGM,IADFgI,EACC,EADDA,QAEF0c,GAAY,SAACW,GACX,IAAMC,EAAWtlB,EAAGqlB,GAOpB,GANArC,GAA0BsC,GAEd,QAARrJ,KACD9b,OAAeolB,MAAQD,GAGV,OAAZtd,GAA0C,MAAtBsd,EAASnmB,UAAmB,CAG9C0lB,IACFW,aAAaX,GACbC,EAAgB,OAGlB,IAAMW,ELpCc,SAAC,GAMyB,IALtDC,EAKqD,EALrDA,UACAC,EAIqD,EAJrDA,UAKA,GACED,EAAUrM,MAAQsM,EAAUtM,KAC5BqM,EAAUvmB,YAAcwmB,EAAUxmB,UAGlC,OADA+c,GAAS,kCACF,CAAE0J,MAAM,EAAM5oB,MAAO,GAO9B,IAJA,IAAM6oB,EAAcH,EAAUnH,QACxBuH,EAAcH,EAAUpH,QAGrBnhB,EAAI,EAAGA,EAAIyoB,EAAY5jB,OAAQ7E,GAAK,EAAG,CAC9C,IAAM2oB,EAAQF,EAAYzoB,GACpB4oB,EAAQF,EAAY1oB,GAC1B,IAAK4oB,EAEH,OADA9J,GAAS,mBAAoB9e,GACtB,CAAEwoB,MAAM,EAAM5oB,MAAOI,GAG9B,GAA2B,SAAvB4oB,EAAM7H,MAAMJ,OAEd,OADA7B,GAAS,kBAAmB9e,GACrB,CAAEwoB,MAAM,EAAM5oB,MAAOI,GAG9B,GAAI2oB,EAAMxM,aAAeyM,EAAMzM,WAE7B,OADA2C,GAAS,yBAA0B9e,GAC5B,CAAEwoB,MAAM,EAAM5oB,MAAOI,GAI9B,IAAK,IAAI6oB,EAAK,EAAGA,EAAKF,EAAMtH,aAAaxc,OAAQgkB,GAAM,EAAG,CACxD,IAAMC,EAAaH,EAAMtH,aAAawH,GAChCE,EAASH,EAAMvH,aAAawH,GAClC,GAAI3C,KAAKC,UAAU2C,KAAgB5C,KAAKC,UAAU4C,GAEhD,OADAjK,GAAS,kBAAmB9e,EAAG6oB,GACxB,CAAEL,MAAM,EAAM5oB,MAAOI,IAMlC,OADA8e,GAAS,WACF,CAAE0J,MAAM,GKbaQ,CAAe,CACjCT,UAAWN,EACXK,UAAWJ,IAGTG,EAAYG,OACE,QAAZ5d,EACF4c,EAAa,CAAE5c,SAAS,EAAMmd,WAAYM,EAAYzoB,SAEtD4nB,EAAa,CAAE5c,SAAS,IACxB8c,EACEuB,YAAW,WACTvB,EAAgB,MAChBF,EAAa,CACX5c,SAAS,EACTmd,WAAYM,EAAYzoB,UA5FZ,QAoGxB,OAAOsoB,OAIX,IAsDF,OAnDA/rB,IAAM0mB,WAAU,WACd/D,GAAS,uBAAwByI,IACP,IAAtBA,EAAU3c,UAMd4c,EAAa,CAAE5c,SAAS,IACxB,sBAAC,sBAAAxM,EAAA,6DACC4pB,GACE,SAACO,GAAD,mBAAC,eACIA,GADL,IAEEpH,QAASoH,EAAUpH,QAAQrhB,KAAI,SAACiP,EAAG/O,GACjC,OAAIA,EAAIunB,EAAUQ,WACThZ,EAEA,2BACFA,GADL,IAEEgS,MAAO,CAAEJ,OAAQ,sBAKzB,CAAE/V,QAAS,OAfd,SAkBOkW,GAAoB,CACxBC,QACAE,UAAW,SAACxX,EAAOyf,GACjBlB,GACE,SAACO,GAAD,mBAAC,eACIA,GADL,IAEEpH,QAASzhB,EACP6oB,EAAUpH,QACV+H,GACA,SAACna,GAAD,mBAAC,eACIA,GADL,IAEEgS,MAAO,CAAEJ,OAAQ,OAAQlX,kBAI/B,CAAEmB,QAAS,QAGfoW,iBAAkBuG,EAAUQ,aApC/B,0CAAD,MAwCC,CAACR,IAGF,qCACE,cAAC4B,EAAA,EAAD,IACA,cAACC,EAAA,EAAD,CAAWjoB,SAAS,KAApB,SACE,eAAC1E,EAAA,EAAD,CACES,QAAS,EACTmsB,eAAe,eACfpsB,WAAW,SACXU,MAAM,KACNimB,QAAS,cAACpmB,EAAA,EAAD,IALX,UAOE,cAACD,EAAA,EAAD,CAAYZ,QAAQ,KAAK2sB,GAAI,EAA7B,uBAGA,eAAC7sB,EAAA,EAAD,CAAOS,QAAS,EAAG0mB,QAAS,cAACpmB,EAAA,EAAD,IAAaP,WAAW,SAApD,UACE,cAAC,GAAD,UACE,cAAC,EAAD,MAEF,cAAC,GAAD,UACE,eAACR,EAAA,EAAD,CAAOS,QAAS,EAAGD,WAAW,SAA9B,UACE,cAACM,EAAA,EAAD,CAAYZ,QAAQ,KAApB,0BACA,cAAC,EAAD,CACE6E,KAAK,wBACLtB,gBAAiB6gB,EAAMhf,UACvB5B,SAAU,SAAC4B,GACTimB,GACE,SAACO,GAAD,mBAAC,eACIA,GADL,IAEExmB,gBAEF,CAAE6I,QAAS,WAIjB,qBAAK/N,MAAO,CAAEsE,SAAU,SAAxB,SACG+lB,GAAStkB,GAAG,CACX/B,MAAOkgB,EAAM9E,IACb9b,SAAU,SAAC8b,GAAD,OACR+L,GACE,SAACO,GAAD,mBAAC,eACIA,GADL,IAEEtM,UAEF,CAAErR,QAAS,oBAMvB,cAAC,GAAD,UACE,cAAC,GAAD,CACEwZ,SAAUrD,EACVgB,gBAAiBpG,GACjB0I,gBAAiB,SAAClD,GAAD,OACf6G,GACE,SAACO,GAAD,mBAAC,eACIA,GADL,IAEEpH,cAEF,CAAEvW,QAAS,aAYnB,cAAC,GAAD,UACE,eAACnO,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,KAApB,2BACA,cAACY,EAAA,EAAD,CAAYZ,QAAQ,QAApB,uEAGA,cAACD,EAAA,EAAD,CACEwE,UAAW,cAAC/D,EAAA,EAAD,oBACXY,GAAI,CAAEoD,SAAU,SAChBxE,QAAQ,YACRG,MAAM,UACNF,QAAS,WACP,IAAMsrB,EAAkB,2BACnBf,IADmB,IAEtBplB,UAAWgf,EAAMhf,YAEnBulB,EAAYY,GACZtC,GAA0BsC,IAX9B,gCAkBJ,mBACEqB,KAAK,4CACL3oB,OAAO,SACP4oB,IAAI,aAHN,SAKE,qBACElqB,IAAI,+EACJ3B,MAAO,GACPoB,OAAQ,GACRkD,IAAI,0BAOd,cAAC,GAAD,QAKAvE,GAAoB,SAAC,GAAD,IAAGxB,EAAH,EAAGA,SAAH,OACxB,cAAC8U,EAAA,EAAD,CAAOnU,MAAO,CAAE4sB,QAAS,IAAM1rB,GAAI,CAAEJ,MAAO,KAA5C,SACGzB,KAMQwtB,GAAgB,WAC3B,OACE,cAAC,GAAD,UACE,cAAC,GAAD,O,wCC3SOC,GAAb,+MACS5I,MAAe,CACpB6I,UAAU,GAFd,wDAUE,SAAkBxpB,EAAcypB,GAC9B9K,QAAQ3e,MAAM,kBAAmBA,EAAOypB,KAX5C,oBAcE,WACE,OAAIC,KAAK/I,MAAM6I,SAEX,eAACntB,EAAA,EAAD,CAAOS,QAAS,EAAhB,UACE,cAACK,EAAA,EAAD,CAAYZ,QAAQ,KAApB,oBACA,cAACY,EAAA,EAAD,CAAYZ,QAAQ,QAApB,+CAGA,cAACY,EAAA,EAAD,CAAYZ,QAAQ,QAApB,sGAIA,cAACD,EAAA,EAAD,CACEC,QAAQ,YACRoB,GAAI,CAAEoD,SAAU,SAChB4oB,QAAS,cAAC5sB,EAAA,EAAD,4BACT+D,UAAW,cAAC/D,EAAA,EAAD,4BACXP,QAASktB,KAAKvG,MAAMyG,oBALtB,yCAaCF,KAAKvG,MAAMrnB,YAvCtB,uCAKE,SAAgCkE,GAE9B,OADA2e,QAAQ3e,MAAMA,GACP,CAAEwpB,UAAU,OAPvB,GAA2CztB,IAAM8tB,WCJ3CC,GAAQC,YAAY,CACxBC,WAAY,CACVC,WAAY,oBAIhBC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAACC,EAAA,EAAD,CAAeP,MAAOA,GAAtB,SACE,cAAC,GAAD,CACEF,oBAAqB,WACnBpE,KACA7iB,OAAO2nB,SAASC,UAHpB,SAME,cAAC,GAAD,UAIN9rB,SAAS+rB,eAAe,W","file":"static/js/main.af836c3e.chunk.js","sourcesContent":["import {\n  Button,\n  ClickAwayListener,\n  Collapse,\n  Icon,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Stack>\n        <Button\n          variant=\"text\"\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ color: 'black' }}\n          size=\"small\"\n        >\n          <Stack direction=\"row\" alignItems=\"center\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'add' : 'remove'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Stack>\n    </ClickAwayListener>\n  );\n};\n","import { Divider, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { Expandable } from './Expandable';\n\nexport const Help: React.FC = () => (\n  <Expandable\n    mainEle={<Typography variant=\"h5\">Click here for Help</Typography>}\n  >\n    <Group>\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Getting Started</Typography>}\n      >\n        <Section>\n          <SectionHeader>\n            Start by importing an image from your device\n          </SectionHeader>\n          <SectionText>You may choose a png, jpg, or gif</SectionText>\n          <SectionText>\n            The frames per second controls how fast the final gif will animate\n          </SectionText>\n        </Section>\n      </Expandable>\n\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Adding Effects</Typography>}\n      >\n        <Group>\n          <Section>\n            <Section>\n              <SectionHeader>\n                Effects are applied to an image to manipulate it\n              </SectionHeader>\n              <SectionText>\n                Some may adjust the basic attributes of an image, such as size,\n                or number of animation frames.\n              </SectionText>\n              <SectionText>\n                Others may apply animated effects, such as making the image\n                spin, or cycle through colors.\n              </SectionText>\n            </Section>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>\n              Animation effects require multiple animaion frames\n            </SectionHeader>\n            <SectionText>\n              The \"Adjust Image\" effect has a \"Frame Count\" paramter.\n            </SectionText>\n            <SectionText>\n              This controls how many frames are in the animation. Typically this\n              is between 10 and 20.\n            </SectionText>\n            <SectionText>\n              More frames will increase both the time to compute the image, and\n              the final file size.\n            </SectionText>\n            <SectionText>\n              Remember that some places (like Slack and Discord) have strict\n              limits on the size of emojis.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>The order of effects matters</SectionHeader>\n            <SectionText>\n              The result of each effect is send to the next effect.\n            </SectionText>\n            <SectionText>\n              Because of this, the order of effects matter.\n            </SectionText>\n            <SectionText>\n              Experiment with moving effects around to see different effects.\n            </SectionText>\n            <SectionText>\n              For instance, applying a background color before rotating the\n              image will have a very different effect than rotating before\n              setting a background color.\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n\n      <Expandable mainEle={<Typography variant=\"h6\">Creating Gifs</Typography>}>\n        <Group>\n          <Section>\n            <SectionHeader>Gifs will compute automatically</SectionHeader>\n            <SectionText>\n              Whenever you add or change an effect, it will compute a new gif\n              directly below that effect.\n            </SectionText>\n            <SectionText>\n              The gif below to each effect shows the results of that effect on\n              the previous gif.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>Creating a GIF</SectionHeader>\n            <SectionText>\n              To export a gif, just right click on the gif itself, and click\n              \"Save Image As...\".\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n    </Group>\n  </Expandable>\n);\n\nconst Group: React.FC = ({ children }) => <Stack spacing={2}>{children}</Stack>;\n\nconst Section: React.FC = ({ children }) => (\n  <Stack width=\"sm\" spacing={1}>\n    {children}\n  </Stack>\n);\n\nconst SectionHeader: React.FC = ({ children }) => (\n  <Typography variant=\"body1\" paddingLeft=\"0.5rem\">\n    {children}\n  </Typography>\n);\n\nconst SectionText: React.FC = ({ children }) => (\n  <Typography variant=\"body2\" paddingLeft=\"1.0rem\">\n    <Icon sx={{ fontSize: 8, marginRight: 1 }}>circle</Icon> {children}\n  </Typography>\n);\n","/** Given a URL to an image, try to load it and return the data URL for it */\nexport const getImageFromUrl = async (url: string) => {\n  return new Promise<string>((resolve, reject) => {\n    const img = new Image();\n    img.setAttribute('crossOrigin', 'anonymous');\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Canvas not supported');\n      }\n      ctx.drawImage(img, 0, 0);\n      resolve(canvas.toDataURL());\n    };\n\n    img.onerror = () => {\n      reject(new Error('Error loading url'));\n    };\n\n    img.src = url;\n  });\n};\n","/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new Error(`AssertionFailure: ${message}`);\n  }\n}\n\n/** Returns a new array where the item at the given index is replaced by the given value */\nexport const replaceIndex = <T>(\n  arr: T[],\n  index: number,\n  newValueFn: (oldValue: T) => T\n): T[] => arr.map((x, i) => (index === i ? newValueFn(x) : x));\n\nexport const isUrl = (s: string): boolean =>\n  /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/.test(\n    s\n  );\n\nexport const copyToClipboard = (s: string): Promise<void> =>\n  navigator.clipboard.writeText(s);\n\nexport const readFromClipboard = (): Promise<string> =>\n  navigator.clipboard.readText();\n","import { Button, Icon, Stack, Box, TextField } from '@material-ui/core';\nimport React from 'react';\nimport { getImageFromUrl } from '../domain/importImageFromUrl';\nimport { isUrl } from '../domain/utils/misc';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  onChange,\n}) => {\n  const [error, setError] = React.useState<string | undefined>();\n  return (\n    <Stack spacing={2}>\n      <Stack direction=\"row\">\n        <TextField\n          label=\"URL\"\n          variant=\"outlined\"\n          error={!!error}\n          helperText={error ?? 'Only supports static images'}\n          onBlur={async (e) => {\n            const text = e.target.value;\n            try {\n              setError(undefined);\n              if (!isUrl(text)) {\n                return;\n              }\n              const dataUrl = await getImageFromUrl(text);\n              onChange(dataUrl);\n            } catch {\n              setError('Error importing url');\n            }\n          }}\n        />\n      </Stack>\n      <Box>OR</Box>\n      <Button\n        startIcon={<Icon>image</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        component=\"label\"\n      >\n        Upload an Image\n        <input\n          type=\"file\"\n          hidden\n          accept=\"image/png,image/jpg,image/jpeg,image/gif\"\n          name=\"source-png\"\n          onChange={async (event) => {\n            const files = Array.from(event.target.files ?? []);\n            const file = files[0];\n            if (file) {\n              // Will be undefined if user clicked the cancel button\n              const baseImage = await readFile(file);\n              onChange(baseImage);\n            }\n          }}\n        />\n      </Button>\n      {currentImageUrl && (\n        <img\n          style={{ maxWidth: '200px', maxHeight: 'auto' }}\n          src={currentImageUrl}\n          alt=\"Source\"\n        ></img>\n      )}\n    </Stack>\n  );\n};\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import seedrandom from 'seedrandom';\n\ntype JsonPrimitive = string | number | boolean | Uint8ClampedArray | null;\ninterface JsonMap {\n  [member: string]: JsonPrimitive | JsonArray | JsonMap;\n}\ninterface JsonArray extends Array<JsonPrimitive | JsonArray | JsonMap> {}\nexport type JsonType = JsonPrimitive | JsonMap | JsonArray;\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type FrameData = Uint8ClampedArray;\n\n/**\n * The results of get-pixels processImage()\n */\nexport type Image = {\n  dimensions: Dimensions;\n  frames: FrameData[];\n};\n\nexport type Random = seedrandom.prng;\n\nexport interface EffectFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport interface Parameter<T extends JsonType> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T extends JsonType> {\n  value: T;\n  onChange: (v: T) => void;\n}\n\nexport type ParamFunction<T extends JsonType> = {\n  name: string;\n  /**\n   * If the previous image is done computing, it will be given to this function.\n   * If it's not done computing, `undefined` will be given\n   */\n  defaultValue: (image?: Image) => T;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type ParamFnDefault<T extends JsonType> =\n  | ParamFunction<T>['defaultValue']\n  | T;\n\nexport const toParamFunction = <T extends JsonType>(\n  x: ParamFnDefault<T>\n): ParamFunction<T>['defaultValue'] => {\n  if (typeof x === 'function') {\n    return x;\n  }\n  return () => x;\n};\n\nexport type EffectFn<Params> = (\n  opts: EffectFnOpts<Params>\n) => Image | Promise<Image>;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Effect<T extends readonly ParamFunction<any>[]> {\n  /** Name of the effect. Must be globally unique */\n  name: string;\n  params: T;\n  /** Description of the effect, will show up in the dropdown */\n  description: string;\n  /** Extra description to be shown in the parameters dialog menu */\n  secondaryDescription?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled: boolean;\n}\n\nexport interface EffectInput {\n  effectName: string;\n  params: any;\n}\n\nexport const buildEffect = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description: string;\n  secondaryDescription?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled?: boolean;\n}): Effect<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  secondaryDescription: args.secondaryDescription,\n  fn: args.fn,\n  disabled: args.disabled ?? false,\n});\n\nexport interface AppStateEffect {\n  effectName: string;\n  paramsValues: any[];\n  state:\n    | { status: 'init' }\n    | { status: 'computing' }\n    | { status: 'done'; image: ImageEffectResult };\n}\n\nexport interface AppState {\n  version: number;\n  baseImage?: string;\n  effects: AppStateEffect[];\n  fps: number;\n}\n\nexport interface ImageEffectResult {\n  gif: string;\n  image: Image;\n}\n\nexport type AsyncRunMessage = {\n  status: 'complete';\n  result: ImageEffectResult;\n};\n\nexport interface CanvasData {\n  canvas: OffscreenCanvas | HTMLCanvasElement;\n  ctx: OffscreenCanvasRenderingContext2D | CanvasRenderingContext2D;\n}\n","// When in a web worker, the window isn't defined.\nexport const IS_WORKER = typeof window === 'undefined';\n","import { CanvasData, Dimensions, FrameData } from '../types';\nimport { IS_WORKER } from './isWorker';\nimport { assert } from './misc';\n\nexport const createCanvas = ([width, height]: Dimensions): CanvasData => {\n  if (IS_WORKER) {\n    // Note that mobile does NOT support OffscreenCanvas.\n    // So if mobile, then we can not use web workers!\n    const canvas = new OffscreenCanvas(width, height);\n    const ctx = canvas.getContext('2d');\n    assert(ctx, 'Canvas not supported');\n    return { canvas, ctx };\n  } else {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    assert(ctx, 'Canvas not supported');\n    return { canvas, ctx };\n  }\n};\n\n/** Converts a frame to a CanvasData */\nexport const frameToCanvas = ({\n  dimensions,\n  frame,\n}: {\n  dimensions: Dimensions;\n  frame: FrameData;\n}): CanvasData => {\n  const [width, height] = dimensions;\n  const { canvas, ctx } = createCanvas(dimensions);\n\n  ctx.putImageData(new ImageData(frame, width, height), 0, 0);\n\n  return { canvas, ctx };\n};\n\n/** Convert a CanvasData into a FrameData */\nexport const canvasToFrame = (canvasData: CanvasData): FrameData => {\n  const imageData = canvasData.ctx.getImageData(\n    0,\n    0,\n    canvasData.canvas.width,\n    canvasData.canvas.height\n  );\n  return imageData.data;\n};\n\n/**\n * Allows you to apply a JS Canvas to an image.\n * Use the `preEffect` and `postEffect` functions to maniuplate the image\n *  both before and after drawing the image to the canvas.\n */\nexport const applyCanvasFromFrame = ({\n  dimensions,\n  frame,\n  preEffect,\n  postEffect,\n}: {\n  dimensions: Dimensions;\n  frame: FrameData;\n  /** Manipulate the context *before* drawing the image. Set things like filters here */\n  preEffect?: (canvasData: CanvasData) => void;\n  /** Manipulate the context *after* drawing the image. Use this to draw on top of the image */\n  postEffect?: (canvasData: CanvasData) => void;\n}): FrameData => {\n  // Create a new Canvas using our existing image.\n  // We can then draw that onto a second canvas, which will have effects applied to it.\n  const canvasData = createCanvas(dimensions);\n\n  canvasData.ctx.save();\n  preEffect?.(canvasData);\n  canvasData.ctx.drawImage(frameToCanvas({ dimensions, frame }).canvas, 0, 0);\n  canvasData.ctx.restore();\n  postEffect?.(canvasData);\n\n  return canvasData.ctx.getImageData(0, 0, dimensions[0], dimensions[1]).data;\n};\n\n/** Combines two canvases together. It's assumed that the first frame has some transparency to it. */\nexport const combineImages = ({\n  dimensions,\n  background,\n  foreground,\n}: {\n  dimensions: Dimensions;\n  background: FrameData | CanvasData;\n  foreground: FrameData | CanvasData;\n}): FrameData => {\n  const backgroundCanvas =\n    'canvas' in background\n      ? background\n      : frameToCanvas({\n          dimensions: dimensions,\n          frame: background,\n        });\n\n  const foregroundCanvas =\n    'canvas' in foreground\n      ? foreground\n      : frameToCanvas({\n          dimensions: dimensions,\n          frame: foreground,\n        });\n\n  backgroundCanvas.ctx.drawImage(foregroundCanvas.canvas, 0, 0);\n\n  return canvasToFrame(backgroundCanvas);\n};\n\nexport const applyFilter = (\n  canvas: CanvasData,\n  {\n    blur,\n    brightness,\n    contrast,\n    opacity,\n    saturation,\n  }: {\n    opacity?: number;\n    blur?: number;\n    brightness?: number;\n    contrast?: number;\n    saturation?: number;\n  }\n): CanvasData => {\n  const filters = [\n    blur == null ? '' : `blur(${blur}px)`,\n    brightness == null ? '' : `brightness(${brightness}%)`,\n    contrast == null ? '' : `contrast(${contrast}%)`,\n    opacity == null ? '' : `opacity(${opacity}%)`,\n    saturation == null ? '' : `saturate(${saturation}%)`,\n  ].filter((x) => x.length > 0);\n\n  canvas.ctx.filter = filters.join(' ');\n\n  return canvas;\n};\n\nexport const applyTransform = (\n  canvas: CanvasData,\n  {\n    horizontalScale,\n    verticalScale,\n    horizontalSkew,\n    verticalSkew,\n    horizontalTranslation,\n    verticalTranslation,\n  }: {\n    horizontalScale?: number;\n    verticalScale?: number;\n    horizontalSkew?: number;\n    verticalSkew?: number;\n    horizontalTranslation?: number;\n    verticalTranslation?: number;\n  }\n): CanvasData => {\n  canvas.ctx.transform(\n    horizontalScale ?? 1,\n    verticalSkew ?? 0,\n    horizontalSkew ?? 0,\n    verticalScale ?? 1,\n    horizontalTranslation ?? 0,\n    verticalTranslation ?? 0\n  );\n  return canvas;\n};\n\n/**\n * Rotates a canvas a number of degrees.\n * 0 degrees points to the right, 90 degrees points up.\n */\nexport const applyRotation = (\n  canvas: CanvasData,\n  degrees: number\n): CanvasData => {\n  const offsetX = canvas.canvas.width / 2;\n  const offsetY = canvas.canvas.height / 2;\n  applyTransform(canvas, {\n    horizontalTranslation: offsetX,\n    verticalTranslation: offsetY,\n  });\n  const radians = -(degrees * Math.PI) / 180;\n  canvas.ctx.rotate(radians);\n  applyTransform(canvas, {\n    horizontalTranslation: -offsetX,\n    verticalTranslation: -offsetY,\n  });\n  return canvas;\n};\n","import * as convert from 'color-convert';\nimport { Color, Coord } from '../types';\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nconst weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our effect functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\n/**\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftTowardsHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Adds the given amount to the hue of the color.\n * Amount should be between 0 and 360\n */\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\n  return [newR, newG, newB, a];\n};\n\n/**\n * Returns the angle in degrees (0 to 360) from c2 to c1\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\nexport const pointDistance = ([x1, y1]: Coord, [x2, y2]: Coord): number => {\n  const xDiff = Math.pow(x2 - x1, 2);\n  const yDiff = Math.pow(y2 - y1, 2);\n  return Math.sqrt(xDiff + yDiff);\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n\nexport const adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nexport const adjustBrightness = (color: Color, amount: number): Color => {\n  const d = (amount / 100) * 128;\n  const [r, g, b, a] = color;\n  return clampColor([r + d, g + d, b + d, a]);\n};\n\n// Amount: -100 to 100\nexport const adjustContrast = (color: Color, amount: number): Color => {\n  const d = amount / 100 + 1;\n  const [r, g, b, a] = color;\n  return clampColor([\n    d * (r - 128) + 128,\n    d * (g - 128) + 128,\n    d * (b - 128) + 128,\n    a,\n  ]);\n};\n\n/**\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\n */\nexport const colorDiff = (c1: Color, c2: Color): number => {\n  // Red-mean color diff algorithm\n  // https://en.wikipedia.org/wiki/Color_difference\n  const deltaRed = c1[0] - c2[0];\n  const deltaBlue = c1[1] - c2[1];\n  const deltaGreen = c1[2] - c2[2];\n  const rSomething = (c1[0] + c2[0]) / 2;\n\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\n  const gComponent = 4 * deltaGreen * deltaGreen;\n  // 765 = ~ difference between black and white pixels\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\n};\n","import { range } from 'remeda';\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  EffectFn,\n  EffectFnOpts,\n  FrameData,\n  Image,\n  Random,\n} from '../types';\nimport {\n  applyCanvasFromFrame,\n  applyTransform,\n  canvasToFrame,\n  createCanvas,\n  frameToCanvas,\n} from './canvas';\nimport { clampColor, TRANSPARENT_COLOR } from './color';\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: FrameData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: FrameData,\n    frameIndex: number,\n    frameCount: number\n  ) => FrameData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): FrameData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8ClampedArray(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress: frameIndex / frameCount,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/**\n * Similar to mapImage, but the first argument pre-computes some things for\n *  each frame, which is then passed to the second callback function.\n * This is useful for performance (only compute things every frame rather than every pixel),\n *  and also allows you to generate some random value that will be the same for every frame.\n */\nexport const mapImageWithPrecompute = <T, R>(\n  compute: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n  }) => R,\n  cb: (args: {\n    computed: R;\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const computed = compute({\n        image,\n        dimensions: image.dimensions,\n        random,\n        parameters,\n        frameCount,\n        frameIndex,\n        animationProgress,\n      });\n\n      return mapCoords(image.dimensions, (coord) =>\n        cb({\n          computed,\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      );\n    });\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Scales the image according to a coefficient\n * Coefficient should be greater than 0.\n * A coefficient of 1 equals no scaling.\n * The image will be centered.\n */\nexport const scaleImage = ({\n  image,\n  horizontalScale,\n  verticalScale,\n}: {\n  image: Image;\n  horizontalScale?: number;\n  verticalScale?: number;\n}): Image => {\n  const [width, height] = image.dimensions;\n  // Adjust how much the image is offset in order to keep it centered\n  const offsetX = (width / 2) * (horizontalScale ?? 1) - width / 2;\n  const offsetY = (height / 2) * (verticalScale ?? 1) - height / 2;\n  return mapFrames(image, (imageData) =>\n    applyCanvasFromFrame({\n      dimensions: image.dimensions,\n      frame: imageData,\n      preEffect: (canvasData) =>\n        applyTransform(canvasData, {\n          horizontalScale,\n          verticalScale,\n          horizontalTranslation: -offsetX,\n          verticalTranslation: -offsetY,\n        }),\n    })\n  );\n};\n\n/**\n * Resize the image to the given dimensions.\n * If `keepScale` is true, then the image will be automatically\n *  resized to keep match the new dimensions.\n * If false, then the image will remain the same size, and will be cropped\n *  if the new dimensions are smaller.\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n  keepScale,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n  keepScale: boolean;\n}): Image => {\n  const newFrames = mapFrames(image, (frame) => {\n    const rootCanvas = createCanvas([newWidth, newHeight]);\n    const imgCanvas = frameToCanvas({ dimensions: image.dimensions, frame });\n\n    if (keepScale) {\n      // Just blow it up\n      rootCanvas.ctx.drawImage(imgCanvas.canvas, 0, 0, newWidth, newHeight);\n    } else {\n      // Keep the image the same size, but be sure to center it\n      const offsetX = newWidth / 2 - image.dimensions[0] / 2;\n      const offsetY = newHeight / 2 - image.dimensions[1] / 2;\n      rootCanvas.ctx.drawImage(\n        imgCanvas.canvas,\n        offsetX,\n        offsetY,\n        image.dimensions[0],\n        image.dimensions[1]\n      );\n    }\n\n    return canvasToFrame(rootCanvas);\n  });\n\n  return {\n    dimensions: [newWidth, newHeight],\n    frames: newFrames.frames,\n  };\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8ClampedArray(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const duplicateImage = (image: Image): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((f) => new Uint8ClampedArray(f)),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\nexport const changeFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had fewer than that, then we'll\n  //  duplicate some frames to approximately slow the animation.\n  // If the original has more frames, then we'll discard some frames.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) => {\n      const frameToCopy = Math.floor((i / frameCount) * currentFrames.length);\n      return currentFrames[frameToCopy];\n    }),\n  };\n};\n","import { Icon, Tooltip } from '@material-ui/core';\nimport React from 'react';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { useDebounce } from '../useDebounce';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  const [val, setVal] = useDebounce({\n    initial: value,\n    callback: onChange,\n  });\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={val}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) => {\n            setVal(value as number);\n          }}\n        />\n        <Typography variant=\"body2\">{val}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue: ParamFnDefault<number>;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import React from 'react';\nimport { useDebounceCallback } from '@react-hook/debounce';\n\nconst DEFAULT_WAIT = 750;\n\ninterface Props<T> {\n  initial: T;\n  callback: (arg: T) => void;\n  waitMillis?: number;\n}\n\nexport function useDebounce<T>({ initial, callback, waitMillis }: Props<T>) {\n  const [val, setVal] = React.useState(initial);\n  const onChangeDebounce = useDebounceCallback(\n    callback,\n    waitMillis ?? DEFAULT_WAIT\n  );\n\n  const setDebounced = React.useCallback(\n    (arg: T) => {\n      setVal(arg);\n      onChangeDebounce(arg);\n    },\n    [onChangeDebounce]\n  );\n\n  const setImmediate = React.useCallback(\n    (arg: T) => {\n      setVal(arg);\n      callback(arg);\n    },\n    [callback]\n  );\n\n  return [val, setDebounced, setImmediate] as const;\n}\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { resizeImage, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const adjustImage = buildEffect({\n  name: 'Adjust Image',\n  description: 'Change the dimensions, brightness, contrast etc.',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [\n      resizeToWidth,\n      resizeToHeight,\n      brightness,\n      contrast,\n      saturation,\n    ],\n  }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\n\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\n    const newWidth =\n      hasScaleChange && resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      hasScaleChange && resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\n\n    let currImage = image;\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = resizeImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n        keepScale: false,\n      });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      applyCanvasFromFrame({\n        dimensions: currImage.dimensions,\n        frame: imageData,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            brightness: brightness + 100,\n            contrast: contrast + 100,\n            saturation: saturation + 100,\n          }),\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = resizeImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n        keepScale: false,\n      });\n    }\n\n    return currImage;\n  },\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  Color,\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils/color';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value: Color;\n  description?: string;\n  onChange: (v: Color) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={toHexColor(value)}\n        onChangeComplete={(c) => {\n          onChange(fromHexColor(c.hex));\n        }}\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<Color>;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const backgroundColor = buildEffect({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [color, opacity] }) =>\n    mapFrames(image, (frame) => {\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => color),\n        foreground,\n      });\n    }),\n});\n","import React from 'react';\nimport { Checkbox, Stack, Typography } from '@material-ui/core';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst CheckboxParam: React.FC<{\n  name: string;\n  value?: boolean;\n  description?: string;\n  onChange: (v: boolean) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Checkbox\n          aria-label={name}\n          checked={value}\n          onChange={(e) => onChange(e.target.checked)}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function checkboxParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<boolean>;\n  description?: string;\n}): ParamFunction<boolean> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <CheckboxParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import React from 'react';\nimport { ImagePicker } from '../components/ImagePicker';\nimport { readImage } from '../domain/run';\nimport { Image, ParamFunction } from '../domain/types';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\ntype ParamType = {\n  dataUrl: string;\n  image: Image;\n};\n\n// Just a 1x1 black jpg. Surprisingly big!\nconst DEFAULT_IMAGE: ParamType = {\n  dataUrl:\n    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\n  image: {\n    dimensions: [1, 1],\n    frames: [new Uint8ClampedArray([0, 0, 0, 255])],\n  },\n};\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<ParamType> {\n  return {\n    name,\n    defaultValue: () => DEFAULT_IMAGE,\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={params.value.dataUrl}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ dataUrl, image });\n        }}\n      />\n    ),\n  };\n}\n","import {\n  FormControl,\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst RadioParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value: string;\n  description?: string;\n  onChange: (s: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label={name}\n          defaultValue={value}\n          onChange={(event) => onChange(event.target.value)}\n        >\n          {options.map((t) => (\n            <FormControlLabel\n              value={t.value}\n              control={<Radio />}\n              label={t.name}\n              key={t.value}\n            />\n          ))}\n        </RadioGroup>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function radioParam<T extends string>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue: ParamFnDefault<T>;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <RadioParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={(s) => params.onChange(s as T)}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { combineImages, frameToCanvas } from '../domain/utils/canvas';\nimport { resizeImage, mapFrames } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { radioParam } from '../params/radioParam';\n\nexport const backgroundImage = buildEffect({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  secondaryDescription:\n    'If the selected image is animated, this will speed up/slow down ' +\n    'the animation to match the original image',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    checkboxParam({\n      name: 'Scale Image',\n      defaultValue: false,\n      description:\n        'If true, the new image will be scaled to fit the dimensions of the original image',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [otherImagePreResize, type, keepScale] }) => {\n    const otherImage = resizeImage({\n      image: otherImagePreResize.image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n      keepScale,\n    });\n\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n\n      const thisFrameCanvas = frameToCanvas({\n        dimensions: image.dimensions,\n        frame,\n      });\n\n      const otherImageFrameIndex = Math.floor(\n        animationProgress * otherImage.frames.length\n      );\n      const otherFrameCanvas = frameToCanvas({\n        dimensions: otherImage.dimensions,\n        frame: otherImage.frames[otherImageFrameIndex],\n      });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: type === 'background' ? otherFrameCanvas : thisFrameCanvas,\n        foreground: type === 'background' ? thisFrameCanvas : otherFrameCanvas,\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const blur = buildEffect({\n  name: 'Blur',\n  description: 'Blurs the image',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      defaultValue: 2,\n      min: 0,\n      max: 20,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [amount] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyFilter(canvasData, { blur: amount }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildEffect({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[1] / 10) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [speed] }) => ({\n      yOffset: Math.round(speed * Math.sin(animationProgress * 2 * Math.PI)),\n    }),\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x, y + yOffset])\n  ),\n});\n","import { concat, drop, pipe, reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const bounceAnimation = buildEffect({\n  name: 'Bounce Animation',\n  description: 'When the animation finishes, it will be replayed in reverse',\n  secondaryDescription: 'This doubles the number of animation frames.',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: concat(\n      image.frames,\n      pipe(image.frames, drop(1), reverse(), drop(1))\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildEffect({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [radius] }) => ({\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\n    }),\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y + yOffset])\n  ),\n});\n","import {\n  Button,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  JsonType,\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ninterface VariableLengthProps<T extends JsonType> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value: T[];\n  description?: string;\n  onChange: (v: T) => void;\n}\n\ntype ParamState = { param: ParamFunction<any>; pValue: any };\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<ParamState[]>(\n    value.map((v) => ({ param: createNewParam(), pValue: v }))\n  );\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: pValue,\n            onChange: (newValue) => {\n              const p = params.map((oldP, i) => {\n                if (idx === i) {\n                  return {\n                    param,\n                    pValue: newValue,\n                  };\n                }\n                return oldP;\n              });\n              setParams(p);\n              onChange(p.map((n) => n.pValue));\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange(newParams.map((n) => n.pValue));\n                }}\n                style={{\n                  visibility:\n                    idx === 0 /* Hide delete on first item */\n                      ? 'hidden'\n                      : undefined,\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams: ParamState[] = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue(),\n              },\n            ];\n            setParams(newParams);\n            const vals = newParams.map((n) => n.pValue);\n            onChange(vals);\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T extends JsonType>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue: ParamFnDefault<T[]>;\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  adjustBrightness,\n  getAveragePixelValue,\n} from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildEffect({\n  name: 'Colors',\n  description: 'Make the image flash different colors of your choosing',\n  secondaryDescription: 'Increase the brightness to increase the effect',\n  params: [\n    sliderParam({\n      name: 'Brightness Increase',\n      defaultValue: 0,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [brightnessIncrease, colors] }) => ({\n      brightnessIncrease,\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { brightnessIncrease, chosenColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (isTransparent(srcPixel)) {\n        return [0, 0, 0, 0];\n      }\n\n      const brightnessAdjusted =\n        brightnessIncrease > 0\n          ? adjustBrightness(srcPixel, brightnessIncrease)\n          : srcPixel;\n      const gray = getAveragePixelValue(brightnessAdjusted);\n\n      return [\n        (gray * chosenColor[0]) / 255,\n        (gray * chosenColor[1]) / 255,\n        (gray * chosenColor[2]) / 255,\n        255,\n      ];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  combineImages,\n  applyCanvasFromFrame,\n  applyFilter,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildEffect({\n  name: 'Colors Background',\n  description:\n    'Transparent pixels will flash different colors of your choosing',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [colors, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const bgColor = colors[Math.floor(animationProgress * colors.length)];\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => bgColor),\n        foreground,\n      });\n    }),\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildEffect({\n  name: 'Double Vision',\n  description: 'See double',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\n      const dir = x % 2 === 0 ? -1 : 1;\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildEffect({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      animationProgress,\n      parameters: [radius],\n    }) => ({\n      dist: Math.cos(animationProgress * 2 * Math.PI) * radius,\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, dist },\n      dimensions: [width, height],\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildEffect, Color, Coord, Image } from '../domain/types';\nimport { TRANSPARENT_COLOR, colorDiff } from '../domain/utils/color';\nimport {\n  duplicateImage,\n  getPixelFromSource,\n  setPixel,\n} from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\n// TODO\nexport const fill = buildEffect({\n  disabled: true,\n  name: 'Fill Transparent',\n  description:\n    'Makes transparent all pixels of similar color surrounding a point',\n  params: [\n    colorPickerParam({\n      name: 'Color to Make Transparent',\n      defaultValue: [0, 0, 0, 255],\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image: oldImage, parameters: [colorToReplace, tolerance] }) => {\n    const image = duplicateImage(oldImage);\n\n    for (\n      let frameIndex = 0;\n      frameIndex < image.frames.length;\n      frameIndex += 1\n    ) {\n      floodFill({\n        image,\n        frameIndex,\n        colorToReplace,\n        newColor: TRANSPARENT_COLOR,\n        tolerance,\n      });\n    }\n\n    return image;\n  },\n});\n\n// Mutates the given image/frameIndex\nconst floodFill = ({\n  image,\n  frameIndex,\n  colorToReplace,\n  newColor,\n  tolerance,\n}: {\n  image: Image;\n  frameIndex: number;\n  colorToReplace: Color;\n  tolerance: number;\n  newColor: Color;\n}) => {\n  const visited = (() => {\n    const set = new Set<string>();\n    return {\n      add: ([x, y]: Coord) => {\n        set.add(`${x}-${y}`);\n      },\n      has: ([x, y]: Coord) => set.has(`${x}-${y}`),\n    };\n  })();\n  const stack: Coord[] = [[0, image.dimensions[1] - 1]]; // Bottom right pixel\n  const push = (coord: Coord) => {\n    if (!visited.has(coord)) {\n      visited.add(coord);\n      stack.push(coord);\n    }\n  };\n\n  while (stack.length > 0) {\n    const coord = stack.pop()!;\n    const [x, y] = coord;\n    if (\n      x < 0 ||\n      x >= image.dimensions[0] ||\n      y < 0 ||\n      y >= image.dimensions[1]\n    ) {\n      // Out of bounds\n      continue;\n    }\n\n    const currColor = getPixelFromSource(\n      image.dimensions,\n      image.frames[frameIndex],\n      coord\n    );\n    if (colorDiff(currColor, colorToReplace) * 100 > tolerance) {\n      continue;\n    }\n\n    setPixel({\n      image,\n      frameIndex,\n      color: newColor,\n      coord: coord,\n    });\n\n    push([x + 1, y]);\n    push([x - 1, y]);\n    push([x, y + y]);\n    push([x, y - 1]);\n  }\n};\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildEffect({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      animationProgress,\n      dimensions: [width, height],\n      parameters: [radius],\n    }) => {\n      const expanding = animationProgress < 0.5;\n      return {\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\n        centerX: width / 2,\n        centerY: height / 2,\n      };\n    },\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { adjustSaturation } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nconst MAX_GRID_SIZE = 64;\n\nexport const grid = buildEffect({\n  name: 'Grid',\n  description: 'Removes the color from all pixels not aligned with a grid',\n  params: [\n    sliderParam({\n      name: 'Grid Size',\n      description: 'The length of each square in the grid',\n      defaultValue: 24,\n      min: 2,\n      max: MAX_GRID_SIZE,\n      step: 2,\n    }),\n    sliderParam({\n      name: 'Grid Angle',\n      defaultValue: 45,\n      min: 0,\n      max: 90,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    let isOnGrid = false;\n    if (gridAngle % 90 === 0) {\n      // Vertical/Horizonal lines\n      isOnGrid = x % gridSize === 0 || y % gridSize === 0;\n    } else {\n      // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\n      // Larger threshold = thicker lines.\n      const threshold =\n        ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\n\n      const onGrid = (angleDegrees: number) => {\n        const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\n        return Math.abs(Math.round(n) - n) < threshold;\n      };\n\n      isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\n    }\n\n    return isOnGrid ? p : adjustSaturation(p, -100);\n  }),\n});\n\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\n","import { Stack, Typography } from '@material-ui/core';\nimport * as convert from 'color-convert';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { toHexColor } from '../domain/utils/color';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor = React.useMemo(\n    () =>\n      value === undefined\n        ? undefined\n        : toHexColor([...convert.hsl.rgb([value, 100, 50]), 255]),\n    [value]\n  );\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        // HSL is in [0-360, 0-100, 0-100]\n        onChangeComplete={({ hsl }) => onChange(hsl.h)}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueChange = buildEffect({\n  name: 'Hue Change',\n  description: 'Change the hue of each pixel towards some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftTowardsHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildEffect({\n  name: 'Hue Shift',\n  description: 'Shift the hue of each pixel in the image by some amount',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How much to shift the hue of each pixel',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [amount] }) =>\n    shiftHue(getSrcPixel(coord), (amount / 100) * 360)\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShiftPulse = buildEffect({\n  name: 'Hue Shift Pulse',\n  description: 'Shift the hue to the given value in a pulsating manner',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, frameCount, frameIndex, parameters: [hue] }) => {\n      const amount = Math.abs(Math.sin(Math.PI * (frameIndex / frameCount)));\n      return shiftTowardsHue(getSrcPixel(coord), hue, amount * 360);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftHue } from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueWave = buildEffect({\n  name: 'Hue Wave',\n  description: 'Shifts the hue of pixels in the image in a wave motion',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the hue shift effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many waves you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: -1 * animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord,\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const [, y] = coord;\n      const amount = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return shiftHue(getSrcPixel(coord), (amount / 100) * 360);\n    }\n  ),\n});\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value: string;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() => {\n            if (val.length > 0) {\n              onChange(val);\n            }\n          }}\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue: ParamFnDefault<string>;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value}\n    />\n  ),\n});\n","import seedrandom from 'seedrandom';\nimport { buildEffect, Color } from '../domain/types';\nimport { isTransparent } from '../domain/utils/color';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils/image';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildEffect({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [seed] }) => {\n    const random = seedrandom(seed);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyTransform } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\n\nexport const mirror = buildEffect({\n  name: 'Mirror',\n  description: 'Mirrors the image',\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyTransform(canvasData, {\n            horizontalScale: -1,\n            horizontalTranslation: image.dimensions[0],\n          }),\n      })\n    ),\n});\n","import * as convert from 'color-convert';\nimport { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils/image';\n\nexport const nuke = buildEffect({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const threshold = animationProgress * 100;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const opacity = buildEffect({\n  name: 'Opacity',\n  description: 'Sets the opacity of the image',\n  secondaryDescription:\n    'Because gifs do not support transparency, ' +\n    'the preview below will not reflect the transparency accurately. ' +\n    'It will apply to subsequent effects though.',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      defaultValue: 50,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [amount] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyFilter(canvasData, { opacity: amount }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildEffect({\n  name: 'Party',\n  description: 'Shift the hue of the image over the course of the animation',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      animationProgress,\n      parameters: [amount, shiftSpeed],\n    }) => {\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n      const srcPixel = getSrcPixel(coord);\n      return shiftTowardsHue(srcPixel, newH, amount);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const partyBackground = buildEffect({\n  name: 'Party Background',\n  description:\n    'Smoothly cycles through background colors over the course of the animation',\n  params: [\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [shiftSpeed, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n      const bgColor = colorFromHue(newH);\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => bgColor),\n        foreground,\n      });\n    }),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\n\nexport const partyHarder = buildEffect({\n  name: 'Party Harder',\n  description:\n    'Shift the hue of each individual pixel over the course of the animation',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) =>\n    shiftHue(getSrcPixel(coord), animationProgress * 360)\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor, calculateAngle } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheelColors = buildEffect({\n  name: 'Pinwheel Colors',\n  description: 'Create a background pinwheel of colors of your choosing',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\n  }) => {\n    const [width, height] = image.dimensions;\n\n    const ribbonCount = colors.length * groupCount;\n    const ribbonArcDegrees = Math.round(360 / ribbonCount);\n    // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n    //  won't get a smooth transition.\n    // We'll cut off colors from the end of the list until we get an even multiple.\n    let colorsLength = colors.length;\n    while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n      colorsLength -= 1;\n    }\n\n    const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n\n      const background = mapCoords(image.dimensions, (coord) => {\n        const pointAngle = calculateAngle(coord, center);\n\n        const colorIdx =\n          Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n        // Increment colorIdx based on current frame progress\n        const idx =\n          (Math.floor(animationProgress * colorsLength) + colorIdx) %\n          colorsLength;\n        return colors[idx];\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    });\n  },\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { calculateAngle, shiftTowardsHue } from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelRainbow = buildEffect({\n  name: 'Pinwheel Rainbow',\n  description: 'Make the image look like a pinwheel rainbow',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    sliderParam({\n      name: 'Strength',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      parameters: [groupCount, amount, offsetX, offsetY],\n    }) => {\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n      return { center };\n    },\n    ({\n      computed: { center },\n      coord,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, strength],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const pointAngle = calculateAngle(coord, center);\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n\n      return shiftTowardsHue(srcPixel, newH, strength);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { calculateAngle, colorFromHue } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelRainbowBackground = buildEffect({\n  name: 'Pinwheel Rainbow Background',\n  description: 'Create a background pinwheel of rainbow colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n\n      const background = mapCoords(image.dimensions, (coord) => {\n        const pointAngle = calculateAngle(coord, center);\n        const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n        return colorFromHue(newH);\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    }),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radianceColors = buildEffect({\n  name: 'Radiance Colors',\n  description: 'Radiate background colors of your choosing out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\n  }) => {\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n\n      const colorList = range(0, groupCount).flatMap(() => colors);\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const background = mapCoords(image.dimensions, ([x, y]) => {\n        const xRelCenter = x - centerX - offsetX;\n        const yRelCenter = y - centerY + offsetY;\n\n        const maxDist = Math.sqrt(\n          (width / 2) * (width / 2) + (height / 2) * (height / 2)\n        );\n        const distFromCenter = Math.sqrt(\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\n        );\n\n        const colorIdx =\n          Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n          colorList.length;\n\n        // Increment colorIdx based on current frame progress\n        const idx =\n          (Math.floor(animationProgress * colorList.length) + colorIdx) %\n          colorList.length;\n        return colorList[idx];\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceRainbow = buildEffect({\n  name: 'Radiance Rainbow',\n  description: 'Radiate rainbow colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    sliderParam({\n      name: 'Strength',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height] }) => ({\n      centerX: width / 2,\n      centerY: height / 2,\n      maxDist: Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      ),\n    }),\n    ({\n      computed: { centerX, centerY, maxDist },\n      coord,\n      animationProgress,\n      parameters: [groupCount, strength, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const newH =\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\n          360 * animationProgress) %\n        360;\n\n      return shiftTowardsHue(src, newH, strength);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceRainbowBackground = buildEffect({\n  name: 'Radiance Rainbow Background',\n  description: 'Radiate rainbow colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const maxDist = Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      );\n\n      const background = mapCoords(image.dimensions, ([x, y]) => {\n        const xRelCenter = x - centerX - offsetX;\n        const yRelCenter = y - centerY + offsetY;\n\n        const distFromCenter = Math.sqrt(\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\n        );\n\n        const newH =\n          ((1 - distFromCenter / maxDist) * 360 * groupCount +\n            360 * animationProgress) %\n          360;\n\n        return colorFromHue(newH);\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    }),\n});\n","import { minBy, sortBy } from 'remeda';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  toHexColor,\n  TRANSPARENT_COLOR,\n  fromHexColor,\n  colorDiff,\n} from '../domain/utils/color';\nimport {\n  mapImageWithPrecompute,\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const reduceColorPalette = buildEffect({\n  name: 'Reduce Color Palette',\n  description:\n    'Reduce the number of unique colors in the gif, to reduce the file size.',\n  secondaryDescription:\n    'This can be a slow operation depending on the number of final colors',\n  params: [\n    sliderParam({\n      name: 'Percent Reduction',\n      description:\n        '0% will have no effect, 100% will result in just one unique color in the result',\n      defaultValue: 70,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image, parameters: [percentReduction] }) => {\n      // Buid up a set of all unique colors.\n      // These will be our data points that we're going to group into to N clusters\n      const allColorsSet = new Set<string>();\n      mapFrames(image, (frame) =>\n        mapCoords(image.dimensions, (coord) => {\n          const px = getPixelFromSource(image.dimensions, frame, coord);\n          allColorsSet.add(toHexColor(px));\n          return TRANSPARENT_COLOR; // Not actually used, just makes TS happy\n        })\n      );\n\n      const allColors = Array.from(allColorsSet).map(fromHexColor);\n      const numColors = Math.max(\n        Math.floor((allColors.length * (100 - percentReduction)) / 100),\n        1\n      );\n\n      // Create a mapping of each unique color to the list of colors are the closest to it.\n      // We'll then pick the top N colors.\n      // Lastly, we'll replace every pixel with the color that it reduces to.\n\n      // colorMap[i].numClosestColors is the number of colors closest to allColors[i]\n      const colorMap: { color: Color; numClosestColors: number }[] =\n        allColors.map((c) => ({\n          color: c,\n          numClosestColors: 0,\n        }));\n\n      for (let i = 1; i < allColors.length; i += 1) {\n        let closestColorIdx = 0;\n        let closetsColorDist = colorDiff(\n          allColors[i],\n          allColors[closestColorIdx]\n        );\n        // Find the other color that is closest to this one\n        for (let k = 0; k < allColors.length; k += 1) {\n          if (k === i) {\n            // Don't check the distance between this color and itself\n            continue;\n          }\n          const dist = colorDiff(allColors[k], allColors[i]);\n          if (dist < closetsColorDist) {\n            closestColorIdx = k;\n            closetsColorDist = dist;\n          }\n        }\n        colorMap[closestColorIdx].numClosestColors += 1;\n      }\n\n      const colorPalette = sortBy(colorMap, [(c) => c.numClosestColors, 'desc'])\n        .slice(0, numColors)\n        .map(({ color }) => color);\n\n      return { colorPalette };\n    },\n    ({ coord, getSrcPixel, computed: { colorPalette } }) => {\n      const px = getSrcPixel(coord);\n      // Find the color in the palette this one is closest to\n      const closestColor = minBy(colorPalette, (top) => colorDiff(top, px))!;\n      return closestColor;\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const repeatAnimation = buildEffect({\n  name: 'Repeat Animation',\n  description: 'Repeats the current animation some number of times',\n  secondaryDescription: 'This can greatly increase the final file size!',\n  params: [\n    sliderParam({\n      name: 'Number of Repeats',\n      defaultValue: 1,\n      min: 1,\n      max: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [numRepeats] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\n      (i) => image.frames[i % image.frames.length]\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildEffect({\n  name: 'Resize Image',\n  description: 'Change the absolute dimensions of the image.',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\n      min: 0,\n    }),\n    checkboxParam({\n      name: 'Keep scale',\n      description:\n        'If checked, the image will be stretched to fit the new dimensions',\n      defaultValue: false,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight, keepScale] }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n    const newWidth =\n      resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n    return resizeImageUtil({\n      image,\n      newWidth,\n      newHeight,\n      keepScale,\n    });\n  },\n});\n","import { reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const reverseAnimation = buildEffect({\n  name: 'Reverse Animation',\n  description: 'Reverses the animation',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: reverse(image.frames),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const ripple = buildEffect({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the ripple effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many ripples you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord: [x, y],\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const offset = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return getSrcPixel([x + offset, y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyRotation } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const rotate = buildEffect({\n  name: 'Rotate',\n  description: 'Rotes the image to a given angle',\n  params: [\n    sliderParam({\n      name: 'Angle',\n      defaultValue: 0,\n      min: 0,\n      max: 360,\n      step: 5,\n      description:\n        'The angle in degrees. 0 degrees points to the right, 90 degrees points up.',\n    }),\n  ],\n  fn: ({ image, parameters: [angle] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyRotation(canvasData, angle),\n      })\n    ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\n\nexport const roxbury = buildEffect({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], animationProgress }) => {\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(animationProgress * 4);\n      const phaseIdx = (animationProgress - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      return {\n        angle,\n        cos: Math.cos(-angle * 1.35),\n        sin: Math.sin(-angle * 1.35),\n        rotatePointX: width * 0.25,\n        rotatePointY: height * 0.7,\n      };\n    },\n    ({\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n      const newCoord: Coord = [\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { scaleImage as scaleImageUtil } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const scaleImage = buildEffect({\n  name: 'Scale Image',\n  description: 'Scale the image without changing the dimensions',\n  params: [\n    sliderParam({\n      name: 'Scale',\n      min: 0.1,\n      max: 3,\n      step: 0.1,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [scale] }) =>\n    scaleImageUtil({ image, horizontalScale: scale, verticalScale: scale }),\n});\n","import { buildEffect } from '../domain/types';\nimport { changeFrameCount } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const setAnimationLength = buildEffect({\n  name: 'Set Animation Length',\n  description: 'Change the length of the animation.',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description: 'Set how many frames of animation there will be.',\n      defaultValue: (image) => (image ? image.frames.length : 0),\n      min: 1,\n      max: 60,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [frameCount] }) => {\n    return changeFrameCount(image, frameCount);\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildEffect({\n  name: 'Shake',\n  description: 'Make the image shake left and right',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: Math.round(\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\n      ),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y])\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { getPixelFromSource, mapCoords } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\n\nexport const slowAnimation = buildEffect({\n  name: 'Slow Animation',\n  description: 'Attempts to slow the animation by adding intermediate frames',\n  secondaryDescription: 'This will make the final filze size larger',\n  params: [\n    radioParam<'basic' | 'smooth'>({\n      name: 'Interpolation Type',\n      options: [\n        { name: 'Basic', value: 'basic' },\n        { name: 'Smooth', value: 'smooth' },\n      ],\n      defaultValue: 'basic',\n      description:\n        'With basic interpolation, frames are simply duplicated. ' +\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\n    }),\n  ],\n  fn: ({ image, parameters: [type] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\n\n      // Even numbered frames are just the original frames\n      if (i % 2 === 0) {\n        return image.frames[i / 2];\n      }\n\n      const ogFrameIdx = (i - 1) / 2;\n\n      if (type === 'basic') {\n        // Intermediate frame is simply the previous OG frame\n        return image.frames[ogFrameIdx];\n      }\n\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\n      return mapCoords(image.dimensions, (coord) => {\n        const [r1, g1, b1, a1] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx],\n          coord\n        );\n        const [r2, g2, b2, a2] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx + 1],\n          coord\n        );\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\n      });\n    }),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyRotation } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\n\nexport const spin = buildEffect({\n  name: 'Spin',\n  description: 'Make the image rotate about the center point in an animation',\n  params: [\n    radioParam<'clockwise' | 'counter'>({\n      name: 'Direction',\n      defaultValue: 'clockwise',\n      options: [\n        { name: 'Clockwise', value: 'clockwise' },\n        { name: 'Counter-Clockwise', value: 'counter' },\n      ],\n    }),\n  ] as const,\n  fn: ({ image, parameters: [direction] }) =>\n    mapFrames(image, (frame, idx, frameCount) => {\n      const angle =\n        (((direction === 'counter' ? 1 : -1) * idx) / frameCount) * 360;\n      return applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyRotation(canvasData, angle),\n      });\n    }),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildEffect({\n  name: 'Static',\n  description: 'Adds random static to each frame the image',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      if (isBackground && type === 'background') {\n        const inverse = Math.ceil(random() * 100) < strength;\n        const grey = Math.ceil(random() * 255);\n\n        return inverse ? [grey, grey, grey, 255] : src;\n      }\n\n      const isStatic = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return isStatic ? [grey, grey, grey, src[3]] : src;\n    }\n  ),\n});\n","import {\n  FormControl,\n  MenuItem,\n  Select,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value?: any;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <Select\n          autoWidth\n          value={value}\n          onChange={(event) => onChange(event.target.value as string)}\n        >\n          {options.map((t) => (\n            <MenuItem key={t.value} value={t.value}>\n              {t.name}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function dropdownParam(args: {\n  name: string;\n  options: readonly { name: string; value: string }[];\n  description?: string;\n  defaultValue: ParamFnDefault<string>;\n}): ParamFunction<string> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame } from '../domain/utils/canvas';\nimport { fromHexColor, toHexColor } from '../domain/utils/color';\nimport { mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { dropdownParam } from '../params/dropdownParam';\nimport { intParam } from '../params/intParam';\nimport { textParam } from '../params/textParam';\n\nconst FONTS = [\n  'Arial',\n  'Verdana',\n  'Tahoma',\n  'Trebuchet MS',\n  'Times New Roman',\n  'Georgia',\n  'Garamond',\n  'Courier New',\n  'Brush Script MT',\n];\n\nexport const text = buildEffect({\n  name: 'Text',\n  description: 'Puts text on the image',\n  params: [\n    textParam({\n      name: 'Text',\n      description: 'The text to put on the image',\n      defaultValue: '',\n    }),\n    dropdownParam({\n      name: 'Font',\n      defaultValue: FONTS[0],\n      options: FONTS.map((font) => ({ name: font, value: font })),\n    }),\n    intParam({\n      name: 'X',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Y',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Size',\n      defaultValue: 12,\n      min: 8,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ] as const,\n  fn: ({ image, parameters: [text, font, x, y, fontSize, color] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        postEffect: ({ ctx }) => {\n          ctx.font = `${fontSize}px ${font}`;\n          ctx.fillStyle = toHexColor(color);\n          ctx.fillText(text, x, y);\n        },\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, colorDiff } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparency = buildEffect({\n  name: 'Transparency',\n  description: 'Set certain pixels to be transparent',\n  params: [\n    checkboxParam({\n      name: 'Matches are Transparent',\n      description:\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\n      defaultValue: true,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      parameters: [matchesTransparent, selectedColor, tolerance],\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const withinTolerance = colorDiff(src, selectedColor) * 100 <= tolerance;\n\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\n        return [src[0], src[1], src[2], 0];\n      }\n      return src;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildEffect({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ] as const,\n  fn: mapImage(({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\n    getSrcPixel([x + transX, y + transY])\n  ),\n});\n","import { pipe, reject, sortBy } from 'remeda';\nimport { ParamFunction, Effect } from '../domain/types';\nimport { assert } from '../domain/utils/misc';\n\nimport { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { blur } from './blur';\nimport { bounce } from './bounce';\nimport { bounceAnimation } from './bounce-animation';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { expand } from './expand';\nimport { fill } from './fill';\nimport { fisheye } from './fisheye';\nimport { grid } from './grid';\nimport { hueChange } from './hue-change';\nimport { hueShift } from './hue-shift';\nimport { hueShiftPulse } from './hue-shift-pulse';\nimport { hueWave } from './hue-wave';\nimport { lightning } from './lightning';\nimport { mirror } from './mirror';\nimport { nuke } from './nuke';\nimport { opacity } from './opacity';\nimport { party } from './party';\nimport { partyBackground } from './party-background';\nimport { partyHarder } from './party-harder';\nimport { pinwheelColors } from './pinwheel-colors';\nimport { pinwheelRainbow } from './pinwheel-rainbow';\nimport { pinwheelRainbowBackground } from './pinwheel-rainbow-background';\nimport { radianceColors } from './radiance-colors';\nimport { radianceRainbow } from './radiance-rainbow';\nimport { radianceRainbowBackground } from './radiance-rainbow-background';\nimport { reduceColorPalette } from './reduce-color-palette';\nimport { repeatAnimation } from './repeat-animation';\nimport { resizeImage } from './resize-image';\nimport { reverseAnimation } from './reverse-animation';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { scaleImage } from './scale-image';\nimport { setAnimationLength } from './set-animation-length';\nimport { shake } from './shake';\nimport { slowAnimation } from './slow-animation';\nimport { spin } from './spin';\nimport { staticc } from './static';\nimport { text } from './text';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nconst otherEffects = pipe(\n  [\n    backgroundColor,\n    backgroundImage,\n    blur,\n    bounce,\n    bounceAnimation,\n    circle,\n    colors,\n    colorsBackground,\n    doubleVision,\n    expand,\n    fill,\n    fisheye,\n    grid,\n    hueChange,\n    hueShift,\n    hueShiftPulse,\n    hueWave,\n    lightning,\n    mirror,\n    nuke,\n    opacity,\n    party,\n    partyBackground,\n    partyHarder,\n    pinwheelColors,\n    pinwheelRainbow,\n    pinwheelRainbowBackground,\n    radianceColors,\n    radianceRainbow,\n    radianceRainbowBackground,\n    reduceColorPalette,\n    repeatAnimation,\n    resizeImage,\n    reverseAnimation,\n    ripple,\n    rotate,\n    roxbury,\n    scaleImage,\n    shake,\n    slowAnimation,\n    spin,\n    staticc,\n    text,\n    transparency,\n    transpose,\n  ],\n  sortBy((x) => x.name),\n  reject((x) => x.disabled)\n);\n\nexport const POSSIBLE_EFFECTS = [\n  // The first one is the one that is automatically selected, so make sure this is at the top of the list\n  setAnimationLength,\n  adjustImage,\n  ...otherEffects,\n];\n\nexport const effectByName = (\n  name: string\n): Effect<readonly ParamFunction<any>[]> => {\n  const t = POSSIBLE_EFFECTS.find((t) => t.name === name);\n  assert(t, `Could not find matching effect: ${name}`);\n  return t as any as Effect<readonly ParamFunction<any>[]>;\n};\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\nimport { effectByName } from '../effects';\nimport {\n  Color,\n  Image,\n  FrameData,\n  ImageEffectResult,\n  EffectInput,\n} from './types';\nimport {\n  fromHexColor,\n  isTransparent,\n  randomColor,\n  toHexColor,\n} from './utils/color';\nimport { getPixelFromSource } from './utils/image';\n\nexport interface RunArgs {\n  randomSeed: string;\n  image: Image;\n  effectInput: EffectInput;\n  fps: number;\n}\n\n// Returns a list of gif data URLs, for each effect\nexport const runEffects = async ({\n  image,\n  effectInput,\n  randomSeed,\n  fps,\n}: RunArgs): Promise<ImageEffectResult> => {\n  const random = seedrandom(randomSeed);\n\n  const effect = effectByName(effectInput.effectName);\n  const result = await effect.fn({\n    image,\n    parameters: effectInput.params,\n    random,\n  });\n\n  const transparentColor = getTransparentColor(result, random);\n\n  const gif = await createGif({\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    image: encodeTransparency(result, transparentColor),\n    transparentColor,\n    fps,\n  });\n\n  return {\n    gif,\n    image: result,\n  };\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  image: Image,\n  transparentColor: Color | undefined\n): Image => {\n  const newFrames = image.frames.map((frame) => {\n    const img = new Uint8ClampedArray(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = 0;\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 0; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return {\n    dimensions: image.dimensions,\n    frames: newFrames,\n  };\n};\n\nconst createGif = async ({\n  image,\n  transparentColor,\n  fps,\n}: {\n  image: Image;\n  transparentColor: Color | undefined;\n  fps: number;\n}): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = image.dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    image.frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: FrameData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          const [width, height] = results.shape;\n          // Single frame\n          return res({\n            frames: [Uint8ClampedArray.from(results.data)],\n            dimensions: [width, height],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8ClampedArray[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          const frame = results.data.subarray(\n            i * sliceSize,\n            (i + 1) * sliceSize\n          );\n          // Contrary to the TS types, the result of subarray returns a regular Uint8Array, NOT a clamped one!\n          frames.push(Uint8ClampedArray.from(frame));\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import React from 'react';\nimport { Dimensions } from '../domain/types';\n\nexport interface GifProps {\n  src: string;\n  alt: string;\n  dimensions?: Dimensions;\n}\n\n/**\n * Returns a size that will make the image at most 300px width or tall,\n *  while preserving the aspect ratio.\n */\nconst calculateDimensions = (dimensions: GifProps['dimensions']): any => {\n  if (dimensions == null) {\n    // TODO This happens in image picker, where we don't have a parsed image.\n    // We can probably parse the image in the image picker instead of just using a URL.\n    return { maxWidth: '300px', maxHeight: '300px' };\n  }\n\n  const [width, height] = dimensions;\n  const aspectRatio = height / width;\n  if (width > height) {\n    const maxWidth = 300;\n    const maxHeight = aspectRatio * 300;\n    // If width is bigger, then limit by width\n    return { maxWidth: `${maxWidth}px`, maxHeight: `${maxHeight}px` };\n  } else {\n    // Else, limit by height\n    const maxHeight = 300;\n    const maxWidth = (1 / aspectRatio) * 300;\n    return { maxHeight: `${maxHeight}px`, maxWidth: `${maxWidth}px` };\n  }\n};\n\nexport const Gif: React.FC<GifProps> = ({ src, alt, dimensions }) => (\n  <img\n    src={src}\n    alt={`gif-${alt}`}\n    style={calculateDimensions(dimensions)}\n  ></img>\n);\n","// DO NOT IMPORT THIS FILE FROM A WEB WORKER\n// Web workers do not have access to `window`\n\nimport MobileDetect from 'mobile-detect';\n\nexport const IS_MOBILE =\n  new MobileDetect(window.navigator.userAgent).mobile() != null;\n\nexport const ENV = (window as any).ENV as 'DEV' | 'PROD';\n\nexport const debugLog = ENV === 'DEV' ? console.log : () => undefined;\n","import React from 'react';\nimport { debugLog } from '../domain/env';\n\nconst getRunId = () => Math.floor(Math.random() * 100000);\n\n/**\n * Computes an asynchronous, calling the given callback when finished.\n *\n * If a compute is called while an existing one is in progress, then the\n *  result for the previous compute will be thrown away. The callback will\n *  only be called a single time. Think of it like a debounce.\n */\nexport function useProcessingQueue<T, R>({\n  fn,\n  onComplete,\n  onError,\n}: {\n  fn: (args: T) => Promise<R>;\n  onComplete: (results: R) => void;\n  onError?: (error: Error) => void;\n}) {\n  const latestRunId = React.useRef<number>(0);\n\n  const onFinish = (runId: number) => (results: R) => {\n    debugLog('Finished', { runId, latestRunId: latestRunId.current });\n    if (runId === latestRunId.current) {\n      onComplete(results);\n    } else {\n      // Throw away this result -- it's been superceded by another compute\n      debugLog('Throwing away an old compute');\n    }\n  };\n\n  return React.useCallback((args: T): void => {\n    const runId = getRunId();\n    debugLog('Computing: ', { runId, args });\n    latestRunId.current = runId;\n    fn(args).then(onFinish(runId)).catch(onError);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // TODO use React memo everywhere so we can do this properly?\n}\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/effect.worker.ea8b76de.worker.js\");\n}\n","import { RunArgs } from './run';\n// @ts-ignore\nimport RunEffectWorker from './effect.worker';\nimport { AsyncRunMessage, ImageEffectResult } from './types';\n\ninterface Computation {\n  resolve: (result: ImageEffectResult) => void;\n  reject: (err: any) => void;\n}\n\n// The order of computations is not guaranteed, so add each computation to a map\nconst computationMap = new Map<string, Computation>();\n\nconst handleError = (computationId: string) => (error: any) => {\n  const computation = computationMap.get(computationId);\n  if (!computation) {\n    return;\n  }\n  computation.reject(error);\n  computationMap.delete(computationId);\n};\n\nconst handleSuccess = (computationId: string, result: ImageEffectResult) => {\n  const computation = computationMap.get(computationId);\n  if (!computation) {\n    return;\n  }\n  computation.resolve(result);\n  computationMap.delete(computationId);\n};\n\nexport const runEffectsAsync = (args: RunArgs) =>\n  new Promise<ImageEffectResult>((resolve, reject) => {\n    const worker = new RunEffectWorker();\n\n    const computationId = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;\n    computationMap.set(computationId, {\n      resolve,\n      reject,\n    });\n\n    worker.addEventListener('error', handleError(computationId));\n    worker.addEventListener('messageerror', handleError(computationId));\n\n    worker.onmessage = (message: { data: AsyncRunMessage }) => {\n      // See effect.worker.ts for what messages look like\n      const data = message.data;\n      if (data.status === 'complete') {\n        handleSuccess(computationId, data.result);\n      }\n    };\n\n    worker.postMessage(args);\n  });\n","import { readImage, runEffects } from './run';\nimport { runEffectsAsync } from './runAsync';\nimport { AppState, Image, ImageEffectResult } from './types';\nimport { ENV, debugLog, IS_MOBILE } from './env';\nimport { assert } from './utils/misc';\n\n// OffscreenCanvas isn't supported by mobile browsers, so mobile will also run synchronously,\n//  which will force us to use regular canvas and not OffscreenCanvas.\n// Also, we can't get web workers working with the dev build, so awalsy use the synchrounous\n//  version if not a prod build.\nexport const computeGif =\n  IS_MOBILE || ENV === 'DEV' ? runEffects : runEffectsAsync;\n\nexport const computeGifsForState = async ({\n  state,\n  startEffectIndex,\n  onCompute,\n}: {\n  state: AppState;\n  startEffectIndex: number;\n  onCompute: (image: ImageEffectResult, idx: number) => void;\n}): Promise<void> => {\n  assert(state.baseImage, 'No source image, this button should be disabled!');\n\n  let image: Image;\n  if (startEffectIndex === 0) {\n    image = await readImage(state.baseImage);\n  } else {\n    const prevEffectState = state.effects[startEffectIndex - 1].state;\n    assert(\n      prevEffectState.status === 'done',\n      'We should not be starting with this effect if the previous is not done computing'\n    );\n    image = prevEffectState.image.image;\n  }\n\n  for (let i = startEffectIndex; i < state.effects.length; i += 1) {\n    const start = Date.now();\n\n    const effect = state.effects[i];\n\n    const result = await computeGif({\n      randomSeed: state.baseImage!,\n      image,\n      effectInput: {\n        effectName: effect.effectName,\n        params: effect.paramsValues,\n      },\n      fps: state.fps,\n    });\n\n    // Google analytics\n    ga('send', {\n      hitType: 'timing',\n      timingCategory: 'computeStep',\n      timingVar: effect.effectName,\n      timingValue: Math.ceil((Date.now() - start) / 1000),\n    });\n\n    image = result.image;\n\n    onCompute(result, i);\n  }\n};\n\n/** Get the index of the first effect that differs from curr to prev state */\nexport const getEffectsDiff = ({\n  currState,\n  prevState,\n}: {\n  currState: AppState;\n  prevState: AppState;\n}): { diff: true; index: number } | { diff: false } => {\n  if (\n    currState.fps !== prevState.fps ||\n    currState.baseImage !== prevState.baseImage\n  ) {\n    debugLog('FPS or base image is different');\n    return { diff: true, index: 0 };\n  }\n\n  const currEffects = currState.effects;\n  const prevEffects = prevState.effects;\n\n  // Find the first newEffect that is different from prevEffects\n  for (let i = 0; i < currEffects.length; i += 1) {\n    const currE = currEffects[i];\n    const prevE = prevEffects[i];\n    if (!prevE) {\n      debugLog('No prevE, index ', i);\n      return { diff: true, index: i };\n    }\n\n    if (prevE.state.status !== 'done') {\n      debugLog('PrevE not done ', i);\n      return { diff: true, index: i };\n    }\n\n    if (currE.effectName !== prevE.effectName) {\n      debugLog('Different effect name ', i);\n      return { diff: true, index: i };\n    }\n\n    // Compare the param values\n    for (let ei = 0; ei < currE.paramsValues.length; ei += 1) {\n      const currEParam = currE.paramsValues[ei];\n      const prevEP = prevE.paramsValues[ei];\n      if (JSON.stringify(currEParam) !== JSON.stringify(prevEP)) {\n        debugLog('Param different', i, ei);\n        return { diff: true, index: i };\n      }\n    }\n  }\n\n  debugLog('No diff');\n  return { diff: false };\n};\n","import React from 'react';\nimport {\n  Autocomplete,\n  Button,\n  CircularProgress,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  Divider,\n  FormControl,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport {\n  ParamFunction,\n  Effect,\n  EffectInput,\n  ImageEffectResult,\n} from '../domain/types';\nimport { replaceIndex } from '../domain/utils/misc';\nimport { debugLog } from '../domain/env';\nimport { effectByName } from '../effects';\nimport { Gif } from './Gif';\nimport { useProcessingQueue } from './useProcessingQueue';\nimport { computeGif } from '../domain/computeGifs';\n\ninterface ImageEffectProps {\n  open: boolean;\n  initialImage: ImageEffectResult | undefined;\n  currentEffect: EffectInput;\n  possibleEffects: Effect<any>[];\n  currFps: number;\n  currRandomSeed: string;\n  onChangeEffect: (\n    effect: EffectInput,\n    computedImage: ImageEffectResult | undefined\n  ) => void;\n  onCancel: () => void;\n}\n\nexport const ImageEffectDialog: React.FC<ImageEffectProps> = ({\n  open,\n  initialImage,\n  currentEffect,\n  possibleEffects,\n  currFps,\n  currRandomSeed,\n  onChangeEffect,\n  onCancel,\n}) => {\n  const [image, setImage] = React.useState<\n    { computing: true } | { computing: false; results: ImageEffectResult }\n  >({ computing: true });\n\n  const onImageChange = useProcessingQueue({\n    fn: computeGif,\n    onComplete: (results) => setImage({ computing: false, results }),\n  });\n\n  const [initialLoaded, setInitialLoaded] = React.useState(false);\n\n  const [editingEffect, setEditingEffect] = React.useState<EffectInput>({\n    // Make a copy of the effect being passed in\n    effectName: currentEffect.effectName,\n    params: [...currentEffect.params],\n  });\n  const [dirty, setDirty] = React.useState(false);\n\n  React.useEffect(() => {\n    // Reset state to default values on close\n    if (!open) {\n      setInitialLoaded(false);\n      setEditingEffect({\n        // Make a copy of the effect being passed in\n        effectName: currentEffect.effectName,\n        params: [...currentEffect.params],\n      });\n      setImage({ computing: true });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [open]);\n\n  React.useEffect(() => {\n    // Set initial loaded image once we have it\n    if (!initialImage) {\n      return;\n    }\n\n    if (!initialLoaded) {\n      debugLog('Initial loading');\n      // The initial loading of the original effect\n      setImage({\n        computing: false,\n        results: initialImage,\n      });\n      setInitialLoaded(true);\n      return;\n    }\n\n    // Just used for setting the initial image, so just change it when the initial image does.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialImage]);\n\n  React.useEffect(() => {\n    if (!initialImage) {\n      return;\n    }\n\n    setImage({ computing: true });\n    onImageChange({\n      fps: currFps,\n      randomSeed: currRandomSeed,\n      image: initialImage.image,\n      effectInput: editingEffect,\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialImage, editingEffect, currFps, currRandomSeed]);\n\n  const closeDialog = ({ save }: { save: boolean }) => {\n    if (!save) {\n      onCancel();\n      return;\n    }\n\n    onChangeEffect(editingEffect, image.computing ? undefined : image.results);\n    setDirty(false);\n  };\n\n  const effect = effectByName(editingEffect.effectName);\n\n  return (\n    <Dialog fullWidth maxWidth=\"sm\" open={open}>\n      <DialogTitle>\n        <Stack direction=\"row\" spacing={4} marginTop={2}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={editingEffect.effectName}\n              options={possibleEffects.map((t) => t.name)}\n              onChange={(event, newEffectName) => {\n                const t = effectByName(newEffectName)!;\n                // Reset all the params when you select a new effect\n                setEditingEffect({\n                  effectName: t.name,\n                  params: t.params.map((p) =>\n                    p.defaultValue(initialImage?.image ?? undefined)\n                  ),\n                });\n                setDirty(true);\n              }}\n              renderOption={(props, option) => (\n                <li {...props}>\n                  <Stack marginLeft={2} marginRight={2}>\n                    <Typography variant=\"body1\">{option}</Typography>\n                    <Typography variant=\"caption\" marginLeft={2}>\n                      {effectByName(option).description}\n                    </Typography>\n                  </Stack>\n                </li>\n              )}\n              renderInput={(params) => <TextField {...params} label=\"Effect\" />}\n            />\n          </FormControl>\n        </Stack>\n      </DialogTitle>\n      <DialogContent>\n        <Stack divider={<Divider />} spacing={2}>\n          <Typography variant=\"body2\">\n            {effect.description}\n            <div>\n              {effect.secondaryDescription && (\n                <Typography variant=\"caption\" marginLeft={2}>\n                  {effect.secondaryDescription}\n                </Typography>\n              )}\n            </div>\n          </Typography>\n\n          {effect.params.map(\n            // Create elements for each of the parameters for the selectect effect.\n            // Each of these would get an onChange event so we know when the user has\n            //  selected a value.\n            (param: ParamFunction<any>, idx: number) => {\n              const ele = param.fn({\n                value: editingEffect.params[idx],\n                onChange: (v) => {\n                  setDirty(true);\n                  setEditingEffect({\n                    ...editingEffect,\n                    params: replaceIndex(editingEffect.params, idx, () => v),\n                  });\n                },\n              });\n              return (\n                <React.Fragment\n                  key={`${editingEffect.effectName}-${param.name}`}\n                >\n                  {ele}\n                </React.Fragment>\n              );\n            }\n          )}\n          <Stack sx={{ height: 300 }}>\n            {image.computing ? (\n              <CircularProgress size={100} />\n            ) : (\n              <Gif\n                src={image.results.gif}\n                alt={`effect-${editingEffect.effectName}`}\n                dimensions={image.results.image.dimensions}\n              />\n            )}\n          </Stack>\n        </Stack>\n      </DialogContent>\n      <DialogActions>\n        <Button\n          variant=\"outlined\"\n          autoFocus\n          onClick={() => {\n            closeDialog({ save: false });\n          }}\n        >\n          Cancel\n        </Button>\n        <Button\n          variant=\"contained\"\n          autoFocus\n          disabled={!dirty}\n          onClick={() => {\n            closeDialog({ save: true });\n          }}\n        >\n          Save and Close\n        </Button>\n      </DialogActions>\n    </Dialog>\n  );\n};\n","import {\n  Button,\n  CircularProgress,\n  Divider,\n  Icon,\n  IconButton,\n  Stack,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { readImage } from '../domain/run';\nimport {\n  ParamFunction,\n  Effect,\n  AppStateEffect,\n  Image,\n  AppState,\n  ImageEffectResult,\n} from '../domain/types';\nimport { replaceIndex } from '../domain/utils/misc';\nimport { Gif } from './Gif';\nimport { ImageEffectDialog } from './ImageEffectDialog';\n\ninterface EffectListProps {\n  appState: AppState;\n  possibleEffects: Effect<any>[];\n  onEffectsChange: (t: AppStateEffect[]) => void;\n}\n\nconst effectKey = (t: AppStateEffect, idx: number): string =>\n  `${t.effectName}-${idx}-${\n    t.state.status === 'done' ? t.state.image.gif.substring(0, 10) : 'pending'\n  }`;\n\nexport const ImageEffectList: React.FC<EffectListProps> = ({\n  appState,\n  possibleEffects,\n  onEffectsChange,\n}) => {\n  const currentEffects = appState.effects;\n  const [effectDialogOpen, setEffectDialogOpen] = React.useState<\n    { open: false } | { open: true; idx: number; isNew: boolean }\n  >({ open: false });\n\n  const onDelete = (idx: number) => () =>\n    onEffectsChange(currentEffects.filter((nextT, newIdx) => newIdx !== idx));\n\n  const [baseImage, setBaseImage] = React.useState<\n    ImageEffectResult | undefined\n  >();\n  React.useEffect(() => {\n    if (!appState.baseImage || baseImage?.gif === appState.baseImage) {\n      return;\n    }\n\n    const gif = appState.baseImage;\n    readImage(gif).then((image) =>\n      setBaseImage({\n        gif,\n        image,\n      })\n    );\n  }, [appState, baseImage]);\n\n  const getInitialImage = React.useCallback(\n    (idx: number): ImageEffectResult | undefined => {\n      const prevEffect = currentEffects[idx - 1];\n      if (prevEffect) {\n        return prevEffect.state.status === 'done'\n          ? prevEffect.state.image\n          : undefined;\n      }\n\n      return baseImage;\n    },\n    [baseImage, currentEffects]\n  );\n\n  const onMoveUp = (idx: number) =>\n    idx > 0\n      ? () =>\n          onEffectsChange(\n            currentEffects.map((nextT, newIdx) => {\n              if (newIdx === idx - 1) {\n                // This is the next item in the list\n                return currentEffects[newIdx + 1];\n              } else if (idx === newIdx) {\n                // This is the previous item\n                return currentEffects[idx - 1];\n              } else {\n                return nextT;\n              }\n            })\n          )\n      : undefined;\n\n  const onMoveDown = (idx: number) =>\n    idx < currentEffects.length - 1\n      ? () =>\n          onEffectsChange(\n            currentEffects.map((nextT, newIdx) => {\n              if (newIdx === idx + 1) {\n                // This is the previous item in the list\n                return currentEffects[newIdx - 1];\n              } else if (idx === newIdx) {\n                // This is the next item\n                return currentEffects[idx + 1];\n              } else {\n                return nextT;\n              }\n            })\n          )\n      : undefined;\n\n  return (\n    <Stack spacing={4} alignItems=\"center\">\n      <Typography variant=\"h5\">Image Effects</Typography>\n      {currentEffects.flatMap((t, tIdx) => [\n        <>\n          <Button\n            variant=\"contained\"\n            startIcon={<Icon>add</Icon>}\n            size=\"large\"\n            onClick={() => {\n              onEffectsChange([\n                {\n                  effectName: possibleEffects[0].name,\n                  paramsValues: possibleEffects[0].params.map(\n                    (p: ParamFunction<any>) => {\n                      let image: Image | undefined = undefined;\n                      if (tIdx === 0) {\n                        image = baseImage?.image;\n                      } else {\n                        const previousEffect = currentEffects[tIdx - 1];\n                        if (previousEffect.state.status === 'done') {\n                          image = previousEffect.state.image.image;\n                        }\n                      }\n\n                      return p.defaultValue(image);\n                    }\n                  ),\n                  state: { status: 'init' },\n                },\n                ...currentEffects,\n              ]);\n              setEffectDialogOpen({\n                open: true,\n                idx: tIdx,\n                isNew: true,\n              });\n            }}\n          >\n            Insert New Effect\n          </Button>\n          <FxDivider key={`divider-top-${effectKey(t, tIdx)}`} />\n          <Stack direction=\"row\" key={effectKey(t, tIdx)} spacing={4}>\n            <Stack border=\"black\">\n              <Stack>\n                <Typography\n                  variant=\"subtitle1\"\n                  fontWeight=\"bold\"\n                  marginLeft={2}\n                  marginBottom={1}\n                >\n                  Effect: {t.effectName}\n                </Typography>\n                <Stack direction=\"row\" spacing={2}>\n                  <Tooltip title=\"Remove effect\">\n                    <IconButton aria-label=\"delete\" onClick={onDelete(tIdx)}>\n                      <Icon>delete</Icon>\n                    </IconButton>\n                  </Tooltip>\n                  <Tooltip title=\"Move effect earlier\">\n                    <IconButton\n                      aria-label=\"move-before\"\n                      onClick={onMoveUp(tIdx)}\n                      disabled={tIdx === 0}\n                    >\n                      <Icon>arrow_upward</Icon>\n                    </IconButton>\n                  </Tooltip>\n                  <Tooltip title=\"Move effect later\">\n                    <IconButton\n                      aria-label=\"move-after\"\n                      onClick={onMoveDown(tIdx)}\n                      disabled={tIdx === currentEffects.length - 1}\n                    >\n                      <Icon>arrow_downward</Icon>\n                    </IconButton>\n                  </Tooltip>\n                </Stack>\n              </Stack>\n              {t.state.status === 'done' && (\n                <Stack sx={{ width: 250 }}>\n                  <Gif\n                    src={t.state.image.gif}\n                    alt={`${t.effectName}-${tIdx}`}\n                    dimensions={t.state.image.image.dimensions}\n                  />\n                </Stack>\n              )}\n              {t.state.status === 'computing' && (\n                <CircularProgress size={100} />\n              )}\n              <Stack spacing={1} marginTop={1}>\n                <Button\n                  variant=\"contained\"\n                  startIcon={<Icon>edit</Icon>}\n                  onClick={() =>\n                    setEffectDialogOpen({ open: true, idx: tIdx, isNew: false })\n                  }\n                >\n                  Edit: \"{t.effectName}\"\n                </Button>\n              </Stack>\n              <ImageEffectDialog\n                open={effectDialogOpen.open && effectDialogOpen.idx === tIdx}\n                possibleEffects={possibleEffects}\n                onChangeEffect={(newEffect, computedImage) => {\n                  onEffectsChange(\n                    replaceIndex(currentEffects, tIdx, () => ({\n                      effectName: newEffect.effectName,\n                      paramsValues: newEffect.params,\n                      state: computedImage\n                        ? { status: 'done', image: computedImage }\n                        : { status: 'init' },\n                    }))\n                  );\n                  setEffectDialogOpen({ open: false });\n                }}\n                onCancel={() => {\n                  // Assumed to be open at this point\n                  if (effectDialogOpen.open && effectDialogOpen.isNew) {\n                    // They pressed cancel on a new effect, so just remove this one.\n                    // (It's assumed to be the last effect in the chain\n                    onEffectsChange(\n                      currentEffects.slice(0, currentEffects.length - 1)\n                    );\n                  }\n\n                  setEffectDialogOpen({ open: false });\n                }}\n                initialImage={getInitialImage(tIdx)}\n                currentEffect={{\n                  effectName: t.effectName,\n                  params: t.paramsValues,\n                }}\n                currFps={appState.fps}\n                currRandomSeed=\"partymoji\"\n              />\n            </Stack>\n          </Stack>\n          <FxDivider key={`divider-bottom-${effectKey(t, tIdx)}`} />\n        </>,\n      ])}\n      <Button\n        variant=\"contained\"\n        startIcon={<Icon>add</Icon>}\n        size=\"large\"\n        onClick={() => {\n          onEffectsChange([\n            ...currentEffects,\n            {\n              effectName: possibleEffects[0].name,\n              paramsValues: possibleEffects[0].params.map(\n                (p: ParamFunction<any>) => {\n                  let image: Image | undefined = undefined;\n                  if (currentEffects.length === 0) {\n                    image = baseImage?.image;\n                  } else {\n                    const lastEffect =\n                      currentEffects[currentEffects.length - 1];\n                    if (lastEffect.state.status === 'done') {\n                      image = lastEffect.state.image.image;\n                    }\n                  }\n\n                  return p.defaultValue(image);\n                }\n              ),\n              state: { status: 'init' },\n            },\n          ]);\n          setEffectDialogOpen({\n            open: true,\n            idx: currentEffects.length,\n            isNew: true,\n          });\n        }}\n      >\n        Append New Effect\n      </Button>\n    </Stack>\n  );\n};\n\nconst FxDivider: React.FC = () => (\n  <Divider variant=\"middle\" sx={{ width: 300 }} />\n);\n","import { AppState, AppStateEffect } from './domain/types';\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nexport const getStoredAppState = (): AppState | undefined => {\n  try {\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (stored) {\n      const savedState = JSON.parse(stored);\n      if (Array.isArray(savedState.effects)) {\n        return savedState;\n      }\n    }\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error loading state from local storage', err.stack || err);\n  }\n\n  return undefined;\n};\n\nexport const saveAppState = (state: AppState) => {\n  try {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, serializeAppState(state));\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error saving state to local storage', err.stack || err);\n  }\n};\n\nexport const clearAppState = () => {\n  try {\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error clearing state from local storage', err.stack || err);\n  }\n};\n\nconst serializeAppState = (state: AppState): string => {\n  const toStore: AppState = {\n    ...state,\n    effects: state.effects.map(\n      (t): AppStateEffect => ({\n        ...t,\n        // Remove the computed image for the state before storing.\n        // This just bloats the storage and doesn't keep anything that isn't reproduceable.\n        state: { status: 'init' },\n      })\n    ),\n  };\n  return JSON.stringify(toStore);\n};\n","import React from 'react';\nimport { Alert, AlertColor, Snackbar } from '@material-ui/core';\n\nexport type AlertValue = { message: string; severity: AlertColor } | null;\n\ninterface AlertContext {\n  alert: AlertValue;\n  setAlert: (alert: AlertValue) => void;\n}\n\nexport const alertContext = React.createContext<AlertContext>({\n  alert: null,\n  setAlert: () => {\n    throw new Error('Context not initialized');\n  },\n});\n\nexport const AlertProvider: React.FC = ({ children }) => {\n  const [alertValue, setAlertValue] = React.useState<AlertValue>(null);\n\n  return (\n    <alertContext.Provider\n      value={{ alert: alertValue, setAlert: setAlertValue }}\n    >\n      {children}\n    </alertContext.Provider>\n  );\n};\n\nexport const AlertSnackbar: React.FC = () => {\n  const { alert, setAlert } = React.useContext(alertContext);\n  return (\n    <Snackbar open={alert != null}>\n      {alert == null ? undefined : (\n        <Alert severity={alert.severity} onClose={() => setAlert(null)}>\n          {alert.message}\n        </Alert>\n      )}\n    </Snackbar>\n  );\n};\n\nexport const useSetAlert = () => {\n  const { setAlert } = React.useContext(alertContext);\n  return setAlert;\n};\n","import React from 'react';\nimport {\n  Button,\n  Container,\n  Divider,\n  Icon,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\n\nimport { Help } from './components/Help';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageEffectList } from './components/ImageEffectList';\nimport { computeGifsForState, getEffectsDiff } from './domain/computeGifs';\nimport { AppState, AppStateEffect } from './domain/types';\nimport { replaceIndex } from './domain/utils/misc';\nimport { ENV, debugLog, IS_MOBILE } from './domain/env';\nimport * as localStorage from './localStorage';\nimport { sliderParam } from './params/sliderParam';\nimport { POSSIBLE_EFFECTS } from './effects';\nimport { AlertProvider, AlertSnackbar, useSetAlert } from './AlertContext';\n\n// Number of millis to wait after a change before recomputing the gif\nconst COMPUTE_DEBOUNCE_MILLIS = 1000;\n\n// Increase this by 1 when there's a breaking change to the app state.\n// Don't change this unless we have to!\nconst CURRENT_APP_STATE_VERSION = 5;\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Final Gif Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nconst DEFAULT_STATE: AppState = {\n  version: CURRENT_APP_STATE_VERSION,\n  effects: [],\n  baseImage: undefined,\n  fps: DEFAULT_FPS,\n};\n\nconst Inner: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n  const [doCompute, setDoCompute] = React.useState<\n    { compute: true; startIndex: number } | { compute: false }\n  >({ compute: false });\n  const [computeTimer, setComputeTimer] = React.useState<null | NodeJS.Timeout>(\n    null\n  );\n\n  const setAlert = useSetAlert();\n\n  React.useEffect(() => {\n    if (IS_MOBILE) {\n      setAlert({\n        severity: 'warning',\n        message:\n          'This app is not well optimized for mobile. Your experience may not be great.',\n      });\n    }\n  }, [setAlert]);\n\n  React.useEffect(() => {\n    // If we have local storage state on startup, then reload that\n    const stored = localStorage.getStoredAppState();\n    if (stored) {\n      if (stored.version === CURRENT_APP_STATE_VERSION) {\n        setStateRaw(stored);\n        setDoCompute({ compute: true, startIndex: 0 });\n      } else {\n        // TODO Might be nice to tell the user we erased their previous stuff\n        localStorage.clearAppState();\n      }\n    }\n  }, []);\n\n  const setState = React.useCallback(\n    (\n      fn: (oldState: AppState) => AppState,\n      { compute }: { compute: 'no' | 'now' | 'later' }\n    ) => {\n      setStateRaw((oldState) => {\n        const newState = fn(oldState);\n        localStorage.saveAppState(newState);\n\n        if (ENV === 'DEV') {\n          (window as any).STATE = newState;\n        }\n\n        if (compute !== 'no' && newState.baseImage != null) {\n          // Compute the gif some time from now.\n          // Other changes within this time should push the compute time back\n          if (computeTimer) {\n            clearTimeout(computeTimer);\n            setComputeTimer(null);\n          }\n\n          const effectsDiff = getEffectsDiff({\n            prevState: oldState,\n            currState: newState,\n          });\n\n          if (effectsDiff.diff) {\n            if (compute === 'now') {\n              setDoCompute({ compute: true, startIndex: effectsDiff.index });\n            } else {\n              setDoCompute({ compute: false });\n              setComputeTimer(\n                setTimeout(() => {\n                  setComputeTimer(null);\n                  setDoCompute({\n                    compute: true,\n                    startIndex: effectsDiff.index,\n                  });\n                }, COMPUTE_DEBOUNCE_MILLIS)\n              );\n            }\n          }\n        }\n\n        return newState;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  React.useEffect(() => {\n    debugLog('UseEffect, doCompute', doCompute);\n    if (doCompute.compute === false) {\n      return;\n    }\n\n    // TODO What happens if new changes come in while we're already computing?\n    // Need to throw away previous results and calculate new ones.\n    setDoCompute({ compute: false });\n    (async () => {\n      setState(\n        (prevState) => ({\n          ...prevState,\n          effects: prevState.effects.map((t, i): AppStateEffect => {\n            if (i < doCompute.startIndex) {\n              return t;\n            } else {\n              return {\n                ...t,\n                state: { status: 'computing' },\n              };\n            }\n          }),\n        }),\n        { compute: 'no' }\n      );\n      // TODO error handling\n      await computeGifsForState({\n        state,\n        onCompute: (image, computeIdx) => {\n          setState(\n            (prevState) => ({\n              ...prevState,\n              effects: replaceIndex(\n                prevState.effects,\n                computeIdx,\n                (t): AppStateEffect => ({\n                  ...t,\n                  state: { status: 'done', image },\n                })\n              ),\n            }),\n            { compute: 'no' }\n          );\n        },\n        startEffectIndex: doCompute.startIndex,\n      });\n    })();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [doCompute]);\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container maxWidth=\"sm\">\n        <Stack\n          spacing={4}\n          justifyContent=\"space-evenly\"\n          alignItems=\"center\"\n          width=\"sm\"\n          divider={<Divider />}\n        >\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />} alignItems=\"center\">\n            <Section>\n              <Help />\n            </Section>\n            <Section>\n              <Stack spacing={1} alignItems=\"center\">\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Upload a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState(\n                      (prevState) => ({\n                        ...prevState,\n                        baseImage,\n                      }),\n                      { compute: 'now' }\n                    );\n                  }}\n                />\n                <div style={{ maxWidth: '300px' }}>\n                  {fpsParam.fn({\n                    value: state.fps,\n                    onChange: (fps) =>\n                      setState(\n                        (prevState) => ({\n                          ...prevState,\n                          fps,\n                        }),\n                        { compute: 'later' }\n                      ),\n                  })}\n                </div>\n              </Stack>\n            </Section>\n            <Section>\n              <ImageEffectList\n                appState={state}\n                possibleEffects={POSSIBLE_EFFECTS}\n                onEffectsChange={(effects) =>\n                  setState(\n                    (prevState) => ({\n                      ...prevState,\n                      effects,\n                    }),\n                    { compute: 'now' }\n                  )\n                }\n              />\n            </Section>\n            {/* <Section>\n            // Disabling this for now as I think it's confusing the way it is.\n              <ImportExportComponent\n                state={state}\n                onImport={(o) => setState(() => o, { compute: 'now' })}\n              />\n            </Section> */}\n            <Section>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear Effects</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear all effects for the image\n                </Typography>\n                <Button\n                  startIcon={<Icon>clear</Icon>}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  color=\"warning\"\n                  onClick={() => {\n                    const newState: AppState = {\n                      ...DEFAULT_STATE,\n                      baseImage: state.baseImage,\n                    };\n                    setStateRaw(newState);\n                    localStorage.saveAppState(newState);\n                  }}\n                >\n                  Clear Effects\n                </Button>\n              </Stack>\n            </Section>\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n\n      <AlertSnackbar />\n    </>\n  );\n};\n\nconst Section: React.FC = ({ children }) => (\n  <Paper style={{ padding: 16 }} sx={{ width: 300 }}>\n    {children}\n  </Paper>\n);\n\n// Icons at https://fonts.google.com/icons?selected=Material+Icons\n\nexport const App: React.FC = () => {\n  return (\n    <AlertProvider>\n      <Inner />\n    </AlertProvider>\n  );\n};\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import { createTheme, ThemeProvider } from '@material-ui/core';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\nimport * as localStorage from './localStorage';\n\nconst theme = createTheme({\n  typography: {\n    fontFamily: 'Raleway, Arial',\n  },\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <TopLevelErrorBoundary\n        onClearLocalStorage={() => {\n          localStorage.clearAppState();\n          window.location.reload();\n        }}\n      >\n        <App />\n      </TopLevelErrorBoundary>\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}