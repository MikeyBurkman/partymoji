{"version":3,"sources":["domain/types.ts","domain/utils.ts","transforms/background-party.ts","params/dropdownParam.tsx","domain/run.ts","components/ImagePicker.tsx","transforms/background-image.ts","params/imagePickerParam.tsx","params/intParam.tsx","transforms/bounce.ts","params/sliderParam.tsx","transforms/brightness.ts","transforms/circle.ts","transforms/expand.ts","transforms/fisheye.ts","transforms/frame-count.ts","transforms/grayscale.ts","transforms/hue-party.ts","params/huePickerParam.tsx","transforms/hue-shift.ts","params/textParam.tsx","transforms/lightning.ts","transforms/nuke.ts","transforms/party.ts","components/Expandable.tsx","params/colorPickerParam.tsx","params/variableLengthParam.tsx","transforms/pinwheel.ts","transforms/radiance.ts","transforms/resize-image.ts","params/floatParam.tsx","transforms/index.ts","transforms/ripple.ts","transforms/rotate.ts","transforms/roxbury.ts","transforms/scale-image.ts","transforms/shake.ts","transforms/solid-background.ts","transforms/static.ts","transforms/static-background.ts","transforms/transparent-color.ts","transforms/transpose.ts","components/ComputeBox.tsx","components/ImageTransform.tsx","components/ImageTransformList.tsx","components/ImportExport.tsx","App.tsx","index.tsx"],"names":["buildTransform","args","name","params","description","fn","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","getAveragePixelValue","round","clampColor","a","clamp","n","max","min","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","map","frame","data","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","getSrcPixel","repeat","times","Array","_","i","writePixel","color","resizeImage","newWidth","newHeight","xRatio","yRatio","newDimensions","srcX","srcY","PARTY_COLORS","backgroundParty","srcPixel","partyColorIdx","DropdownParam","options","value","onChange","Stack","spacing","direction","Typography","variant","Tooltip","title","Icon","fontSize","FormControl","Select","autoWidth","event","valid","target","t","MenuItem","dropdownParam","defaultValue","undefined","runTransforms","inputDataUrl","transformList","fps","seedrandom","readImage","originalImage","images","reduce","transformInput","result","transform","push","Promise","all","newImage","transparentColor","getTransparentColor","encodeTransparency","f","createGif","img","resolve","gif","gifEncoder","setFrameRate","setRepeat","hexColor","slice","setTransparent","writeHeader","on","chunk","dataUrl","URL","createObjectURL","Blob","type","forEach","addFrame","finish","res","rej","getPixels","err","getPixelResults","from","shape","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","ImagePicker","currentImageUrl","Button","startIcon","sx","maxWidth","component","hidden","accept","files","file","readFile","baseImage","src","alt","reader","FileReader","onload","readAsDataURL","backgroundImage","imagePickerParam","otherImage","otherImageSrc","IntParam","parse","React","useState","val","setVal","invalidText","setInvalidText","TextField","error","onBlur","reason","e","FormHelperText","intParam","isNaN","bounce","sin","PI","SliderParam","step","Slider","aria-label","valueLabelDisplay","getAriaValueText","sliderParam","brightness","rawAmount","p","circle","radius","cos","expand","dist","centerX","centerY","fisheye","expanding","angle","atan2","currentFrames","grayscale","gray","hueParty","convert","hsl","l","rgb","HuePickerParam","onChangeComplete","h","hueShift","newHue","TextParam","lightningIntensities","lightning","textParam","flashIntensity","icf","nuke","threshold","party","partyColor","Expandable","mainEle","children","collapsed","setCollapsed","ClickAwayListener","onClickAway","Box","onClick","style","textTransform","Collapse","in","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","colorPickerParam","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","oldP","IconButton","newParams","filter","variableLengthParam","DEFAULT_COLORS","pinwheel","offsetX","offsetY","groupCount","colors","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","xRelCenter","yRelCenter","pointAngle","colorIdx","frameProgress","radiance","colorList","flatMap","maxDist","sqrt","distFromCenter","xPadding","yPadding","FloatParam","floatParam","parseFloat","POSSIBLE_TRANSFORMS","amplitude","period","shift","offset","sign","amount","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","newCoord","strength","isStatic","ceil","grey","inverse","tolerance","diff0","diff1","diff2","transX","transY","sort","transformByName","find","fpsParam","ComputeBox","isDirty","computeDisabled","baseImageUrl","transforms","onComputed","loading","results","computeTime","state","setState","fpsChanged","setFpsChanged","setFps","buttonDisabled","endIcon","disabled","transformInputs","transformName","paramsValues","setTimeout","start","Date","now","gifs","console","stack","CircularProgress","Divider","Grid","container","padding","columns","xs","sm","md","item","ImageTransform","selectedTransform","possibleTransforms","index","onSelect","onRemove","onMoveLeft","onMoveRight","elevation","fullWidth","Autocomplete","disableClearable","newTransformName","paramValues","renderInput","label","divider","Fragment","ImageTransformList","currentTransforms","onTransformsChange","tIdx","nextT","newIdx","selected","nextTIdx","computedImage","ImportExport","onImport","info","setInfo","isInvalid","setInvalid","showInfo","text","showError","output","lz","JSON","stringify","navigator","clipboard","writeText","readText","clipboardContents","isArray","Alert","severity","App","dirty","computeBtnDisbled","some","every","ScopedCssBaseline","Container","justifyContent","pt","newState","href","rel","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"ySA0GaA,EAAiB,SAA0CC,GAA1C,MAKT,CACnBC,KAAMD,EAAKC,KACXC,OAAQF,EAAKE,OACbC,YAAaH,EAAKG,YAClBC,GAAIJ,EAAKI,K,iBClGEC,EAAa,SAAC,GAAsB,IAAD,mBAApBC,EAAoB,KAAjBC,EAAiB,KAAdC,EAAc,KACxCC,EAAa,SAACC,GAClB,IAAMC,EAAID,EAAEE,SAAS,IAAIC,cACzB,OAAoB,IAAbF,EAAEG,OAAeH,EAAI,IAAMA,GAGpC,MAAM,IAAN,OAAWF,EAAWH,IAAtB,OAA2BG,EAAWF,IAAtC,OAA2CE,EAAWD,KAG3CO,EAAe,SAACC,GAAD,MAAwB,CAClDC,SAASD,EAAIH,cAAcK,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIH,cAAcK,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIH,cAAcK,OAAO,EAAG,GAAI,IACzC,MAKWC,EAAgB,SAACC,GAAD,OAAkBA,EAAM,GAAK,IAE7CC,EAAc,SAACC,GAAD,MAAoC,CAC7DC,KAAKC,MAAuB,IAAjBF,EAAOG,SAClBF,KAAKC,MAAuB,IAAjBF,EAAOG,SAClBF,KAAKC,MAAuB,IAAjBF,EAAOG,SAClB,MAGWC,EAAuB,SAAC,GAAD,uBAAEpB,EAAF,KAAKC,EAAL,KAAQC,EAAR,YAClCe,KAAKI,OAAOrB,EAAIC,EAAIC,GAAK,IAEdoB,EAAa,SAAC,GAAgC,IAAD,mBAA9BtB,EAA8B,KAA3BC,EAA2B,KAAxBC,EAAwB,KAArBqB,EAAqB,KAClDC,EAAQ,SAACC,GAAD,OAAeR,KAAKS,IAAIT,KAAKU,IAAIF,EAAG,KAAM,IAExD,MAAO,CAACD,EAAMxB,GAAIwB,EAAMvB,GAAIuB,EAAMtB,GAAIsB,EAAMD,KAGjCK,EAAqB,SAChCC,EACAC,EACAC,GACW,IAAD,cACcF,EADd,GACHG,EADG,KACIC,EADJ,mBAEKF,EAFL,GAEHG,EAFG,KAEAC,EAFA,KAGV,GAAID,EAAI,GAAKA,GAAKF,GAASG,EAAI,GAAKA,GAAKF,EACvC,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAMG,EAAMC,EAAcR,EAAYK,EAAGC,GACzC,MAAO,CAACL,EAAMM,GAAMN,EAAMM,EAAM,GAAIN,EAAMM,EAAM,GAAIN,EAAMM,EAAM,KAa3D,SAASE,EACdC,GAEoB,IADpBC,EACmB,uDADT,yBAEV,IAAKD,EACH,MAAM,IAAIE,iBAAe,CAAED,UAASE,OAAQH,IAOzC,IAAMI,EAAY,SACvBb,EACAc,GAMA,IAAMC,EAASf,EAAMe,OAAOC,KAAI,SAACC,EAAOX,GAAR,MAAiB,CAC/CY,KAAMJ,EAAGG,EAAMC,KAAMZ,EAAKN,EAAMe,OAAOrC,YAEzC,MAAO,CACLqB,WAAYC,EAAMD,WAClBgB,WAOSI,EAAY,SACvBpB,EACAe,GAIA,IAHe,IAAD,cACUf,EADV,GACPG,EADO,KACAC,EADA,KAERiB,EAAuB,IAAIC,WAAWnB,EAAQC,EAAS,GACpDE,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIF,EAAOE,GAAK,EAAG,CACjC,IAAM9B,EAAIkB,EAAWsB,EAAG,CAACV,EAAGC,KACtBC,EAAMC,EAAcR,EAAYK,EAAGC,GACzCe,EAAqBd,GAAOhC,EAAE,GAC9B8C,EAAqBd,EAAM,GAAKhC,EAAE,GAClC8C,EAAqBd,EAAM,GAAKhC,EAAE,GAClC8C,EAAqBd,EAAM,GAAKhC,EAAE,GAGtC,OAAO8C,GAOIE,EAAW,SACtBR,GAWA,OAAO,gBAAGd,EAAH,EAAGA,MAAOd,EAAV,EAAUA,OAAQqC,EAAlB,EAAkBA,WAAlB,OACLV,EAAUb,GAAO,SAACwB,EAAWC,EAAYC,GAAxB,OACfP,EAAUnB,EAAMD,YAAY,SAACE,GAAD,OAC1Ba,EAAG,CACDd,QACAD,WAAYC,EAAMD,WAClBb,SACAqC,aACAtB,QACAyB,aACAD,aACAE,YAAa,SAACrD,GAAD,OACXwB,EAAmBE,EAAMD,WAAYyB,EAAWlD,cAO/CsD,EAAS,SAACC,GAAD,OACpB,YAAI,IAAIC,MAAMD,IAAQb,KAAI,SAACe,EAAGC,GAAJ,OAAUA,MAEzBzB,EAAgB,SAAC,EAAqBH,EAAWC,GAAjC,OACT,GAAjBD,EAAIC,EADsB,sBAGhB4B,EAAa,SAACrE,GAMzB,IAAM0C,EAAMC,EAAc3C,EAAKmC,WAAYnC,EAAKqC,MAAM,GAAIrC,EAAKqC,MAAM,IACrErC,EAAKoC,MAAMM,GAAO1C,EAAKsE,MAAM,GAC7BtE,EAAKoC,MAAMM,EAAM,GAAK1C,EAAKsE,MAAM,GACjCtE,EAAKoC,MAAMM,EAAM,GAAK1C,EAAKsE,MAAM,GACjCtE,EAAKoC,MAAMM,EAAM,GAAK1C,EAAKsE,MAAM,IAGtBC,EAAc,SAACvE,GAId,IACJoC,EAA+BpC,EAA/BoC,MAAOoC,EAAwBxE,EAAxBwE,SAAUC,EAAczE,EAAdyE,UADd,cAEarC,EAAMD,WAFnB,GAEJG,EAFI,KAEGC,EAFH,KAGLmC,EAASpC,EAAQkC,EACjBG,EAASpC,EAASkC,EAElBG,EAA4B,CAACJ,EAAUC,GA6B7C,MAAO,CACLtB,OA5BgBf,EAAMe,OAAOC,KAAI,SAACC,GAElC,IADA,IAAMG,EAAuB,IAAIC,WAAWe,EAAWC,EAAY,GAC1DhC,EAAI,EAAGA,EAAIgC,EAAWhC,GAAK,EAClC,IAAK,IAAID,EAAI,EAAGA,EAAIgC,EAAUhC,GAAK,EAAG,CAIpC,IAAMqC,EAAOtD,KAAKC,MAAMgB,EAAIkC,GACtBI,EAAOvD,KAAKC,MAAMiB,EAAIkC,GAEtBvD,EAAQc,EAAmBE,EAAMD,WAAYkB,EAAMC,KAAM,CAC7DuB,EACAC,IAEFT,EAAW,CACTC,MAAOlD,EACPiB,MAAO,CAACG,EAAGC,GACXN,WAAYyC,EACZxC,MAAOoB,IAIb,MAAO,CACLF,KAAME,MAMRrB,WAAY,CAACqC,EAAUC,KC7NrBM,EAAwB,CAC5B,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,MAGLC,EAAkBjF,EAAe,CAC5CE,KAAM,mBACNE,YAAa,oDACbD,OAAQ,GACRE,GAAIsD,GAAS,YAAqD,IAAlDrB,EAAiD,EAAjDA,MAAOyB,EAA0C,EAA1CA,WAAYD,EAA8B,EAA9BA,WAC3BoB,GAAWlB,EAD8C,EAAlBA,aAChB1B,GAG7B,GAAIlB,EAAc8D,GAAW,CAC3B,IAAMC,EAAgB3D,KAAKC,MACxBqC,EAAaC,EAAciB,EAAajE,QAE3C,OAAOiE,EAAaG,GAGtB,OAAOD,O,oDCnBLE,EAMD,SAAC,GAAqD,IAAnDlF,EAAkD,EAAlDA,KAAMmF,EAA4C,EAA5CA,QAASC,EAAmC,EAAnCA,MAAOlF,EAA4B,EAA5BA,YAAamF,EAAe,EAAfA,SACzC,OACE,eAACC,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,cAACC,EAAA,EAAD,UACE,cAACC,EAAA,EAAD,CACEC,WAAS,EACTb,MAAOA,EACPC,SAAU,SAACa,GAAD,OACRb,EAAS,CAAEc,OAAO,EAAMf,MAAOc,EAAME,OAAOhB,SAJhD,SAOGD,EAAQhC,KAAI,SAACkD,GAAD,OACX,cAACC,EAAA,EAAD,CAAwBlB,MAAOiB,EAAEjB,MAAjC,SACGiB,EAAErG,MADUqG,EAAEjB,kBAUtB,SAASmB,EAAiBxG,GAM/B,MAAO,CACLC,KAAMD,EAAKC,KACXwG,aAAczG,EAAKyG,aACf,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACbhG,GAAI,SAACF,GACH,OACE,cAAC,EAAD,CACED,KAAMD,EAAKC,KACXoF,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,EACjDtB,QAASpF,EAAKoF,QACdjF,YAAaH,EAAKG,YAClBmF,SAAUpF,EAAOoF,a,kFClDdqB,EAAa,uCAAG,WAC3BC,EACAC,EACAC,GAH2B,mBAAAjF,EAAA,6DAKrBP,EAASyF,IAAWH,GALC,SAOCI,GAAUJ,GAPX,cAOrBK,EAPqB,OASrBC,EAAkB,GACxBL,EAAcM,QAAO,SAAC/E,EAAOgF,GAC3B,IAAMC,EAASD,EAAeE,UAAUlH,GAAG,CACzCgC,QACAuB,WAAYyD,EAAelH,OAC3BoB,WAGF,OADA4F,EAAOK,KAAKF,GACLA,IACNJ,GAlBwB,SAoBdO,QAAQC,IACnBP,EAAO9D,IAAP,uCAAW,WAAOsE,GAAP,iBAAA7F,EAAA,6DACH8F,EAAmBC,GAAoBF,EAAUpG,GAGjDc,EAAQyF,EACZH,EAASvE,OAAOC,KAAI,SAAC0E,GAAD,OAAOA,EAAExE,QAC7BqE,GANO,SASII,GAAUL,EAASvF,WAAYC,EAAOuF,EAAkBb,GAT5D,mFAAX,wDArByB,mFAAH,0DAuCpBe,EAAqB,SACzB1E,EACAwE,GAqBA,OAnBcxE,EAAOC,KAAI,SAACC,GAExB,IADA,IAAM2E,EAAM,IAAIvE,WAAWJ,EAAMvC,QACxBsD,EAAI,EAAGA,EAAIf,EAAMvC,OAAQsD,GAAK,EACjCuD,GAAoBtE,EAAMe,EAAI,GAAK,KAErC4D,EAAI5D,GAAKuD,EAAiB,GAC1BK,EAAI5D,EAAI,GAAKuD,EAAiB,GAC9BK,EAAI5D,EAAI,GAAKuD,EAAiB,GAC9BK,EAAI5D,EAAI,GAAKuD,EAAiB,KAE9BK,EAAI5D,GAAKf,EAAMe,GACf4D,EAAI5D,EAAI,GAAKf,EAAMe,EAAI,GACvB4D,EAAI5D,EAAI,GAAKf,EAAMe,EAAI,GACvB4D,EAAI5D,EAAI,GAAK,KAGjB,OAAO4D,MAMLD,GAAS,uCAAG,WAChB5F,EACAgB,EACAwE,EACAb,GAJgB,SAAAjF,EAAA,+EAMhB,IAAI2F,SAAgB,SAACS,GAAa,IAAD,cACP9F,EADO,GACxBG,EADwB,KACjBC,EADiB,KAEzB2F,EAAM,IAAIC,IAAW7F,EAAOC,GAIlC,GAFA2F,EAAIE,aAAatB,GACjBoB,EAAIG,UAAU,GACVV,EAAkB,CAEpB,IAAMW,EAAWjI,EAAWsH,GAAkBY,MAAM,GACpDL,EAAIM,eAAJ,YAAwBF,IAI1BJ,EAAIO,cAEJ,IAAInF,EAAc,GAClB4E,EAAIQ,GAAG,QAAQ,SAACC,GACdrF,EAAKiE,KAAKoB,MAEZT,EAAIQ,GAAG,OAAO,WACZ,IAAME,EAAUC,IAAIC,gBAClB,IAAIC,KAAKzF,EAAM,CAAE0F,KAAM,eAEzBf,EAAQW,MAGVzF,EAAO8F,SAAQ,SAACnB,GACdI,EAAIgB,SAASpB,MAGfI,EAAIiB,aApCU,2CAAH,4DAuCFnC,GAAY,SAAC4B,GAAD,OACvB,IAAIpB,SAAe,SAAC4B,EAAKC,GAAN,OACjBC,IACEV,GACA,SAACW,EAAYC,GACX,OAAID,EACKF,EAAIE,GAEJH,EAAI,CACTjG,OAAQ,CACN,CACEG,KAAMG,WAAWgG,KAAKD,EAAgBlG,QAG1CnB,WAAY,CAACqH,EAAgBE,MAAM,GAAIF,EAAgBE,MAAM,aAOnE9B,GAAsB,SAC1BxF,EACAd,GAEA,IAAIqI,GAAiB,EACfC,EAAa,IAAIC,IAFD,cAGEzH,EAAMD,WAHR,GAGfG,EAHe,KAGRC,EAHQ,KAIlBuH,EAAUzJ,EAAW,CAAC,EAAG,IAAK,EAAG,MAkBrC,OAjBA+B,EAAMe,OAAO8F,SAAQ,SAAC5F,GACpB,IAAK,IAAIZ,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIF,EAAOE,GAAK,EAAG,CACjC,IAAMuH,EAAK7H,EAAmBE,EAAMD,WAAYkB,EAAMC,KAAM,CAACd,EAAGC,IAChE,GAAItB,EAAc4I,GAChBJ,GAAiB,MACZ,CACL,IAAM3I,EAAMX,EAAW0J,GACvBH,EAAWI,IAAIhJ,GACXA,IAAQ8I,IAEVA,EAAUG,GAAwB3I,EAAQsI,SAM7CD,EAAiB5I,EAAa+I,QAAWpD,GAG5CuD,GAA0B,SAA1BA,EACJ3I,EACA4I,GAEY,IADZC,EACW,uDADA,EAELC,EAAM/J,EAAWgB,EAAYC,IACnC,OAAI6I,EAAW,IAENC,EAEFF,EAAIG,IAAID,GACXH,EAAwB3I,EAAQ4I,EAAKC,EAAW,GAChDC,G,UC1KOE,GAA0C,SAAC,GAAD,IACrDC,EADqD,EACrDA,gBACAtK,EAFqD,EAErDA,KACAqC,EAHqD,EAGrDA,MACAC,EAJqD,EAIrDA,OACA+C,EALqD,EAKrDA,SALqD,OAOrD,eAACC,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACgF,GAAA,EAAD,CACEC,UAAW,cAAC3E,EAAA,EAAD,oBACX4E,GAAI,CAAEC,SAAU,SAChBhF,QAAQ,YACRiF,UAAU,QAJZ,UAMG3K,EACD,uBACE+I,KAAK,OACL6B,QAAM,EACNC,OAAO,sBACP7K,KAAK,aACLqF,SAAQ,uCAAE,WAAOa,GAAP,qBAAAtE,EAAA,6DACFkJ,EAAQ7G,MAAMuF,KAAN,UAAWtD,EAAME,OAAO0E,aAAxB,QAAiC,IACzCC,EAAOD,EAAM,GAFX,SAGgBE,GAASD,GAHzB,OAGFE,EAHE,OAIR5F,EAAS4F,GAJD,2CAAF,2DAQXX,GACC,qBACEjI,MAAOA,EACPC,OAAQA,EACR4I,IAAKZ,EACLa,IAAI,eAMNH,GAAW,SAACD,GAAD,OACf,IAAIxD,SAAgB,SAACS,GACnB,IAAMoD,EAAS,IAAIC,WACnBD,EAAOE,OAAS,kBAAMtD,EAAQoD,EAAOhE,SACrCgE,EAAOG,cAAcR,OC3ClB,IAAMS,GAAkB1L,EAAe,CAC5CE,KAAM,mBACNE,YAAa,gEACbD,OAAQ,CCJH,YAEuE,IAD5ED,EAC2E,EAD3EA,KAEA,MAAO,CACLA,OACAwG,aAAc,CAAEL,OAAO,GACvBhG,GAAI,SAACF,GAAD,OACF,cAAC,GAAD,CACEqK,gBACErK,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,MAAMuD,aAAUlC,EAEpDzG,KAAMA,EACNqC,MAAO,GACPC,OAAQ,GACR+C,SAAQ,uCAAE,WAAOsD,GAAP,eAAA/G,EAAA,sEACYmF,GAAU4B,GADtB,OACFxG,EADE,OAERlC,EAAOoF,SAAS,CAAEc,OAAO,EAAMf,MAAO,CAAEuD,UAASxG,WAFzC,2CAAF,0DDTZsJ,CAAiB,CACfzL,KAAM,UAERuG,EAAc,CACZvG,KAAM,OACNwG,aAAc,aACdrB,QAAS,CACP,CACEnF,KAAM,aACNoF,MAAO,cAET,CACEpF,KAAM,aACNoF,MAAO,kBAKfjF,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WACNgI,EAAapH,EAAY,CAC7BnC,MAAOuB,EAAW,GAAGvB,MACrBoC,SAAUpC,EAAMD,WAAW,GAC3BsC,UAAWrC,EAAMD,WAAW,KAExB6G,EAAOrF,EAAW,GAExB,OAAOV,EAAUb,GAAO,SAACkB,GACvB,OAAOC,EAAUnB,EAAMD,YAAY,SAACE,GAClC,IAAM8I,EAAMjJ,EAAmBE,EAAMD,WAAYmB,EAAMjB,GACjDuJ,EAAgB1J,EACpByJ,EAAWxJ,WACXwJ,EAAWxI,OAAO,GAAGG,KACrBjB,GAGF,MAAa,eAAT2G,EAEK7H,EAAcgK,GAAOS,EAAgBT,EAErChK,EAAcyK,GAAiBT,EAAMS,W,oBEtChDC,GAMD,SAAC,GAAmD,IAAjD5L,EAAgD,EAAhDA,KAAMoF,EAA0C,EAA1CA,MAAOlF,EAAmC,EAAnCA,YAAa2L,EAAsB,EAAtBA,MAAOxG,EAAe,EAAfA,SAAe,EAChCyG,IAAMC,cAChBtF,IAAVrB,OAAsBqB,EAAYrB,EAAMzE,YAFY,mBAC/CqL,EAD+C,KAC1CC,EAD0C,OAIhBH,IAAMC,SAAS,IAJC,mBAI/CG,EAJ+C,KAIlCC,EAJkC,KAwBtD,OACE,eAAC7G,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,eAACC,EAAA,EAAD,WACE,cAACqG,GAAA,EAAD,CACEC,QAASH,EACT1F,aAAcpB,EACdkH,OAhCO,WACb,QAAY7F,IAARuF,KAKA5G,GAAS4G,IAAQ5G,EAAMzE,YAA3B,CAGA,IAAMmB,EAAI+J,EAAMG,GACZlK,EAAEqE,MACJgG,EAAe,IAEfA,EAAerK,EAAEyK,QAEnBlH,EAASvD,KAkBHuD,SAAU,SAACmH,GACTP,EAAOO,EAAEpG,OAAOhB,UAGnB8G,GAAe,cAACO,GAAA,EAAD,UAAiBP,WAM5BQ,GAAW,SAAC3M,GAAD,MAMM,CAC5BC,KAAMD,EAAKC,KACXwG,kBACwBC,IAAtB1G,EAAKyG,aACD,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACfhG,GAAI,SAACF,GAAY,IACP+B,EAAajC,EAAbiC,IAAKD,EAAQhC,EAARgC,IAkBb,OACE,cAAC,GAAD,CACE/B,KAAMD,EAAKC,KACXE,YAAaH,EAAKG,YAClB2L,MArBU,SAACnL,GACb,IAAMoB,EAAId,SAASN,EAAG,IACtB,OAAIiM,MAAM7K,GACD,CAAEqE,OAAO,EAAOoG,OAAQ,2BAErB9F,IAARzE,GAAqBF,EAAIE,EACpB,CACLmE,OAAO,EACPoG,OAAO,oCAAD,OAAsCvK,SAGpCyE,IAAR1E,GAAqBD,EAAIC,EACpB,CAAEoE,OAAO,EAAOoG,OAAO,iCAAD,OAAmCxK,IAE3D,CAAEoE,OAAO,EAAMf,MAAOtD,IAQ3BuD,SAAUpF,EAAOoF,SACjBD,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,OCxG5CmG,GAAS9M,EAAe,CACnCE,KAAM,SACNE,YAAa,oCACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,eACNE,YAAa,kBACbsG,aAAc,EACdxE,IAAK,KAGT7B,GAAIsD,GAAS,YAAiE,IAA9DrB,EAA6D,EAA7DA,MAAOyB,EAAsD,EAAtDA,WAAYD,EAA0C,EAA1CA,WAAYE,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAAiB,cAC5DtB,EAD4D,GAQ3E,OAAO0B,EAAY,CARwD,UAIzExC,KAAKI,MACHgC,EAAW,GAAKpC,KAAKuL,IAAKjJ,EAAaC,EAAc,EAAIvC,KAAKwL,Y,UCfhEC,GAQD,SAAC,GAA4D,IAA1D/M,EAAyD,EAAzDA,KAAMoF,EAAmD,EAAnDA,MAAOpD,EAA4C,EAA5CA,IAAKD,EAAuC,EAAvCA,IAAKiL,EAAkC,EAAlCA,KAAM9M,EAA4B,EAA5BA,YAAamF,EAAe,EAAfA,SAChD,OACE,eAACC,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,eAACR,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAAC0H,GAAA,EAAD,CACEC,aAAYlN,EACZwG,aAAcpB,EACd4H,KAAMA,EACNG,kBAAkB,MAClBC,iBAAkB,SAAC7K,GAAD,OAAOA,EAAE5B,YAC3BqB,IAAKA,EACLD,IAAKA,EACLsD,SAAU,SAACmH,EAAGpH,GAAJ,OACRC,EAAS,CAAEc,OAAO,EAAMf,MAAOA,OAGnC,cAACK,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6BN,WAM9B,SAASiI,GAAYtN,GAQ1B,MAAO,CACLC,KAAMD,EAAKC,KACXwG,kBACwBC,IAAtB1G,EAAKyG,aACD,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACfhG,GAAI,SAACF,GACH,OACE,cAAC,GAAD,CACED,KAAMD,EAAKC,KACXoF,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,EACjDpB,SAAUpF,EAAOoF,SACjBrD,IAAKjC,EAAKiC,IACVD,IAAKhC,EAAKgC,IACViL,KAAMjN,EAAKiN,KACX9M,YAAaH,EAAKG,gBC9DrB,IAAMoN,GAAaxN,EAAe,CACvCE,KAAM,aACNE,YAAa,mDACbD,OAAQ,CACNoN,GAAY,CACVrN,KAAM,SACNwG,aAAc,EACdxE,KAAM,IACND,IAAK,OAGT5B,GAAIsD,GAAS,YAAyC,IAAtCrB,EAAqC,EAArCA,MAAO0B,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAE5B6J,EAF6C,YAClC7J,EADkC,MAEvB,IAAO,IAC7B8J,EAAI1J,EAAY1B,GACtB,OAAOT,EAAW,CAChB6L,EAAE,GAAKD,EACPC,EAAE,GAAKD,EACPC,EAAE,GAAKD,EACPC,EAAE,UCnBKC,GAAS3N,EAAe,CACnCE,KAAM,SACNE,YAAa,4CACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,SACNE,YAAa,kBACbsG,aAAc,GACdxE,IAAK,KAGT7B,GAAIsD,GAAS,YAAiE,IAA9DrB,EAA6D,EAA7DA,MAAOyB,EAAsD,EAAtDA,WAAYD,EAA0C,EAA1CA,WAAYE,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WACnDgK,EADoE,YAC1DhK,EAD0D,oBAE5DtB,EAF4D,GAEpEG,EAFoE,KAEjEC,EAFiE,KAS3E,OAAOsB,EAAY,CAACvB,EANJjB,KAAKI,MACnBgM,EAASpM,KAAKuL,KAAK,EAAIvL,KAAKwL,IAAMlJ,EAAaC,KAKhBrB,EAHjBlB,KAAKI,MACnBgM,EAASpM,KAAKqM,KAAK,EAAIrM,KAAKwL,IAAMlJ,EAAaC,YClBxC+J,GAAS9N,EAAe,CACnCE,KAAM,SACNE,YAAa,iCACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,SACNE,YAAa,kBACbsG,aAAc,GACdxE,IAAK,KAGT7B,GAAIsD,GACF,YAOO,IANLvB,EAMI,EANJA,WACAE,EAKI,EALJA,MACAyB,EAII,EAJJA,WACAD,EAGI,EAHJA,WACAE,EAEI,EAFJA,YACAJ,EACI,EADJA,WAEMjB,EAAMmB,EAAaC,EACnBgK,EAAOvM,KAAKqM,IAAU,EAANlL,EAAUnB,KAAKwL,IAAMpJ,EAAW,GAFlD,cAKoBxB,EALpB,GAKGG,EALH,KAKUC,EALV,KAMEwL,EAAUzL,EAAQ,EAClB0L,EAAUzL,EAAS,EAPrB,cASWF,EATX,GASGG,EATH,KASMC,EATN,KAUEiC,GAAUlC,EAAIuL,GAAWzL,EACzBqC,GAAUlC,EAAIuL,GAAWzL,EAI/B,OAAOwB,EAAY,CAACvB,EAFJjB,KAAKC,MAAMsM,EAAOpJ,GAEDjC,EADjBlB,KAAKI,MAAMmM,EAAOnJ,UChC3BsJ,GAAUlO,EAAe,CACpCE,KAAM,UACNE,YAAa,wDACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,SACNE,YAAa,kBACbsG,aAAc,GACdxE,IAAK,KAGT7B,GAAIsD,GACF,YAOO,IANLvB,EAMI,EANJA,WACAE,EAKI,EALJA,MACAyB,EAII,EAJJA,WACAD,EAGI,EAHJA,WACAE,EAEI,EAFJA,YACAJ,EACI,EADJA,WAEMjB,EAAMmB,EAAaC,EACnBoK,EAAYxL,EAAM,GAFpB,cAGoBP,EAHpB,GAGGG,EAHH,KAGUC,EAHV,KAIEuL,GAAQI,EAAYxL,EAAM,EAAIA,GAAOiB,EAAW,GAChDoK,EAAUzL,EAAQ,EAClB0L,EAAUzL,EAAS,EANrB,cAQWF,EARX,GAQGG,EARH,KAQMC,EARN,KASE0L,EAAQ5M,KAAK6M,MAAMJ,EAAUvL,EAAGsL,EAAUvL,GAIhD,OAAOuB,EAAY,CAACvB,EAFJjB,KAAKI,MAAMmM,EAAOvM,KAAKqM,IAAIO,IAEV1L,EADjBlB,KAAKI,MAAMmM,EAAOvM,KAAKuL,IAAIqB,WChCpCrK,GAAa/D,EAAe,CACvCE,KAAM,cACNE,YACE,gGACFD,OAAQ,CACNoN,GAAY,CACVrN,KAAM,mBACNwG,aAAc,GACdxE,IAAK,EACLD,IAAK,MAGT5B,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WACLG,EADsB,YACRH,EADQ,MAGvB0K,EAAgBjM,EAAMe,OAKtBA,EAASa,EAAOF,GAAYV,KAChC,SAACgB,GAAD,MAAe,CACbd,KAAM+K,EAAcjK,GAChBiK,EAAcjK,GAAGd,KACjB+K,EAAcA,EAAcvN,OAAS,GAAGwC,SAIhD,MAAO,CACLnB,WAAYC,EAAMD,WAClBgB,aC/BOmL,GAAYvO,EAAe,CACtCE,KAAM,YACNE,YAAa,iCACbD,OAAQ,GACRE,GAAIsD,GAAS,YAA6B,IAA1BrB,EAAyB,EAAzBA,MACR4C,GAAWlB,EADsB,EAAlBA,aACQ1B,GAE7B,GAAIlB,EAAc8D,GAChB,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAMsJ,EAAO7M,EAAqBuD,GAElC,MAAO,CAACsJ,EAAMA,EAAMA,EAAM,U,SCZjBC,GAAWzO,EAAe,CACrCE,KAAM,YACNE,YAAa,6BACbD,OAAQ,GACRE,GAAIsD,GAAS,YAAqD,IAAlDrB,EAAiD,EAAjDA,MAAO0B,EAA0C,EAA1CA,YAAaD,EAA6B,EAA7BA,WAAYD,EAAiB,EAAjBA,WAAiB,EAC1CE,EAAY1B,GAD8B,mBACxD/B,EADwD,KACrDC,EADqD,KAClDC,EADkD,KAC/CqB,EAD+C,OAE9C4M,OAAYC,IAAI,CAACpO,EAAGC,EAAGC,IAFuB,mBAEtDG,EAFsD,KAEnDgO,EAFmD,OAGpCF,OAAYG,IAAI,CACxC/K,EAAaC,EAAc,IAC5BnD,EACAgO,IAN6D,mBAQ/D,MAAO,EAAErO,EARsD,MAQ1C,GAAIC,EARsC,MAQ1B,GAAIC,EARsB,MAQV,EAAGqB,Q,SCRtDgN,GAKD,SAAC,GAA4C,IAA1C5O,EAAyC,EAAzCA,KAAMoF,EAAmC,EAAnCA,MAAOlF,EAA4B,EAA5BA,YAAamF,EAAe,EAAfA,SAC1BgD,OACM5B,IAAVrB,OACIqB,EACArG,EAAW,GAAD,mBAAKoO,OAAYG,IAAI,CAACvJ,EAAO,IAAK,OAAlC,CAAyC,OACzD,OACE,eAACE,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,cAAC,KAAD,CACEzB,MAAOgE,EACPwG,iBAAkB,gBAAGJ,EAAH,EAAGA,IAAH,OAAapJ,EAAS,CAAEc,OAAO,EAAMf,MAAOqJ,EAAIK,WCzBnE,ID+BwB/O,GC/BlBgP,GAAWjP,EAAe,CACrCE,KAAM,YACNE,YAAa,oCACbD,OAAQ,ED4BqBF,GC3BZ,CACbC,KAAM,MACNwG,aAAc,KD8BX,CACLxG,KAAMD,GAAKC,KACXwG,aAAczG,GAAKyG,aACf,CAAEL,OAAO,EAAMf,MAAOrF,GAAKyG,cAC3B,CAAEL,OAAO,GACbhG,GAAI,SAACF,GACH,OACE,cAAC,GAAD,CACED,KAAMD,GAAKC,KACXoF,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,EACjDpB,SAAUpF,EAAOoF,eCrCzBlF,GAAIsD,GAAS,YAAyC,IAAtCrB,EAAqC,EAArCA,MAAO0B,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAC3BsL,EAD4C,YAClCtL,EADkC,QAE9BI,EAAY1B,GAFkB,mBAE5C/B,EAF4C,KAEzCC,EAFyC,KAEtCC,EAFsC,KAEnCqB,EAFmC,OAGlC4M,OAAYC,IAAIpO,EAAGC,EAAGC,GAHY,mBAG1CG,EAH0C,KAGvCgO,EAHuC,OAIxBF,OAAYG,IAAI,CAACK,EAAQtO,EAAGgO,IAJJ,mBAKnD,MAAO,CAL4C,eAKzB9M,QCRxBqN,GAKD,SAAC,GAA4C,IAA1CjP,EAAyC,EAAzCA,KAAMoF,EAAmC,EAAnCA,MAAOlF,EAA4B,EAA5BA,YAAamF,EAAe,EAAfA,SAAe,EACzByG,IAAMC,SAAS3G,GADU,mBACxC4G,EADwC,KACnCC,EADmC,KAG/C,OACE,eAAC3G,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,cAACC,EAAA,EAAD,UACE,cAACqG,GAAA,EAAD,CACE5F,aAAcpB,EACdC,SAAU,SAACmH,GAAD,OAAOP,EAAOO,EAAEpG,OAAOhB,QACjCkH,OAAQ,kBACNjH,EAAS2G,EAAM,CAAE7F,OAAO,EAAMf,MAAO4G,GAAQ,CAAE7F,OAAO,aCtB5D+I,GAAgC,CACpC,CAAC,EAAG,GAAI,GAAI,KACZ,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,MAGLC,GAAYrP,EAAe,CACtCE,KAAM,YACNE,YAAa,+CACbD,OAAQ,CDoBe,SAACF,GAAD,MAIK,CAC5BC,KAAMD,EAAKC,KACXwG,kBACwBC,IAAtB1G,EAAKyG,aACD,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACfhG,GAAI,SAACF,GAAD,OACF,cAAC,GAAD,CACED,KAAMD,EAAKC,KACXE,YAAaH,EAAKG,YAClBmF,SAAUpF,EAAOoF,SACjBD,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,MClCnD2I,CAAU,CACRpP,KAAM,cACNE,YACE,mEACFsG,aAAc,eAGlBrG,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WACNrC,EAASyF,IAAWpD,EAAW,IACrC,OAAOV,EAAUb,GAAO,SAACkB,GACvB,IAAMc,EAAI9C,IACJgO,EAAiBlL,EAAI,GAAM,EAAIA,EAAI,IAAO,EAAIA,EAAI,IAAO,EAAI,EAEnE,OAAOb,EAAUnB,EAAMD,YAAY,SAACE,GAClC,IAAM8I,EAAMjJ,EAAmBE,EAAMD,WAAYmB,EAAMjB,GAEvD,GAAIlB,EAAcgK,GAChB,OAAOgE,GAAqBG,GAG9B,GAAIA,EAAiB,EAAG,CAEtB,IAAMC,EAAM,KAAOD,EACnB,MAAO,CAACnE,EAAI,GAAKoE,EAAKpE,EAAI,GAAKoE,EAAKpE,EAAI,GAAKoE,EAAKpE,EAAI,IAIxD,OAAOA,WC9CFqE,GAAOzP,EAAe,CACjCE,KAAM,OACNE,YAAa,WACbD,OAAQ,GACRE,GAAIsD,GAAS,YAAqD,IAAlDrB,EAAiD,EAAjDA,MAAO0B,EAA0C,EAA1CA,YAAaD,EAA6B,EAA7BA,WAC5B2L,EADyD,EAAjB5L,WACdC,EAAc,IADiB,EAE1CC,EAAY1B,GAF8B,mBAExD/B,EAFwD,KAErDC,EAFqD,KAElDC,EAFkD,KAE/CqB,EAF+C,OAG7C4M,OAAYC,IAAIpO,EAAGC,EAAGC,GAHuB,mBAGxDuO,EAHwD,KAGrDpO,EAHqD,KAGlDgO,EAHkD,OAIpCF,OAAYG,IAAI,CAACG,EAAGpO,EAAGgO,EAAIc,EAAYd,EAAI,IAJP,mBAK/D,MAAO,CALwD,eAKrCA,EAAIc,EAAY5N,EAAI,QCV5CkD,GAAwB,CAC5B,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,MAGL2K,GAAQ3P,EAAe,CAClCE,KAAM,QACNE,YAAa,wCACbD,OAAQ,GACRE,GAAIsD,GAAS,YAAqD,IAAlDrB,EAAiD,EAAjDA,MAAOyB,EAA0C,EAA1CA,WAAYD,EAA8B,EAA9BA,WAC3BoB,GAAWlB,EAD8C,EAAlBA,aAChB1B,GAE7B,GAAIlB,EAAc8D,GAChB,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAMC,EAAgB3D,KAAKC,MACxBqC,EAAaC,EAAciB,GAAajE,QAErC6O,EAAa5K,GAAaG,GAE1BqJ,EAAO7M,EAAqBuD,GAElC,MAAO,CACJsJ,EAAOoB,EAAW,GAAM,IACxBpB,EAAOoB,EAAW,GAAM,IACxBpB,EAAOoB,EAAW,GAAM,IACzB,U,8BCxBOC,GAAwC,SAAC,GAG/C,IAFLC,EAEI,EAFJA,QACAC,EACI,EADJA,SACI,EAC8B/D,IAAMC,UAAS,GAD7C,mBACG+D,EADH,KACcC,EADd,KAGJ,OACE,cAACC,GAAA,EAAD,CAAmBC,YAAa,kBAAMF,GAAa,IAAnD,SACE,eAACG,GAAA,EAAD,WACE,cAAC3F,GAAA,EAAD,CACE4F,QAAS,kBAAMJ,GAAcD,IAC7BM,MAAO,CAAEC,cAAe,QAF1B,SAIE,eAAC/K,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,8BAAMqK,IACN,cAAC/J,EAAA,EAAD,UAAOiK,EAAY,cAAgB,qBAGvC,cAACQ,GAAA,EAAD,CAAUC,IAAKT,EAAf,SAA2BD,UCxB7BW,GAAuC,SAAC,GAAD,IAAGnM,EAAH,EAAGA,MAAH,OAC3C,qBACE+L,MAAO,CACL/N,MAAO,QACPC,OAAQ,QACRmO,gBAAiBrQ,EAAWiE,OAK5BqM,GAKD,SAAC,GAA4C,IAA1C1Q,EAAyC,EAAzCA,KAAMoF,EAAmC,EAAnCA,MAAOlF,EAA4B,EAA5BA,YAAamF,EAAe,EAAfA,SAChC,OACE,cAAC,GAAD,CACEuK,QACE,eAACtK,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,qBAGHT,GAAS,cAAC,GAAD,CAAUf,MAAOe,OATjC,SAaE,cAAC,KAAD,CACEuL,cAAc,EACdC,aAAc,GACdvM,MAAOe,EAAQhF,EAAWgF,QAASqB,EACnCoI,iBAAkB,SAACpO,GAAD,OAChB4E,EAAS,CAAEc,OAAO,EAAMf,MAAOtE,EAAaL,EAAEM,aAOjD,SAAS8P,GAAiB9Q,GAK/B,MAAO,CACLC,KAAMD,EAAKC,KACXwG,aAAczG,EAAKyG,aACf,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACbhG,GAAI,SAACF,GACH,OACE,cAAC,GAAD,CACED,KAAMD,EAAKC,KACXoF,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,EACjDpB,SAAUpF,EAAOoF,SACjBnF,YAAaH,EAAKG,gB,cC7CtB4Q,GAA0D,SAAC,GAO1D,IANL9Q,EAMI,EANJA,KACA+Q,EAKI,EALJA,aACAC,EAII,EAJJA,eACA5L,EAGI,EAHJA,MACAlF,EAEI,EAFJA,YACAmF,EACI,EADJA,SACI,EACwByG,IAAMC,cAGtBtF,IAAVrB,EACI,GACAA,EAAMjC,KAAI,SAAC8N,EAAGxO,GAAJ,MAAa,CAAEyO,MAAOF,IAAkBG,OAAQF,OAN5D,mBACGhR,EADH,KACWmR,EADX,KAQJ,OACE,cAACC,EAAA,EAAD,UACE,eAAC/L,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,wBAIL5F,EAAOkD,KAAI,WAAoBV,GAAS,IAA1ByO,EAAyB,EAAzBA,MAAOC,EAAkB,EAAlBA,OACdG,EAAMJ,EAAM/Q,GAAG,CACnBiF,MAAO,CAAEe,OAAO,EAAMf,MAAO+L,GAC7B9L,SAAU,SAACkM,GACT,GAAIA,EAASpL,MAAO,CAClB,IAAMqH,EAAIvN,EAAOkD,KAAI,SAACqO,EAAMrN,GAC1B,OAAI1B,IAAQ0B,EACH,CACL+M,QACAC,OAAQI,EAASnM,OAGdoM,KAETJ,EAAU5D,GACVnI,EAAS,CACPc,OAAO,EACPf,MAAOoI,EAAErK,KAAI,SAACrB,GAAD,OAAOA,EAAEqP,gBAM9B,OACE,eAAC7L,EAAA,EAAD,CAAOE,UAAU,MAAjB,UACE,cAACiM,GAAA,EAAD,CACEtB,QAAS,WACP,IAAMuB,EAAYzR,EAAO0R,QAAO,SAACpP,EAAG4B,GAAJ,OAAUA,IAAM1B,KAChD2O,EAAUM,GACVrM,EAAS,CACPc,OAAO,EACPf,MAAOsM,EAAUvO,KAAI,SAACrB,GAAD,OAAOA,EAAEqP,aANpC,SAUE,cAACtL,EAAA,EAAD,uBAEDyL,IAbH,UAA+BtR,EAA/B,YAAuCyC,OAiB3C,cAAC8H,GAAA,EAAD,CACE7E,QAAQ,YACRyK,QAAS,WACP,IAAM3C,EAAIwD,IACJU,EAAS,sBACVzR,GADU,CAEb,CACEiR,MAAO1D,EACP2D,OAAQ3D,EAAEhH,aAAaL,MAAQqH,EAAEhH,aAAapB,WAAQqB,KAG1D2K,EAAUM,GACNlE,EAAEhH,aAAaL,OACjBd,EAAS,CACPc,OAAO,EACPf,MAAOsM,EAAUvO,KAAI,SAACrB,GAAD,OAAOA,EAAEqP,aAftC,SAoBGJ,UAOJ,SAASa,GAAuB7R,GAOrC,MAAO,CACLC,KAAMD,EAAKC,KACXwG,aAAczG,EAAKyG,aACf,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACbhG,GAAI,SAACF,GACH,OACE,cAAC,GAAD,CACED,KAAMD,EAAKC,KACX+Q,aAAchR,EAAKgR,aACnB3L,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,EACjDuK,eAAgBjR,EAAKiR,eACrB9Q,YAAaH,EAAKG,YAClBmF,SAAUpF,EAAOoF,aChI3B,IAAMwM,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA1O,IAAIrC,GAEOgR,GAAWhS,EAAe,CACrCE,KAAM,WACNE,YAAa,8BACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,WACNE,YAAa,+CACbsG,aAAc,IAEhBkG,GAAS,CACP1M,KAAM,WACNE,YAAa,6CACbsG,aAAc,KAEhB6G,GAAY,CACVrN,KAAM,cACNE,YAAa,0DACbsG,aAAc,EACdxE,IAAK,EACLD,IAAK,KAEP6P,GAAoB,CAClB5R,KAAM,SACN+Q,aAAc,YACd7Q,YAAa,0BACbsG,aAAcqL,GACdb,eAAgB,kBACdH,GAAiB,CACf7Q,KAAM,cAIdG,GAAIsD,GACF,YAkBE,IAXK,IANLrB,EAMI,EANJA,MACAF,EAKI,EALJA,WACA2B,EAII,EAJJA,WACAD,EAGI,EAHJA,WACAE,EAEI,EAFJA,YACAJ,EACI,EADJA,WAEMsB,EAAWlB,EAAY1B,GADzB,cAG2CsB,EAH3C,GAGGqO,EAHH,KAGYC,EAHZ,KAGqBC,EAHrB,KAGiCC,EAHjC,KAKEC,EAAcD,EAAOrR,OAASoR,EAC9BG,EAAmB9Q,KAAKI,MAAM,IAAMyQ,GAItCE,EAAeH,EAAOrR,OACmC,QAArDsR,EAAcE,GAAcC,QAAQ,GAAGhK,OAAO,IACpD+J,GAAgB,EAIlB,GAAInR,EAAc8D,GAAW,CAC3B,IAAM8I,EAAU5L,EAAW,GAAK,EAAI6P,EAC9BhE,EAAU7L,EAAW,GAAK,EAAI8P,EAFT,cAGZ5P,EAHY,GAIrBmQ,EAJqB,KAIJzE,EACjB0E,EALqB,KAKJzE,EAEjB0E,GACH,IAA4C,IAArCnR,KAAK6M,MAAMqE,EAAYD,GAAqBjR,KAAKwL,IAAM,IAE3D4F,EACJpR,KAAKC,MAAMkR,EAAaL,GAAoBC,EAGxCM,EAAgB/O,EAAaC,EAGnC,OAAOqO,GADJ5Q,KAAKC,MAAMoR,EAAgBN,GAAgBK,GAAYL,GAI5D,OAAOrN,OCjFP6M,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA1O,IAAIrC,GAEO8R,GAAW9S,EAAe,CACrCE,KAAM,WACNE,YAAa,8BACbD,OAAQ,CACNoN,GAAY,CACVrN,KAAM,cACNE,YAAa,0DACbsG,aAAc,EACdxE,IAAK,EACLD,IAAK,KAEP6P,GAAoB,CAClB5R,KAAM,SACN+Q,aAAc,YACd7Q,YAAa,oCACbsG,aAAcqL,GACdb,eAAgB,kBACdH,GAAiB,CACf7Q,KAAM,cAIdG,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WAAiB,cACAA,EADA,GACtBuO,EADsB,KACVC,EADU,KAEvBW,EAAY9O,EAAOkO,GAAYa,SAAQ,kBAAMZ,KAFtB,cAGL/P,EAAMD,WAHD,GAGtBG,EAHsB,KAGfC,EAHe,KAIvBwL,EAAUzL,EAAQ,EAClB0L,EAAUzL,EAAS,EAEzB,OAAOU,EAAUb,GAAO,SAACwB,EAAWC,EAAYC,GAAxB,OACtBP,EAAUnB,EAAMD,YAAY,SAACE,GAC3B,IAAM4C,EAAW/C,EAAmBE,EAAMD,WAAYyB,EAAWvB,GAGjE,GAAIlB,EAAc8D,GAAW,CAAC,IAAD,cACZ5C,EADY,GACpBG,EADoB,KACjBC,EADiB,KAErB+P,EAAahQ,EAAIuL,EACjB0E,EAAahQ,EAAIuL,EAEjBgF,EAAUzR,KAAK0R,KAClB3Q,EAAQ,GAAMA,EAAQ,GAAMC,EAAS,GAAMA,EAAS,IAEjD2Q,EAAiB3R,KAAK0R,KAC1BR,EAAaA,EAAaD,EAAaA,GAGnCG,EACJpR,KAAKC,OAAO,EAAI0R,EAAiBF,GAAWF,EAAUhS,QACtDgS,EAAUhS,OAGN8R,EAAgB/O,EAAaC,EAC7BpB,GACHnB,KAAKC,MAAMoR,EAAgBE,EAAUhS,QAAU6R,GAChDG,EAAUhS,OACZ,OAAOgS,EAAUpQ,GAGnB,OAAOuC,WC9EFV,GAAcxE,EAAe,CACxCE,KAAM,eACNE,YACE,4IAGFD,OAAQ,CACNyM,GAAS,CAAE1M,KAAM,QAASwG,aAAc,IAAKxE,IAAK,IAClD0K,GAAS,CAAE1M,KAAM,SAAUwG,aAAc,IAAKxE,IAAK,KAErD7B,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WAAiB,cACLvB,EAAMD,WADD,GACtBG,EADsB,KACfC,EADe,mBAECoB,EAFD,GAEtBa,EAFsB,KAEZC,EAFY,KAIvBG,EAA4B,CAACJ,EAAUC,GAEvC0O,GAAY3O,EAAWlC,GAAS,EAChC8Q,GAAY3O,EAAYlC,GAAU,EA6BxC,MAAO,CACLY,OA5BgBf,EAAMe,OAAOC,KAAI,SAACC,GAElC,IADA,IAAMG,EAAuB,IAAIC,WAAWe,EAAWC,EAAY,GAC1DhC,EAAI,EAAGA,EAAIgC,EAAWhC,GAAK,EAClC,IAAK,IAAID,EAAI,EAAGA,EAAIgC,EAAUhC,GAAK,EAAG,CACpC,IAAMpB,EACJoB,EAAI2Q,GACJ3Q,EAAIgC,EAAW2O,GACf1Q,EAAI2Q,GACJ3Q,EAAIgC,EAAY2O,EACZlR,EAAmBE,EAAMD,WAAYkB,EAAMC,KAAM,CAC/Cd,EAAI2Q,EACJ1Q,EAAI2Q,IAEN,CAAC,EAAG,EAAG,EAAG,GAChB/O,EAAW,CACTC,MAAOlD,EACPiB,MAAO,CAACG,EAAGC,GACXN,WAAYyC,EACZxC,MAAOoB,IAIb,MAAO,CACLF,KAAME,MAMRrB,WAAYyC,MCpCZyO,GAMD,SAAC,GAAmD,IAAjDpT,EAAgD,EAAhDA,KAAMoF,EAA0C,EAA1CA,MAAOlF,EAAmC,EAAnCA,YAAa2L,EAAsB,EAAtBA,MAAOxG,EAAe,EAAfA,SAAe,EAChCyG,IAAMC,cAChBtF,IAAVrB,OAAsBqB,EAAYrB,EAAMzE,YAFY,mBAC/CqL,EAD+C,KAC1CC,EAD0C,OAIhBH,IAAMC,SAAS,IAJC,mBAI/CG,EAJ+C,KAIlCC,EAJkC,KAwBtD,OACE,eAAC7G,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,QAApB,SAA6B1F,IAC5BE,GACC,cAACyF,EAAA,EAAD,CAASC,MAAO1F,EAAhB,SACE,cAAC2F,EAAA,EAAD,CAAMC,SAAS,QAAf,uBAIN,eAACC,EAAA,EAAD,WACE,cAACqG,GAAA,EAAD,CACEC,QAASH,EACT1F,aAAcpB,EACdkH,OAhCO,WACb,QAAY7F,IAARuF,KAKA5G,GAAS4G,IAAQ5G,EAAMzE,YAA3B,CAGA,IAAMmB,EAAI+J,EAAMG,GACZlK,EAAEqE,MACJgG,EAAe,IAEfA,EAAerK,EAAEyK,QAEnBlH,EAASvD,KAkBHuD,SAAU,SAACmH,GACTP,EAAOO,EAAEpG,OAAOhB,UAGnB8G,GAAe,cAACO,GAAA,EAAD,UAAiBP,WAM5BmH,GAAa,SAACtT,GAAD,MAMI,CAC5BC,KAAMD,EAAKC,KACXwG,kBACwBC,IAAtB1G,EAAKyG,aACD,CAAEL,OAAO,EAAMf,MAAOrF,EAAKyG,cAC3B,CAAEL,OAAO,GACfhG,GAAI,SAACF,GAAY,IACP+B,EAAajC,EAAbiC,IAAKD,EAAQhC,EAARgC,IAkBb,OACE,cAAC,GAAD,CACE/B,KAAMD,EAAKC,KACXE,YAAaH,EAAKG,YAClB2L,MArBU,SAACnL,GACb,IAAMoB,EAAIwR,WAAW5S,GACrB,OAAIiM,MAAM7K,GACD,CAAEqE,OAAO,EAAOoG,OAAQ,yBAErB9F,IAARzE,GAAqBF,EAAIE,EACpB,CACLmE,OAAO,EACPoG,OAAO,oCAAD,OAAsCvK,SAGpCyE,IAAR1E,GAAqBD,EAAIC,EACpB,CAAEoE,OAAO,EAAOoG,OAAO,iCAAD,OAAmCxK,IAE3D,CAAEoE,OAAO,EAAMf,MAAOtD,IAQ3BuD,SAAUpF,EAAOoF,SACjBD,MAAOnF,EAAOmF,MAAMe,MAAQlG,EAAOmF,MAAMA,WAAQqB,OC9E5C8M,GAAsB,CACjC/H,GACAzG,EACA6H,GACAU,GACAG,GACAG,GACAI,GACAnK,GACAwK,GACAE,GACAQ,GACAI,GACAI,GACAE,GACAqC,GACAc,GACAtO,GC1CoBxE,EAAe,CACnCE,KAAM,SACNE,YAAa,qCACbD,OAAQ,CACNoT,GAAW,CACTrT,KAAM,YACNwG,aAAc,GACdtG,YAAa,2CAEfwM,GAAS,CACP1M,KAAM,SACNwG,aAAc,EACdxE,IAAK,EACL9B,YAAa,iDAGjBC,GAAI,gBAAGgC,EAAH,EAAGA,MAAOuB,EAAV,EAAUA,WAAV,OACFV,EAAUb,GAAO,SAACkB,EAAMO,EAAYC,GAAgB,IAAD,cACrBH,EADqB,GAC1C8P,EAD0C,KAC/BC,EAD+B,KAG3CnR,EAASH,EAAMD,WAAW,GAC1BwR,EAAS9P,EAAaC,EAAc,EAAIvC,KAAKwL,GACnD,OAAOxJ,EAAUnB,EAAMD,YAAY,YAAa,IAAD,mBAAVK,EAAU,KAAPC,EAAO,KACvCmR,EAASrS,KAAKI,MAClB8R,EAAYlS,KAAKuL,IAAKrK,EAAIF,EAAUmR,EAASnS,KAAKwL,GAAK4G,IAGzD,OAAOzR,EAAmBE,EAAMD,WAAYmB,EAAM,CAACd,EAAIoR,EAAQnR,aC5BjD1C,EAAe,CACnCE,KAAM,SACNE,YAAa,+CACbD,OAAQ,CACNsG,EAAc,CACZvG,KAAM,YACNwG,cAAe,EACfrB,QAAS,CACP,CAAEnF,KAAM,YAAaoF,OAAQ,GAC7B,CAAEpF,KAAM,oBAAqBoF,MAAO,OAI1CjF,GAAIsD,GACF,YAOO,IANLvB,EAMI,EANJA,WACAE,EAKI,EALJA,MACAyB,EAII,EAJJA,WACAD,EAGI,EAHJA,WACAE,EAEI,EAFJA,YACAJ,EACI,EADJA,WAEOkQ,EADH,YACWlQ,EADX,MAEEoK,EAAU5L,EAAW,GAAK,EAC1B6L,EAAU7L,EAAW,GAAK,EAH5B,cAIWE,EAJX,GAKEmQ,EALF,KAKmBzE,EACjB0E,EANF,KAMmBzE,EAEjB8F,EAAUjQ,EAAaC,GAAe+P,GAAQ,GAC9CjG,EAAMrM,KAAKqM,IAAI,EAAIrM,KAAKwL,GAAK+G,GAC7BhH,EAAMvL,KAAKuL,IAAI,EAAIvL,KAAKwL,GAAK+G,GAOnC,OAAO/P,EALiB,CACtBxC,KAAKI,MAAMoM,EAAUyE,EAAa5E,EAAM6E,EAAa3F,GACrDvL,KAAKI,MAAMqM,EAAUyE,EAAa7E,EAAM4E,EAAa1F,UCpCtC/M,EAAe,CACpCE,KAAM,UACNE,YAAa,sBACbD,OAAQ,GACRE,GAAI,gBAAGgC,EAAH,EAAGA,MAAH,OACFa,EAAUb,GAAO,SAACkB,EAAMO,EAAYC,GAClC,IAAMpB,EAAMmB,EAAaC,EAMnBiQ,EAAQxS,KAAKC,MAAY,EAANkB,GACnBsR,EAA+B,GAAnBtR,EAAMqR,EAAQ,GAE1BE,EAAY1S,KAAKwL,GAAK,EAAK,GAE3BoB,EACM,IAAV4F,EACI,EACU,IAAVA,EACAC,EAAWC,EACD,IAAVF,EACAE,GACC,EAAID,GAAYC,EAEjBrG,EAAMrM,KAAKqM,IAAa,MAARO,GAChBrB,EAAMvL,KAAKuL,IAAa,MAARqB,GAEhB+F,EAAqC,IAAtB9R,EAAMD,WAAW,GAChCgS,EAAqC,GAAtB/R,EAAMD,WAAW,GAEtC,OAAOoB,EAAUnB,EAAMD,YAAY,SAACE,GAAW,IAAD,cAC7BA,EAD6B,GACrCG,EADqC,KAClCC,EADkC,KAEtC+P,EAAajR,KAAKC,MAAMgB,EAAI0R,EAAe,EAAI3S,KAAKuL,IAAIqB,IACxDsE,EAAalR,KAAKC,MAAMiB,EAAI0R,EAAe,EAAI5S,KAAKqM,IAAIO,IAExDiG,EAAkB,CACtB7S,KAAKI,MAAMuS,EAAe1B,EAAa5E,EAAM6E,EAAa3F,GAC1DvL,KAAKI,MAAMwS,EAAe1B,EAAa7E,EAAM4E,EAAa1F,IAG5D,OAAO5K,EAAmBE,EAAMD,WAAYmB,EAAM8Q,YCzChCrU,EAAe,CACvCE,KAAM,cACNE,YAAa,oDACbD,OAAQ,CACNyM,GAAS,CACP1M,KAAM,QACNwG,aAAc,IACdxE,IAAK,IAEP0K,GAAS,CACP1M,KAAM,SACNwG,aAAc,IACdxE,IAAK,KAGT7B,GAAI,YAA4B,IAAzBgC,EAAwB,EAAxBA,MAAOuB,EAAiB,EAAjBA,WAAiB,cACCA,EADD,GACtBa,EADsB,KACZC,EADY,KAE7B,OAAOF,EAAY,CACjBnC,QACAoC,WACAC,iBCpBe1E,EAAe,CAClCE,KAAM,QACNE,YAAa,sCACbD,OAAQ,CAACoT,GAAW,CAAErT,KAAM,YAAawG,aAAc,GAAIxE,IAAK,KAChE7B,GAAIsD,GAAS,YAAiE,IAA9DrB,EAA6D,EAA7DA,MAAOyB,EAAsD,EAAtDA,WAAYD,EAA0C,EAA1CA,WAAYE,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WACnD8P,EADoE,YACvD9P,EADuD,oBAE5DtB,EAF4D,GAEpEG,EAFoE,KAEjEC,EAFiE,KAO3E,OAAOsB,EAAY,CAHjBvB,EACAjB,KAAKI,MAAM8R,EAAYlS,KAAKqM,IAAK/J,EAAaC,EAAc,EAAIvC,KAAKwL,KAE1CtK,SCXF1C,EAAe,CAC5CE,KAAM,mBACNE,YAAa,mDACbD,OAAQ,CACN4Q,GAAiB,CACf7Q,KAAM,mBACNwG,aAAc1F,EAAa,cAG/BX,GAAIsD,GAAS,YAAyC,IAAtCrB,EAAqC,EAArCA,MAAO0B,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAC3BW,EAD4C,YACnCX,EADmC,MAE7C8J,EAAI1J,EAAY1B,GACtB,OAAOlB,EAAcsM,GAAKnJ,EAAQmJ,OCZf1N,EAAe,CACpCE,KAAM,SACNE,YAAa,kCACbD,OAAQ,CACNoN,GAAY,CACVrN,KAAM,WACNE,YAAa,sDACbsG,aAAc,GACdxE,IAAK,EACLD,IAAK,IACLiL,KAAM,KAGV7M,GAAIsD,GAAS,YAAiD,IAA9CrB,EAA6C,EAA7CA,MAAO0B,EAAsC,EAAtCA,YAAaJ,EAAyB,EAAzBA,WAAYrC,EAAa,EAAbA,OACvC+S,EADoD,YACxC1Q,EADwC,MAErDwH,EAAMpH,EAAY1B,GAExB,GAAIlB,EAAcgK,GAChB,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,IAAMmJ,EAAW/S,KAAKgT,KAAgB,IAAXjT,KAAkB+S,EACvCG,EAAOjT,KAAKgT,KAAgB,IAAXjT,KAEvB,OAAOgT,EAAW,CAACE,EAAMA,EAAMA,EAAMrJ,EAAI,IAAMA,OCxBnBpL,EAAe,CAC7CE,KAAM,oBACNE,YAAa,uCACbD,OAAQ,CACNoN,GAAY,CACVrN,KAAM,WACNE,YAAa,sDACbsG,aAAc,GACdxE,IAAK,EACLD,IAAK,IACLiL,KAAM,KAGV7M,GAAIsD,GAAS,YAAiD,IAA9CrB,EAA6C,EAA7CA,MAAO0B,EAAsC,EAAtCA,YAAaJ,EAAyB,EAAzBA,WAAYrC,EAAa,EAAbA,OACvC+S,EADoD,YACxC1Q,EADwC,MAErDwH,EAAMpH,EAAY1B,GAExB,GAAIlB,EAAcgK,GAAM,CACtB,IAAMsJ,EAAUlT,KAAKgT,KAAgB,IAAXjT,KAAkB+S,EACtCG,EAAOjT,KAAKgT,KAAgB,IAAXjT,KAEvB,OAAOmT,EAAU,CAACD,EAAMA,EAAMA,EAAM,KAAOrJ,EAG7C,OAAOA,OCvBqBpL,EAAe,CAC7CE,KAAM,oBACNE,YACE,yEACFD,OAAQ,CACN4Q,GAAiB,CACf7Q,KAAM,oBACNwG,aAAc1F,EAAa,aAE7BuM,GAAY,CACVrN,KAAM,YACNE,YACE,uGACFsG,aAAc,GACdxE,IAAK,EACLD,IAAK,IACLiL,KAAM,KAGV7M,GAAIsD,GAAS,YAAyC,IAAtCrB,EAAqC,EAArCA,MAAO0B,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAAiB,cACxBA,EADwB,GAC5CW,EAD4C,KACrCoQ,EADqC,KAE7CjH,EAAI1J,EAAY1B,GAChBsS,EAAQlH,EAAE,GAAKnJ,EAAM,GACrBsQ,EAAQnH,EAAE,GAAKnJ,EAAM,GACrBuQ,EAAQpH,EAAE,GAAKnJ,EAAM,GAE3B,OADa/C,KAAK0R,KAAK0B,EAAQA,EAAQC,EAAQA,EAAQC,EAAQA,GACnD,IAAO,KAAOH,EACjB,CAACjH,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAI,GAErBA,OC9Bc1N,EAAe,CACtCE,KAAM,YACNE,YAAa,2CACbD,OAAQ,CACNyM,GAAS,CAAE1M,KAAM,IAAKwG,aAAc,IACpCkG,GAAS,CAAE1M,KAAM,IAAKwG,aAAc,KAEtCrG,GAAIsD,GAAS,YAAyC,IAAtCrB,EAAqC,EAArCA,MAAO0B,EAA8B,EAA9BA,YAAaJ,EAAiB,EAAjBA,WAAiB,cAC1BA,EAD0B,GAC5CmR,EAD4C,KACpCC,EADoC,mBAEpC1S,EAFoC,GAInD,OAAO0B,EAAY,CAJgC,KAI3B+Q,EAJ2B,KAIfC,UV2CtCC,MAAK,SAACxS,EAAGC,GAAJ,OAAWD,EAAEvC,KAAOwC,EAAExC,KAAO,GAAK,KAE5BgV,GAAkB,SAAChV,GAC9B,IAAMqG,EAAIkN,GAAoB0B,MAAK,SAAC5O,GAAD,OAAOA,EAAErG,OAASA,KAErD,OADA2C,EAAO0D,GACAA,G,oBW7BH6O,GAAW7H,GAAY,CAC3BrN,KAAM,oBACNwG,aAHkB,GAIlBxE,IAAK,EACLD,IAAK,KAGMoT,GAAwC,SAAC,GAM/C,IALLC,EAKI,EALJA,QACAC,EAII,EAJJA,gBACAC,EAGI,EAHJA,aACAC,EAEI,EAFJA,WACAC,EACI,EADJA,WACI,EACsB1J,IAAMC,SAAuB,CACrD0J,SAAS,EACTC,QAAS,GACTC,iBAAalP,IAJX,mBACGmP,EADH,KACUC,EADV,OAMgC/J,IAAMC,UAAS,GAN/C,mBAMG+J,EANH,KAMeC,EANf,OAOkBjK,IAAMC,SArBV,IAcd,mBAOGlF,EAPH,KAOQmP,EAPR,KASEC,EAAiBZ,IAAoBS,EAE3C,OACE,eAACxQ,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,KAApB,wBAEA,qBAAK0K,MAAO,CAAE1F,SAAU,SAAxB,SACGwK,GAAS/U,GAAG,CACXiF,MAAO,CAAEe,OAAO,EAAMf,MAAOyB,GAC7BxB,SAAU,SAAC9C,GACLA,EAAE4D,QACJ6P,EAAOzT,EAAE6C,OACT2Q,GAAc,SAKtB,cAACxL,GAAA,EAAD,CACE7E,QAAQ,YACR+E,GAAI,CAAEC,SAAU,SAChBwL,QACGN,EAAMH,UAAYL,IAAWU,OAE1BrP,EADF,cAACZ,EAAA,EAAD,4BAGJsQ,SAAUF,EACV9F,QAAO,sBAAE,4BAAAvO,EAAA,sDACDwU,EAAkBb,EAAWpS,KACjC,SAACkD,GAAD,MAA6B,CAC3BgB,UAAW2N,GAAgB3O,EAAEgQ,eAC7BpW,OAAQoG,EAAEiQ,aAAanT,KAAI,SAACqK,GAE1B,OADA7K,EAAO6K,EAAErH,OACFqH,EAAEpI,aAIfyQ,EAAS,CAAEJ,SAAS,IACpBc,WAAU,sBAAC,gCAAA3U,EAAA,sEAEPe,EACE2S,EACA,oDAEIkB,EAAQC,KAAKC,MANZ,SAOYhQ,EACjB4O,EACAc,EACAvP,GAVK,OAOD8P,EAPC,OAYDhB,EAAcrU,KAAKgT,MAAMmC,KAAKC,MAAQF,GAAS,KACrDX,EAAS,CACPJ,SAAS,EACTE,cACAD,QAASiB,EAAKxT,KAAI,SAAC8E,EAAKxF,GAAN,MAAe,CAC/B4T,cAAed,EAAW9S,GAAK4T,cAC/BpO,YAGJ8N,GAAc,GACdP,IAtBO,kDAwBPoB,QAAQvK,MAAR,MACAuK,QAAQvK,MAAM,KAAIwK,OAzBX,2DAXJ,2CATX,SAkDGjB,EAAMH,QAAU,cAACqB,GAAA,EAAD,CAAkBzS,MAAM,YAAe,aAExDuR,EAAMH,SAAWG,EAAMD,aACvB,qCACE,cAACoB,EAAA,EAAD,IACA,eAACtR,EAAA,EAAD,CAAYC,QAAQ,UAApB,2BACiBkQ,EAAMD,YADvB,oBAMFC,EAAMH,SAAWG,EAAMF,QAAQ7U,OAAS,GACxC,qCACE,cAACkW,EAAA,EAAD,IACA,cAACC,GAAA,EAAD,CACEC,WAAS,EACT1R,QAAS,EACT2R,QAAS,EACTC,QAAS,CAAEC,GAAI,EAAGC,GAAI,EAAGC,GAAI,IAJ/B,SAMG1B,EAAMF,QAAQvS,KAAI,WAAyBV,GAAzB,IAAGwF,EAAH,EAAGA,IAAKoO,EAAR,EAAQA,cAAR,OACjB,eAACW,GAAA,EAAD,CAAMO,MAAI,EAACH,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAA7B,UACE,cAAC7R,EAAA,EAAD,CAAYC,QAAQ,YAApB,SAAiC2Q,IACjC,qBAAKnL,IAAKjD,EAAKkD,IAAG,cAASkL,EAAT,YAA0B5T,oB,UCnH/C+U,GAAgD,SAAC,GAQvD,IAPLC,EAOI,EAPJA,kBACAC,EAMI,EANJA,mBACAC,EAKI,EALJA,MACAC,EAII,EAJJA,SACAC,EAGI,EAHJA,SACAC,EAEI,EAFJA,WACAC,EACI,EADJA,YAEA,OACE,cAAC1G,EAAA,EAAD,CAAOjB,MAAO,CAAE8G,QAAS,GAAKc,UAAW,EAAzC,SACE,eAAC1S,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,eAACD,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,YAApB,SAAiCiS,EAAQ,IACzC,cAAChS,EAAA,EAAD,CAASC,MAAM,mBAAf,SACE,cAAC6L,GAAA,EAAD,CAAYvE,aAAW,SAASiD,QAAS0H,EAAzC,SACE,cAAChS,EAAA,EAAD,yBAGJ,cAACF,EAAA,EAAD,CAASC,MAAM,sBAAf,SACE,cAAC6L,GAAA,EAAD,CACEvE,aAAW,SACXiD,QAAS2H,EACT3B,UAAW2B,EAHb,SAKE,cAACjS,EAAA,EAAD,+BAGJ,cAACF,EAAA,EAAD,CAASC,MAAM,uBAAf,SACE,cAAC6L,GAAA,EAAD,CACEvE,aAAW,SACXiD,QAAS4H,EACT5B,UAAW4B,EAHb,SAKE,cAAClS,EAAA,EAAD,mCAIN,cAACP,EAAA,EAAD,CAAOE,UAAU,MAAMD,QAAS,EAAhC,SACE,cAACQ,EAAA,EAAD,CAAakS,WAAS,EAAtB,SACE,cAACC,GAAA,EAAD,CACEC,kBAAgB,EAChB/S,MAAOqS,EAAkBpQ,UAAUrH,KACnCmF,QAASuS,EAAmBvU,KAAI,SAACkD,GAAD,OAAOA,EAAErG,QACzCqF,SAAU,SAACa,EAAOkS,GAChB,IAAM/R,EAAIqR,EAAmBzC,MAC3B,SAAC5O,GAAD,OAAOA,EAAErG,OAASoY,KAGpBR,EAAS,CACPvQ,UAAWhB,EACXgS,YAAahS,EAAEpG,OAAOkD,KACpB,SAACqK,GAAD,OAA2BA,EAAEhH,mBAInC8R,YAAa,SAACrY,GAAD,OACX,cAACmM,GAAA,EAAD,2BAAenM,GAAf,IAAuBsY,MAAM,sBAKpCd,EAAkBpQ,UAAUnH,aAC3B,cAACuF,EAAA,EAAD,CAAYC,QAAQ,UAApB,SACG+R,EAAkBpQ,UAAUnH,cAGhCuX,EAAkBpQ,UAAUpH,OAAOY,OAAS,GAC3C,cAAC4E,EAAA,EAAD,CAAYC,QAAQ,YAApB,wBAEF,cAACJ,EAAA,EAAD,CAAOkT,QAAS,cAACzB,EAAA,EAAD,IAAaxR,QAAS,EAAtC,SACGkS,EAAkBpQ,UAAUpH,OAAOkD,KAIlC,SAAC+N,EAA2BzO,GAC1B,IAAM6O,EAAMJ,EAAM/Q,GAAG,CACnBiF,MAAOqS,EAAkBY,YAAY5V,GACrC4C,SAAU,SAAC4L,GACT2G,EAAS,2BACJH,GADG,IAENY,YAAaZ,EAAkBY,YAAYlV,KAAI,SAACZ,EAAG4B,GACjD,OAAIA,IAAM1B,EACDwO,EAEF1O,WAKf,OACE,cAAC,IAAMkW,SAAP,UAGGnH,GAHH,UACUmG,EAAkBpQ,UAAUrH,KADtC,YAC8CkR,EAAMlR,kBC/GvD0Y,GAAmD,SAAC,GAAD,IAC9DC,EAD8D,EAC9DA,kBACAjB,EAF8D,EAE9DA,mBACAkB,EAH8D,EAG9DA,mBAH8D,OAK9D,eAACtT,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,KAApB,8BACA,eAACsR,GAAA,EAAD,CAAMC,WAAS,EAAC1R,QAAS,EAAG2R,QAAS,EAAGC,QAAS,CAAEC,GAAI,EAAGC,GAAI,EAAGC,GAAI,IAArE,UACGqB,EAAkBxV,KAAI,SAACkD,EAAGwS,GAAJ,OACrB,cAAC7B,GAAA,EAAD,CAAMO,MAAI,EAACH,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAA7B,SACE,cAAC,GAAD,CACEK,MAAOkB,EACPnB,mBAAoBA,EACpBD,kBAAmB,CACjBpQ,UAAW2N,GAAgB3O,EAAEgQ,eAC7BgC,YAAahS,EAAEiQ,cAEjBuB,SAAU,kBACRe,EACED,EAAkBhH,QAAO,SAACmH,EAAOC,GAAR,OAAmBA,IAAWF,OAG3Df,WACEe,EAAO,EACH,kBACED,EACED,EAAkBxV,KAAI,SAAC2V,EAAOC,GAC5B,OAAIA,IAAWF,EAAO,EAEbF,EAAkBI,EAAS,GACzBF,IAASE,EAEXJ,EAAkBE,EAAO,GAEzBC,YAIfrS,EAENsR,YACEc,EAAOF,EAAkB9X,OAAS,EAC9B,kBACE+X,EACED,EAAkBxV,KAAI,SAAC2V,EAAOC,GAC5B,OAAIA,IAAWF,EAAO,EAEbF,EAAkBI,EAAS,GACzBF,IAASE,EAEXJ,EAAkBE,EAAO,GAEzBC,YAIfrS,EAENmR,SAAU,SAACoB,GAAD,OACRJ,EACED,EAAkBxV,KAAI,SAAC2V,EAAOG,GAC5B,OAAIJ,IAASI,EAEJ,CACL5C,cAAe2C,EAAS3R,UAAUrH,KAClCsW,aAAc0C,EAASX,YACvBa,mBAAezS,GAIZ,CACL4P,cAAeyC,EAAMzC,cACrBC,aAAcwC,EAAMxC,aACpB4C,mBAAezS,eAQ7B,cAACuQ,GAAA,EAAD,CAAMO,MAAI,EAACH,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAA7B,SACE,cAAChS,EAAA,EAAD,CAAOC,QAAS,EAAhB,SACE,cAACgF,GAAA,EAAD,CACE0N,WAAW,EACXvS,QAAQ,YACR8E,UAAW,cAAC3E,EAAA,EAAD,kBACXsK,QAAS,kBACPyI,EAAmB,GAAD,mBACbD,GADa,CAEhB,CACEtC,cAAeqB,EAAmB,GAAG1X,KACrCsW,aAAcoB,EAAmB,GAAGzX,OAAOkD,KACzC,SAACqK,GAAD,OAA2BA,EAAEhH,qBAVvC,sC,oBC9EG2S,GAA4C,SAAC,GAGnD,IAFLvD,EAEI,EAFJA,MACAwD,EACI,EADJA,SACI,EACoBtN,IAAMC,WAD1B,mBACGsN,EADH,KACSC,EADT,OAE4BxN,IAAMC,UAAS,GAF3C,mBAEGwN,EAFH,KAEcC,EAFd,KAIEC,EAAW,SAACC,GAChBJ,EAAQI,GACRnD,YAAW,kBAAM+C,OAAQ7S,KAAY,MAGjCkT,EAAY,WAChBH,GAAW,GACXjD,YAAW,kBAAMiD,GAAW,KAAQ,MAGtC,OACE,eAAClU,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,KAApB,2BACA,eAAC6E,GAAA,EAAD,CACE2L,QAAS,cAACrQ,EAAA,EAAD,0BACT4E,GAAI,CAAEC,SAAU,SAChBhF,QAAQ,YACRyK,QAAS,WACP,IAAMyJ,EAASC,oBACbC,KAAKC,UAAL,2BAAoBnE,GAApB,IAA2B3K,eAAWxE,MAExCuT,UAAUC,UAAUC,UAAUN,GAC9BH,EAAS,wBATb,iCAYsB,uBAZtB,wBAcA,eAAClP,GAAA,EAAD,CACE2L,QAAS,cAACrQ,EAAA,EAAD,0BACT4E,GAAI,CAAEC,SAAU,SAChBhF,QAAQ,YACRyK,QAAS,WACP,IAAMyJ,EAASC,oBAAoBC,KAAKC,UAAUnE,IAClDoE,UAAUC,UAAUC,UAAUN,GAC9BH,EAAS,wBAPb,iCAUsB,uBAVtB,yBAaA,cAAClP,GAAA,EAAD,CACE2L,QAAS,cAACrQ,EAAA,EAAD,4BACT4E,GAAI,CAAEC,SAAU,SAChBhF,QAAQ,YACRyK,QAAO,sBAAE,8BAAAvO,EAAA,+EAE2BoY,UAAUC,UAAUE,WAF/C,UAECC,EAFD,8BAIHT,IAJG,6BAOCtW,EAAOyW,KAAKjO,MAChBgO,wBAAwBO,IAErBnW,MAAMoW,QAAQhX,EAAKkS,YAVnB,wBAWHoE,IAXG,2BAcLP,EAAS/V,GACTmW,GAAW,GAfN,kDAiBL5C,QAAQvK,MAAR,MACAsN,IAlBK,0DAJX,mCA4BCN,GACC,cAACiB,GAAA,EAAD,CAAOC,SAAS,OAAO9P,GAAI,CAAEC,SAAU,SAAvC,SACG2O,IAGJE,GACC,cAACe,GAAA,EAAD,CAAOC,SAAS,QAAQ9P,GAAI,CAAEC,SAAU,SAAxC,gDC9EK8P,GAAgB,WAAO,IAAD,EACP1O,IAAMC,SAAmB,CACjD0O,OAAO,EACPlF,WAAY,GACZtK,eAAWxE,IAJoB,mBAC1BmP,EAD0B,KACnBC,EADmB,KAWjC,IAAM6E,GACH9E,EAAM3K,WACqB,IAA5B2K,EAAML,WAAW1U,SAChB+U,EAAM6E,OACP7E,EAAML,WAAWoF,MAAK,SAACtU,GAGrB,OAFe2O,GAAgB3O,EAAEgQ,eAC9BpW,OAEMY,OAAS,GAAKwF,EAAEiQ,aAAasE,OAAM,SAACpN,EAAGrJ,GAAJ,OAAsB,IAAZqJ,EAAErH,YAI5D,OACE,qCACE,cAAC0U,EAAA,EAAD,IACA,cAACC,EAAA,EAAD,UACE,eAACxV,EAAA,EAAD,CAAOC,QAAS,EAAGwV,eAAe,eAAevC,QAAS,cAACzB,EAAA,EAAD,IAA1D,UACE,cAACtR,EAAA,EAAD,CAAYC,QAAQ,KAAKsV,GAAI,EAA7B,uBAGA,eAAC1V,EAAA,EAAD,CAAOC,QAAS,EAAGiT,QAAS,cAACzB,EAAA,EAAD,IAA5B,UACE,cAAC1F,EAAA,EAAD,CAAOjB,MAAO,CAAE8G,QAAS,IAAzB,SACE,eAAC5R,EAAA,EAAD,CAAOC,QAAS,EAAhB,UACE,cAACE,EAAA,EAAD,CAAYC,QAAQ,KAApB,0BACA,cAAC,GAAD,CACE1F,KAAK,wBACLsK,gBAAiBsL,EAAM3K,UACvB5F,SAAU,SAAC4F,GACT4K,EAAS,2BACJD,GADG,IAEN3K,YACAwP,OAAO,aAMjB,cAACpJ,EAAA,EAAD,CAAOjB,MAAO,CAAE8G,QAAS,IAAzB,SACE,cAAC,GAAD,CACEyB,kBAAmB/C,EAAML,WACzBmC,mBAAoBnE,GACpBqF,mBAAoB,SAACrD,GAAD,OAClBM,EAAS,2BACJD,GADG,IAEN6E,OAAO,EACPlF,qBAKR,cAAClE,EAAA,EAAD,CAAOjB,MAAO,CAAE8G,QAAS,IAAzB,SACE,cAAC,GAAD,CACE9B,QAASQ,EAAM6E,MACfnF,aAAcM,EAAM3K,UACpBoK,gBAAiBqF,EACjBnF,WAAYK,EAAML,WAClBC,WAAY,kBACVK,EAAS,2BACJD,GADG,IAEN6E,OAAO,UAKf,cAACpJ,EAAA,EAAD,CAAOjB,MAAO,CAAE8G,QAAS,IAAzB,SACE,cAAC,GAAD,CACEtB,MAAOA,EACPwD,SAAU,SAAC6B,GAAD,OAAcpF,EAAS,2BAAKoF,GAAN,IAAgBR,OAAO,UAhFzD,MAwFF,mBACES,KAAK,4CACL9U,OAAO,SACP+U,IAAI,aAHN,SAKE,qBACEjQ,IAAI,4EACJ7I,MAAO,GACPC,OAAQ,GACR6I,IAAI,8BC/GpBiQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.96ce9d24.chunk.js","sourcesContent":["import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\nexport type Frame = {\n  data: ImageData;\n};\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: Frame[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface TransformFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport type ParamValue<T> = { valid: true; value: T } | { valid: false };\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: ParamValue<T>;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nexport type ParamFunction<T> = {\n  name: string;\n  defaultValue: ParamValue<T>;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type TransformFn<Params> = (opts: TransformFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Transform<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}\n\nexport interface TransformWithParams<T extends readonly ParamFunction<any>[]> {\n  transformName: string;\n  paramsValues: ParamValue<T>[];\n}\n\nexport interface TransformInput<T extends ParamFunction<any>[]> {\n  transform: Transform<T>;\n  params: T;\n}\n\nexport const buildTransform = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}): Transform<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  fn: args.fn,\n});\n\nexport interface AppState {\n  baseImage?: string;\n  transforms: {\n    transformName: string;\n    paramsValues: ParamValue<any>[];\n    computedImage?: string;\n  }[];\n  dirty: boolean;\n}\n","import seedrandom from 'seedrandom';\nimport { AssertionError } from 'assert';\n\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  ImageData,\n  Image,\n  Random,\n  TransformFn,\n  TransformFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => {\n  const clamp = (n: number) => Math.max(Math.min(n, 255), 0);\n\n  return [clamp(r), clamp(g), clamp(b), clamp(a)];\n};\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return [0, 0, 0, 0]; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => {\n  const frames = image.frames.map((frame, idx) => ({\n    data: cb(frame.data, idx, image.frames.length),\n  }));\n  return {\n    dimensions: image.dimensions,\n    frames,\n  };\n};\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/** Create a new array [0, 1, 2, ...N-1] */\nexport const repeat = (times: number): number[] =>\n  [...new Array(times)].map((_, i) => i);\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\nexport const writePixel = (args: {\n  image: ImageData;\n  dimensions: Dimensions;\n  coord: Coord;\n  color: Color;\n}): void => {\n  const idx = getImageIndex(args.dimensions, args.coord[0], args.coord[1]);\n  args.image[idx] = args.color[0];\n  args.image[idx + 1] = args.color[1];\n  args.image[idx + 2] = args.color[2];\n  args.image[idx + 3] = args.color[3];\n};\n\nexport const resizeImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newDimensions: Dimensions = [newWidth, newHeight];\n\n  const newFrames = image.frames.map((frame) => {\n    const transformedImageData = new Uint8Array(newWidth * newHeight * 4);\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const pixel = getPixelFromSource(image.dimensions, frame.data, [\n          srcX,\n          srcY,\n        ]);\n        writePixel({\n          color: pixel,\n          coord: [x, y],\n          dimensions: newDimensions,\n          image: transformedImageData,\n        });\n      }\n    }\n    return {\n      data: transformedImageData,\n    };\n  });\n\n  return {\n    frames: newFrames,\n    dimensions: [newWidth, newHeight],\n  };\n};\n","import { buildTransform, Color } from '../domain/types';\nimport { mapImage, isTransparent } from '../domain/utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const backgroundParty = buildTransform({\n  name: 'Background Party',\n  description: 'Transparent pixels will flash bright party colors',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    // Make the transparent parts colorful\n    if (isTransparent(srcPixel)) {\n      const partyColorIdx = Math.floor(\n        (frameIndex / frameCount) * PARTY_COLORS.length\n      );\n      return PARTY_COLORS[partyColorIdx];\n    }\n\n    return srcPixel;\n  }),\n});\n","import {\n  Tooltip,\n  Icon,\n  FormControl,\n  Select,\n  MenuItem,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: any }[];\n  value?: any;\n  description?: string;\n  onChange: (v: ParamValue<any>) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <FormControl>\n        <Select\n          autoWidth\n          value={value}\n          onChange={(event) =>\n            onChange({ valid: true, value: event.target.value })\n          }\n        >\n          {options.map((t) => (\n            <MenuItem key={t.value} value={t.value}>\n              {t.name}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function dropdownParam<T>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue?: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          options={args.options}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\n\nimport { Color, TransformInput, Image, Dimensions, ImageData } from './types';\nimport {\n  toHexColor,\n  getPixelFromSource,\n  randomColor,\n  fromHexColor,\n  isTransparent,\n} from './utils';\n\n// Returns a list of gif data URLs, for each transform\nexport const runTransforms = async (\n  inputDataUrl: string,\n  transformList: TransformInput<any>[],\n  fps: number\n): Promise<string[]> => {\n  const random = seedrandom(inputDataUrl);\n\n  const originalImage = await readImage(inputDataUrl);\n\n  const images: Image[] = [];\n  transformList.reduce((image, transformInput) => {\n    const result = transformInput.transform.fn({\n      image,\n      parameters: transformInput.params,\n      random,\n    });\n    images.push(result);\n    return result;\n  }, originalImage);\n\n  return await Promise.all(\n    images.map(async (newImage) => {\n      const transparentColor = getTransparentColor(newImage, random);\n\n      // Transform any of our transparent pixels to what our gif understands to be transparent\n      const image = encodeTransparency(\n        newImage.frames.map((f) => f.data),\n        transparentColor\n      );\n\n      return await createGif(newImage.dimensions, image, transparentColor, fps);\n    })\n  );\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  frames: ImageData[],\n  transparentColor: Color | undefined\n): ImageData[] => {\n  const image = frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = transparentColor[3];\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 255; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return image;\n};\n\nconst createGif = async (\n  dimensions: Dimensions,\n  frames: ImageData[],\n  transparentColor: Color | undefined,\n  fps: number\n): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, getPixelResults: { shape: Dimensions; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        } else {\n          return res({\n            frames: [\n              {\n                data: Uint8Array.from(getPixelResults.data),\n              },\n            ],\n            dimensions: [getPixelResults.shape[0], getPixelResults.shape[1]],\n          });\n        }\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame.data, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import { Button, Icon, Stack } from '@material-ui/core';\nimport React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  width,\n  height,\n  onChange,\n}) => (\n  <Stack spacing={4}>\n    <Button\n      startIcon={<Icon>image</Icon>}\n      sx={{ maxWidth: '300px' }}\n      variant=\"contained\"\n      component=\"label\"\n    >\n      {name}\n      <input\n        type=\"file\"\n        hidden\n        accept=\"image/png,image/jpg\"\n        name=\"source-png\"\n        onChange={async (event) => {\n          const files = Array.from(event.target.files ?? []);\n          const file = files[0];\n          const baseImage = await readFile(file);\n          onChange(baseImage);\n        }}\n      />\n    </Button>\n    {currentImageUrl && (\n      <img\n        width={width}\n        height={height}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </Stack>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import { dropdownParam } from '../params/dropdownParam';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { buildTransform } from '../domain/types';\nimport {\n  isTransparent,\n  getPixelFromSource,\n  mapFrames,\n  mapCoords,\n  resizeImage,\n} from '../domain/utils';\n\nexport const backgroundImage = buildTransform({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    dropdownParam({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ] as const,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const otherImage = resizeImage({\n      image: parameters[0].image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n    });\n    const type = parameters[1];\n\n    return mapFrames(image, (data) => {\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n        const otherImageSrc = getPixelFromSource(\n          otherImage.dimensions,\n          otherImage.frames[0].data,\n          coord\n        );\n\n        if (type === 'background') {\n          // Only print the other image if the src image is transparent here\n          return isTransparent(src) ? otherImageSrc : src;\n        } else {\n          return isTransparent(otherImageSrc) ? src : otherImageSrc;\n        }\n      });\n    });\n  },\n});\n","import React from 'react';\n\nimport { readImage } from '../domain/run';\nimport { ParamFunction, Image } from '../domain/types';\nimport { ImagePicker } from '../components/ImagePicker';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<{ dataUrl: string; image: Image }> {\n  return {\n    name,\n    defaultValue: { valid: false },\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={\n          params.value.valid ? params.value.value.dataUrl : undefined\n        }\n        name={name}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ valid: true, value: { dataUrl, image } });\n        }}\n      />\n    ),\n  };\n}\n","import {\n  FormControl,\n  FormHelperText,\n  Icon,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          defaultValue={value}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildTransform({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [x, y] = coord;\n    const yOffset =\n      y +\n      Math.round(\n        parameters[0] * Math.sin((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([x, yOffset]);\n  }),\n});\n","import { Icon, Slider, Stack, Tooltip, Typography } from '@material-ui/core';\nimport React from 'react';\n\nimport { ParamValue, ParamFunction } from '../domain/types';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <Stack direction=\"row\" spacing={2}>\n        <Slider\n          aria-label={name}\n          defaultValue={value}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) =>\n            onChange({ valid: true, value: value as number })\n          }\n        />\n        <Typography variant=\"body2\">{value}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue:\n      args.defaultValue !== undefined\n        ? { valid: true, value: args.defaultValue }\n        : { valid: false },\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage, clampColor } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const brightness = buildTransform({\n  name: 'Brightness',\n  description: 'Increase or decrease the brightness of the image',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      defaultValue: 0,\n      min: -100,\n      max: 100,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [amount] = parameters;\n    const rawAmount = (amount / 100) * 255;\n    const p = getSrcPixel(coord);\n    return clampColor([\n      p[0] + rawAmount,\n      p[1] + rawAmount,\n      p[2] + rawAmount,\n      p[3],\n    ]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildTransform({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [radius] = parameters;\n    const [x, y] = coord;\n    const xOffset = Math.round(\n      radius * Math.sin(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    const yOffset = Math.round(\n      radius * Math.cos(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    return getSrcPixel([x + xOffset, y + yOffset]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildTransform({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const dist = Math.cos(idx * 2 * Math.PI) * parameters[0];\n\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const [width, height] = dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildTransform({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const expanding = idx < 0.5;\n      const [width, height] = dimensions;\n      const dist = (expanding ? idx : 1 - idx) * parameters[0];\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { Frame, buildTransform } from '../domain/types';\nimport { repeat } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const frameCount = buildTransform({\n  name: 'Frame Count',\n  description:\n    'Set how many frames of animation there will be. This is required for all animation transforms',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      defaultValue: 10,\n      min: 1,\n      max: 60,\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [frameCount] = parameters;\n\n    const currentFrames = image.frames;\n\n    // Resulting image will contain frameCount frames.\n    // If the original image had less than that, then we'll copy the last frame until we have enough.\n    // If the original has more frames, then we'll discard the last ones.\n    const frames = repeat(frameCount).map(\n      (i): Frame => ({\n        data: currentFrames[i]\n          ? currentFrames[i].data\n          : currentFrames[currentFrames.length - 1].data,\n      })\n    );\n\n    return {\n      dimensions: image.dimensions,\n      frames,\n    };\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent, getAveragePixelValue } from '../domain/utils';\n\nexport const grayscale = buildTransform({\n  name: 'Grayscale',\n  description: 'Make the image black and white',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [gray, gray, gray, 255];\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\n\nexport const hueParty = buildTransform({\n  name: 'Hue Party',\n  description: 'Shift through all the hues',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, frameCount, frameIndex }) => {\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [, s, l] = convert.rgb.hsl([r, g, b]);\n    const [newR, newG, newB] = convert.hsl.rgb([\n      (frameIndex / frameCount) * 255,\n      s,\n      l,\n    ]);\n    return [(r + newR) / 2, (g + newG) / 2, (b + newB) / 2, a];\n  }),\n});\n","import { Icon, Stack, Tooltip, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport * as convert from 'color-convert';\n\nimport { ParamValue, ParamFunction } from '../domain/types';\nimport { toHexColor } from '../domain/utils';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor =\n    value === undefined\n      ? undefined\n      : toHexColor([...convert.hsl.rgb([value, 255, 255]), 255]);\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        onChangeComplete={({ hsl }) => onChange({ valid: true, value: hsl.h })}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShift = buildTransform({\n  name: 'Hue Shift',\n  description: 'Shift the hue to some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 128,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [newHue] = parameters;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([newHue, s, l]);\n    return [newR, newG, newB, a];\n  }),\n});\n","import {\n  FormControl,\n  Icon,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value?: string;\n  description?: string;\n  onChange: (v: ParamValue<string>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <FormControl>\n        <TextField\n          defaultValue={value}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() =>\n            onChange(val ? { valid: true, value: val } : { valid: false })\n          }\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue?: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value.valid ? params.value.value : undefined}\n    />\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport seedrandom from 'seedrandom';\n\nimport { Color } from '../domain/types';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n  isTransparent,\n} from '../domain/utils';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildTransform({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const random = seedrandom(parameters[0]);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\n\nexport const nuke = buildTransform({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, frameCount, frameIndex }) => {\n    const threshold = (frameIndex / frameCount) * 255;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildTransform, Color } from '../domain/types';\nimport { isTransparent, getAveragePixelValue, mapImage } from '../domain/utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const party = buildTransform({\n  name: 'Party',\n  description: 'Make the image flash different colors',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const partyColorIdx = Math.floor(\n      (frameIndex / frameCount) * PARTY_COLORS.length\n    );\n    const partyColor = PARTY_COLORS[partyColorIdx];\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [\n      (gray * partyColor[0]) / 255,\n      (gray * partyColor[1]) / 255,\n      (gray * partyColor[2]) / 255,\n      255,\n    ];\n  }),\n});\n","import React from 'react';\nimport {\n  Collapse,\n  Icon,\n  Box,\n  Button,\n  ClickAwayListener,\n  Stack,\n} from '@material-ui/core';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Box>\n        <Button\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ textTransform: 'none' }}\n        >\n          <Stack direction=\"row\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'expand_less' : 'expand_more'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Box>\n    </ClickAwayListener>\n  );\n};\n","import { Icon, Stack, Tooltip, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\n\nimport { ParamValue, ParamFunction, Color } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value?: Color;\n  description?: string;\n  onChange: (v: ParamValue<Color>) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          {description && (\n            <Tooltip title={description}>\n              <Icon>help</Icon>\n            </Tooltip>\n          )}\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={value ? toHexColor(value) : undefined}\n        onChangeComplete={(c) =>\n          onChange({ valid: true, value: fromHexColor(c.hex) })\n        }\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue?: Color;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import {\n  Tooltip,\n  Icon,\n  IconButton,\n  Button,\n  Paper,\n  Typography,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ninterface VariableLengthProps<T> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value?: T[];\n  description?: string;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<\n    { param: ParamFunction<any>; pValue: any }[]\n  >(\n    value === undefined\n      ? []\n      : value.map((v, idx) => ({ param: createNewParam(), pValue: v }))\n  );\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          {description && (\n            <Tooltip title={description}>\n              <Icon>help</Icon>\n            </Tooltip>\n          )}\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: { valid: true, value: pValue },\n            onChange: (newValue) => {\n              if (newValue.valid) {\n                const p = params.map((oldP, i) => {\n                  if (idx === i) {\n                    return {\n                      param,\n                      pValue: newValue.value,\n                    };\n                  }\n                  return oldP;\n                });\n                setParams(p);\n                onChange({\n                  valid: true,\n                  value: p.map((n) => n.pValue),\n                });\n              }\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange({\n                    valid: true,\n                    value: newParams.map((n) => n.pValue),\n                  });\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue.valid ? p.defaultValue.value : undefined,\n              },\n            ];\n            setParams(newParams);\n            if (p.defaultValue.valid) {\n              onChange({\n                valid: true,\n                value: newParams.map((n) => n.pValue),\n              });\n            }\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue?: T[];\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value.valid ? params.value.value : undefined}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent, fromHexColor } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheel = buildTransform({\n  name: 'Pinwheel',\n  description: 'Create a pinwheel of colors',\n  params: [\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 40,\n    }),\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated. Positive integer',\n      defaultValue: 1,\n      min: 1,\n      max: 80,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      dimensions,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const [offsetX, offsetY, groupCount, colors] = parameters;\n\n      const ribbonCount = colors.length * groupCount;\n      const ribbonArcDegrees = Math.round(360 / ribbonCount);\n      // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n      //  won't get a smooth transition.\n      // We'll cut off colors from the end of the list until we get an even multiple.\n      let colorsLength = colors.length;\n      while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n        colorsLength -= 1;\n      }\n\n      // Make the transparent parts colorful\n      if (isTransparent(srcPixel)) {\n        const centerX = dimensions[0] / 2 + offsetX;\n        const centerY = dimensions[1] / 2 + offsetY;\n        const [x, y] = coord;\n        const xRelCenter = x - centerX;\n        const yRelCenter = y - centerY;\n\n        const pointAngle =\n          (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n\n        const colorIdx =\n          Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n        // Increment colorIdx based on current frame progress\n        const frameProgress = frameIndex / frameCount;\n        const idx =\n          (Math.floor(frameProgress * colorsLength) + colorIdx) % colorsLength;\n        return colors[idx];\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport {\n  isTransparent,\n  repeat,\n  fromHexColor,\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radiance = buildTransform({\n  name: 'Radiance',\n  description: 'Radiate colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated. Positive integer',\n      defaultValue: 1,\n      min: 1,\n      max: 90,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const [groupCount, colors] = parameters;\n    const colorList = repeat(groupCount).flatMap(() => colors);\n    const [width, height] = image.dimensions;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    return mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) => {\n        const srcPixel = getPixelFromSource(image.dimensions, imageData, coord);\n\n        // Make the transparent parts colorful\n        if (isTransparent(srcPixel)) {\n          const [x, y] = coord;\n          const xRelCenter = x - centerX;\n          const yRelCenter = y - centerY;\n\n          const maxDist = Math.sqrt(\n            (width / 2) * (width / 2) + (height / 2) * (height / 2)\n          );\n          const distFromCenter = Math.sqrt(\n            yRelCenter * yRelCenter + xRelCenter * xRelCenter\n          );\n\n          const colorIdx =\n            Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n            colorList.length;\n\n          // Increment colorIdx based on current frame progress\n          const frameProgress = frameIndex / frameCount;\n          const idx =\n            (Math.floor(frameProgress * colorList.length) + colorIdx) %\n            colorList.length;\n          return colorList[idx];\n        }\n\n        return srcPixel;\n      })\n    );\n  },\n});\n","import { buildTransform, Color, Dimensions } from '../domain/types';\nimport { getPixelFromSource, writePixel } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildTransform({\n  name: 'Resize Image',\n  description:\n    'Change the dimensions of the image. ' +\n    'If bigger than original, the extra space will be transparent. ' +\n    'If smaller, the image will be cropped. ',\n  params: [\n    intParam({ name: 'Width', defaultValue: 128, min: 0 }),\n    intParam({ name: 'Height', defaultValue: 128, min: 0 }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [width, height] = image.dimensions;\n    const [newWidth, newHeight] = parameters;\n\n    const newDimensions: Dimensions = [newWidth, newHeight];\n\n    const xPadding = (newWidth - width) / 2;\n    const yPadding = (newHeight - height) / 2;\n\n    const newFrames = image.frames.map((frame) => {\n      const transformedImageData = new Uint8Array(newWidth * newHeight * 4);\n      for (let y = 0; y < newHeight; y += 1) {\n        for (let x = 0; x < newWidth; x += 1) {\n          const pixel: Color =\n            x > xPadding &&\n            x < newWidth - xPadding &&\n            y > yPadding &&\n            y < newHeight - yPadding\n              ? getPixelFromSource(image.dimensions, frame.data, [\n                  x - xPadding,\n                  y - yPadding,\n                ])\n              : [0, 0, 0, 0];\n          writePixel({\n            color: pixel,\n            coord: [x, y],\n            dimensions: newDimensions,\n            image: transformedImageData,\n          });\n        }\n      }\n      return {\n        data: transformedImageData,\n      };\n    });\n\n    return {\n      frames: newFrames,\n      dimensions: newDimensions,\n    };\n  },\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Icon,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        {description && (\n          <Tooltip title={description}>\n            <Icon fontSize=\"small\">help</Icon>\n          </Tooltip>\n        )}\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          defaultValue={value}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { backgroundParty } from './background-party';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { brightness } from './brightness';\nimport { circle } from './circle';\nimport { expand } from './expand';\nimport { fisheye } from './fisheye';\nimport { frameCount } from './frame-count';\nimport { grayscale } from './grayscale';\nimport { hueParty } from './hue-party';\nimport { hueShift } from './hue-shift';\nimport { lightning } from './lightning';\nimport { nuke } from './nuke';\nimport { party } from './party';\nimport { pinwheel } from './pinwheel';\nimport { radiance } from './radiance';\nimport { resizeImage } from './resize-image';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { scaleImage } from './scale-image';\nimport { shake } from './shake';\nimport { solidBackground } from './solid-background';\nimport { staticc } from './static';\nimport { staticBackground } from './static-background';\nimport { transparentColor } from './transparent-color';\nimport { transpose } from './transpose';\n\nimport { assert } from '../domain/utils';\n\nexport const POSSIBLE_TRANSFORMS = [\n  backgroundImage,\n  backgroundParty,\n  bounce,\n  brightness,\n  circle,\n  expand,\n  fisheye,\n  frameCount,\n  grayscale,\n  hueParty,\n  hueShift,\n  lightning,\n  nuke,\n  party,\n  pinwheel,\n  radiance,\n  resizeImage,\n  ripple,\n  rotate,\n  roxbury,\n  scaleImage,\n  shake,\n  solidBackground,\n  staticc,\n  staticBackground,\n  transparentColor,\n  transpose,\n].sort((x, y) => (x.name > y.name ? 1 : -1));\n\nexport const transformByName = (name: string) => {\n  const t = POSSIBLE_TRANSFORMS.find((t) => t.name === name);\n  assert(t);\n  return t;\n};\n","import { buildTransform } from '../domain/types';\nimport { mapFrames, mapCoords, getPixelFromSource } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\nimport { intParam } from '../params/intParam';\n\nexport const ripple = buildTransform({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: 10,\n      description: 'How strong the ripple effect should be',\n    }),\n    intParam({\n      name: 'Period',\n      defaultValue: 2,\n      min: 0,\n      description: 'How many ripples you want. Positive number.',\n    }),\n  ],\n  fn: ({ image, parameters }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const [amplitude, period] = parameters;\n\n      const height = image.dimensions[1];\n      const shift = (frameIndex / frameCount) * 2 * Math.PI;\n      return mapCoords(image.dimensions, ([x, y]) => {\n        const offset = Math.round(\n          amplitude * Math.sin((y / height) * period * Math.PI + shift)\n        );\n\n        return getPixelFromSource(image.dimensions, data, [x + offset, y]);\n      });\n    }),\n});\n","import { mapImage } from '../domain/utils';\nimport { buildTransform, Coord } from '../domain/types';\nimport { dropdownParam } from '../params/dropdownParam';\n\nexport const rotate = buildTransform({\n  name: 'Rotate',\n  description: 'Make the image rotate about the center point',\n  params: [\n    dropdownParam({\n      name: 'Direction',\n      defaultValue: -1,\n      options: [\n        { name: 'Clockwise', value: -1 },\n        { name: 'Counter-Clockwise', value: 1 },\n      ],\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const [sign] = parameters;\n      const centerX = dimensions[0] / 2;\n      const centerY = dimensions[1] / 2;\n      const [x, y] = coord;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const amount = (frameIndex / frameCount) * (sign || 1);\n      const cos = Math.cos(2 * Math.PI * amount);\n      const sin = Math.sin(2 * Math.PI * amount);\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { mapFrames, mapCoords, getPixelFromSource } from '../domain/utils';\nimport { buildTransform, Coord } from '../domain/types';\n\nexport const roxbury = buildTransform({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const idx = frameIndex / frameCount;\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(idx * 4);\n      const phaseIdx = (idx - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      const cos = Math.cos(-angle * 1.35);\n      const sin = Math.sin(-angle * 1.35);\n\n      const rotatePointX = image.dimensions[0] * 0.25;\n      const rotatePointY = image.dimensions[1] * 0.7;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const [x, y] = coord;\n        const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n        const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n        const newCoord: Coord = [\n          Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n          Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n        ];\n\n        return getPixelFromSource(image.dimensions, data, newCoord);\n      });\n    }),\n});\n","import { buildTransform } from '../domain/types';\nimport { resizeImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const scaleImage = buildTransform({\n  name: 'Scale Image',\n  description: 'Scales the image to the selected width and height',\n  params: [\n    intParam({\n      name: 'Width',\n      defaultValue: 128,\n      min: 1,\n    }),\n    intParam({\n      name: 'Height',\n      defaultValue: 128,\n      min: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const [newWidth, newHeight] = parameters;\n    return resizeImage({\n      image,\n      newWidth,\n      newHeight,\n    });\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildTransform({\n  name: 'Shake',\n  description: 'Make the image shake back and forth',\n  params: [floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [amplitude] = parameters;\n    const [x, y] = coord;\n    const xOffset =\n      x +\n      Math.round(amplitude * Math.cos((frameIndex / frameCount) * 2 * Math.PI));\n\n    return getSrcPixel([xOffset, y]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent, fromHexColor } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\n\nexport const solidBackground = buildTransform({\n  name: 'Solid Background',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Background Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color] = parameters;\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildTransform({\n  name: 'Static',\n  description: 'Adds random static to the image',\n  params: [\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      return [0, 0, 0, 0];\n    }\n\n    const isStatic = Math.ceil(random() * 100) < strength;\n    const grey = Math.ceil(random() * 255);\n\n    return isStatic ? [grey, grey, grey, src[3]] : src;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticBackground = buildTransform({\n  name: 'Static Background',\n  description: 'Adds random static to the background',\n  params: [\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      const inverse = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return inverse ? [grey, grey, grey, 255] : src;\n    }\n\n    return src;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { fromHexColor, mapImage } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparentColor = buildTransform({\n  name: 'Transparent Color',\n  description:\n    'All pixels similar in color to the chosen one will be made transparent',\n  params: [\n    colorPickerParam({\n      name: 'Transparent Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color, tolerance] = parameters;\n    const p = getSrcPixel(coord);\n    const diff0 = p[0] - color[0];\n    const diff1 = p[1] - color[1];\n    const diff2 = p[2] - color[2];\n    const diff = Math.sqrt(diff0 * diff0 + diff1 * diff1 + diff2 * diff2);\n    if ((diff / 255) * 100 <= tolerance) {\n      return [p[0], p[1], p[2], 0];\n    }\n    return p;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildTransform({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [transX, transY] = parameters;\n    const [x, y] = coord;\n\n    return getSrcPixel([x + transX, y + transY]);\n  }),\n});\n","import React from 'react';\nimport {\n  Button,\n  CircularProgress,\n  Divider,\n  Grid,\n  Icon,\n  Stack,\n  Typography,\n} from '@material-ui/core';\n\nimport { assert } from '../domain/utils';\nimport { runTransforms } from '../domain/run';\nimport { TransformInput, TransformWithParams } from '../domain/types';\nimport { transformByName } from '../transforms';\nimport { sliderParam } from '../params/sliderParam';\n\ninterface ComputeBoxProps {\n  isDirty: boolean;\n  computeDisabled: boolean;\n  baseImageUrl?: string;\n  transforms: TransformWithParams<any>[];\n  onComputed: () => void;\n}\n\ntype ComputeState =\n  | {\n      loading: false;\n      results: { transformName: string; gif: string }[];\n      computeTime: number | undefined;\n    }\n  | { loading: true };\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nexport const ComputeBox: React.FC<ComputeBoxProps> = ({\n  isDirty,\n  computeDisabled,\n  baseImageUrl,\n  transforms,\n  onComputed,\n}) => {\n  const [state, setState] = React.useState<ComputeState>({\n    loading: false,\n    results: [],\n    computeTime: undefined,\n  });\n  const [fpsChanged, setFpsChanged] = React.useState(false);\n  const [fps, setFps] = React.useState(DEFAULT_FPS);\n\n  const buttonDisabled = computeDisabled && !fpsChanged;\n\n  return (\n    <Stack spacing={1}>\n      <Typography variant=\"h5\">Create Gif</Typography>\n\n      <div style={{ maxWidth: '300px' }}>\n        {fpsParam.fn({\n          value: { valid: true, value: fps },\n          onChange: (x) => {\n            if (x.valid) {\n              setFps(x.value);\n              setFpsChanged(true);\n            }\n          },\n        })}\n      </div>\n      <Button\n        variant=\"contained\"\n        sx={{ maxWidth: '300px' }}\n        endIcon={\n          !state.loading && (isDirty || fpsChanged) ? (\n            <Icon>priority_high</Icon>\n          ) : undefined\n        }\n        disabled={buttonDisabled}\n        onClick={async () => {\n          const transformInputs = transforms.map(\n            (t): TransformInput<any> => ({\n              transform: transformByName(t.transformName),\n              params: t.paramsValues.map((p) => {\n                assert(p.valid);\n                return p.value;\n              }),\n            })\n          );\n          setState({ loading: true });\n          setTimeout(async () => {\n            try {\n              assert(\n                baseImageUrl,\n                'No source image, this button should be disabled!'\n              );\n              const start = Date.now();\n              const gifs = await runTransforms(\n                baseImageUrl,\n                transformInputs,\n                fps\n              );\n              const computeTime = Math.ceil((Date.now() - start) / 1000);\n              setState({\n                loading: false,\n                computeTime,\n                results: gifs.map((gif, idx) => ({\n                  transformName: transforms[idx].transformName,\n                  gif,\n                })),\n              });\n              setFpsChanged(false);\n              onComputed();\n            } catch (err) {\n              console.error(err);\n              console.error(err.stack);\n            }\n          });\n        }}\n      >\n        {state.loading ? <CircularProgress color=\"inherit\" /> : 'Compute'}\n      </Button>\n      {!state.loading && state.computeTime && (\n        <>\n          <Divider />\n          <Typography variant=\"caption\">\n            Compute Time: {state.computeTime} second(s)\n          </Typography>\n        </>\n      )}\n\n      {!state.loading && state.results.length > 0 && (\n        <>\n          <Divider />\n          <Grid\n            container\n            spacing={2}\n            padding={1}\n            columns={{ xs: 4, sm: 8, md: 12 }}\n          >\n            {state.results.map(({ gif, transformName }, idx) => (\n              <Grid item xs={4} sm={4} md={4}>\n                <Typography variant=\"subtitle2\">{transformName}</Typography>\n                <img src={gif} alt={`gif-${transformName}-${idx}`}></img>\n              </Grid>\n            ))}\n          </Grid>\n        </>\n      )}\n    </Stack>\n  );\n};\n","import {\n  FormControl,\n  IconButton,\n  Icon,\n  Tooltip,\n  Stack,\n  Typography,\n  Paper,\n  Autocomplete,\n  TextField,\n  Divider,\n} from '@material-ui/core';\nimport React from 'react';\n\nimport { ParamFunction, ParamValue, Transform } from '../domain/types';\n\ninterface SelectedTransform {\n  transform: Transform<any>;\n  paramValues: ParamValue<any>[];\n}\n\ninterface ImageTransformProps {\n  selectedTransform: SelectedTransform;\n  possibleTransforms: Transform<any>[];\n  index: number;\n  onSelect: (selected: SelectedTransform) => void;\n  onRemove: () => void;\n  onMoveLeft?: () => void;\n  onMoveRight?: () => void;\n}\n\nexport const ImageTransform: React.FC<ImageTransformProps> = ({\n  selectedTransform,\n  possibleTransforms,\n  index,\n  onSelect,\n  onRemove,\n  onMoveLeft,\n  onMoveRight,\n}) => {\n  return (\n    <Paper style={{ padding: 8 }} elevation={3}>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={2}>\n          <Typography variant=\"subtitle1\">{index + 1}</Typography>\n          <Tooltip title=\"Delete transform\">\n            <IconButton aria-label=\"delete\" onClick={onRemove}>\n              <Icon>delete</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform left\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveLeft}\n              disabled={!onMoveLeft}\n            >\n              <Icon>chevron_left</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform right\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveRight}\n              disabled={!onMoveRight}\n            >\n              <Icon>chevron_right</Icon>\n            </IconButton>\n          </Tooltip>\n        </Stack>\n        <Stack direction=\"row\" spacing={4}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={selectedTransform.transform.name}\n              options={possibleTransforms.map((t) => t.name)}\n              onChange={(event, newTransformName) => {\n                const t = possibleTransforms.find(\n                  (t) => t.name === newTransformName\n                )!;\n                // Reset all the params when you select a new transform\n                onSelect({\n                  transform: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n              renderInput={(params) => (\n                <TextField {...params} label=\"Transform\" />\n              )}\n            />\n          </FormControl>\n        </Stack>\n        {selectedTransform.transform.description && (\n          <Typography variant=\"caption\">\n            {selectedTransform.transform.description}\n          </Typography>\n        )}\n        {selectedTransform.transform.params.length > 0 && (\n          <Typography variant=\"subtitle1\">Parameters</Typography>\n        )}\n        <Stack divider={<Divider />} spacing={2}>\n          {selectedTransform.transform.params.map(\n            // Create elements for each of the parameters for the selectect transform.\n            // Each of these would get an onChange event so we know when the user has\n            //  selected a value.\n            (param: ParamFunction<any>, idx: number) => {\n              const ele = param.fn({\n                value: selectedTransform.paramValues[idx],\n                onChange: (v) => {\n                  onSelect({\n                    ...selectedTransform,\n                    paramValues: selectedTransform.paramValues.map((x, i) => {\n                      if (i === idx) {\n                        return v;\n                      }\n                      return x;\n                    }),\n                  });\n                },\n              });\n              return (\n                <React.Fragment\n                  key={`${selectedTransform.transform.name}-${param.name}`}\n                >\n                  {ele}\n                </React.Fragment>\n              );\n            }\n          )}\n        </Stack>\n      </Stack>\n    </Paper>\n  );\n};\n","import { Button, Grid, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Transform, TransformWithParams } from '../domain/types';\nimport { transformByName } from '../transforms';\nimport { ImageTransform } from './ImageTransform';\n\ninterface TransformListProps {\n  currentTransforms: TransformWithParams<any>[];\n  possibleTransforms: Transform<any>[];\n  onTransformsChange: (t: TransformWithParams<any>[]) => void;\n}\n\nexport const ImageTransformList: React.FC<TransformListProps> = ({\n  currentTransforms,\n  possibleTransforms,\n  onTransformsChange,\n}) => (\n  <Stack spacing={1}>\n    <Typography variant=\"h5\">Image Transforms</Typography>\n    <Grid container spacing={2} padding={1} columns={{ xs: 4, sm: 8, md: 12 }}>\n      {currentTransforms.map((t, tIdx) => (\n        <Grid item xs={4} sm={4} md={4}>\n          <ImageTransform\n            index={tIdx}\n            possibleTransforms={possibleTransforms}\n            selectedTransform={{\n              transform: transformByName(t.transformName),\n              paramValues: t.paramsValues,\n            }}\n            onRemove={() =>\n              onTransformsChange(\n                currentTransforms.filter((nextT, newIdx) => newIdx !== tIdx)\n              )\n            }\n            onMoveLeft={\n              tIdx > 0\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx - 1) {\n                          // This is the next item in the list\n                          return currentTransforms[newIdx + 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the previous item\n                          return currentTransforms[tIdx - 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onMoveRight={\n              tIdx < currentTransforms.length - 1\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx + 1) {\n                          // This is the previous item in the list\n                          return currentTransforms[newIdx - 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the next item\n                          return currentTransforms[tIdx + 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onSelect={(selected) =>\n              onTransformsChange(\n                currentTransforms.map((nextT, nextTIdx) => {\n                  if (tIdx === nextTIdx) {\n                    // This is the one we just changed\n                    return {\n                      transformName: selected.transform.name,\n                      paramsValues: selected.paramValues,\n                      computedImage: undefined,\n                    };\n                  }\n                  // Reset all the images if we changed anything\n                  return {\n                    transformName: nextT.transformName,\n                    paramsValues: nextT.paramsValues,\n                    computedImage: undefined,\n                  };\n                })\n              )\n            }\n          />\n        </Grid>\n      ))}\n      <Grid item xs={4} sm={4} md={4}>\n        <Stack spacing={4}>\n          <Button\n            fullWidth={false}\n            variant=\"contained\"\n            startIcon={<Icon>add</Icon>}\n            onClick={() =>\n              onTransformsChange([\n                ...currentTransforms,\n                {\n                  transformName: possibleTransforms[0].name,\n                  paramsValues: possibleTransforms[0].params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                },\n              ])\n            }\n          >\n            New Transform\n          </Button>\n        </Stack>\n      </Grid>\n    </Grid>\n  </Stack>\n);\n","import {\n  Stack,\n  Button,\n  Icon,\n  Typography,\n  Alert,\n  Grid,\n} from '@material-ui/core';\nimport React from 'react';\nimport * as lz from 'lz-string';\nimport { AppState } from '../domain/types';\n\ninterface ImportExportProps {\n  state: AppState;\n  onImport: (o: AppState) => void;\n}\n\nexport const ImportExport: React.FC<ImportExportProps> = ({\n  state,\n  onImport,\n}) => {\n  const [info, setInfo] = React.useState<string | undefined>();\n  const [isInvalid, setInvalid] = React.useState(false);\n\n  const showInfo = (text: string) => {\n    setInfo(text);\n    setTimeout(() => setInfo(undefined), 2000);\n  };\n\n  const showError = () => {\n    setInvalid(true);\n    setTimeout(() => setInvalid(false), 2000);\n  };\n\n  return (\n    <Stack spacing={3}>\n      <Typography variant=\"h5\">Import/Export</Typography>\n      <Button\n        endIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(\n            JSON.stringify({ ...state, baseImage: undefined })\n          );\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard <br /> (NO Source Image)\n      </Button>\n      <Button\n        endIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(JSON.stringify(state));\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard <br />\n        (With Source Image)\n      </Button>\n      <Button\n        endIcon={<Icon>file_download</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={async () => {\n          try {\n            const clipboardContents = await navigator.clipboard.readText();\n            if (!clipboardContents) {\n              showError();\n              return;\n            }\n            const data = JSON.parse(\n              lz.decompressFromBase64(clipboardContents)!\n            );\n            if (!Array.isArray(data.transforms)) {\n              showError();\n              return;\n            }\n            onImport(data);\n            setInvalid(false);\n          } catch (e) {\n            console.error(e);\n            showError();\n          }\n        }}\n      >\n        Import from clipboard\n      </Button>\n      {info && (\n        <Alert severity=\"info\" sx={{ maxWidth: '300px' }}>\n          {info}\n        </Alert>\n      )}\n      {isInvalid && (\n        <Alert severity=\"error\" sx={{ maxWidth: '300px' }}>\n          Error importing from clipboard\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n","import React from 'react';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\nimport {\n  Container,\n  Stack,\n  Divider,\n  Paper,\n  Typography,\n} from '@material-ui/core';\n\nimport { POSSIBLE_TRANSFORMS, transformByName } from './transforms';\nimport { ParamFunction, AppState } from './domain/types';\nimport { ComputeBox } from './components/ComputeBox';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageTransformList } from './components/ImageTransformList';\nimport { ImportExport } from './components/ImportExport';\n\n// Set to true to print out the current state at the bottom of the page\nconst DEBUG = false;\n\nexport const App: React.FC = () => {\n  const [state, setState] = React.useState<AppState>({\n    dirty: false,\n    transforms: [],\n    baseImage: undefined,\n  });\n\n  if (DEBUG) {\n    (window as any).STATE = state;\n  }\n\n  const computeBtnDisbled =\n    !state.baseImage ||\n    state.transforms.length === 0 ||\n    !state.dirty ||\n    state.transforms.some((t) => {\n      const params = transformByName(t.transformName)\n        .params as ParamFunction<any>[];\n      return (\n        params.length > 0 && t.paramsValues.every((p, i) => p.valid === false)\n      );\n    });\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container>\n        <Stack spacing={4} justifyContent=\"space-evenly\" divider={<Divider />}>\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />}>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={1}>\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Choose a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState({\n                      ...state,\n                      baseImage,\n                      dirty: true,\n                    });\n                  }}\n                />\n              </Stack>\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImageTransformList\n                currentTransforms={state.transforms}\n                possibleTransforms={POSSIBLE_TRANSFORMS}\n                onTransformsChange={(transforms) =>\n                  setState({\n                    ...state,\n                    dirty: true,\n                    transforms,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ComputeBox\n                isDirty={state.dirty}\n                baseImageUrl={state.baseImage}\n                computeDisabled={computeBtnDisbled}\n                transforms={state.transforms}\n                onComputed={() =>\n                  setState({\n                    ...state,\n                    dirty: false,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImportExport\n                state={state}\n                onImport={(newState) => setState({ ...newState, dirty: true })}\n              />\n            </Paper>\n            {DEBUG && (\n              <div>\n                <code>{JSON.stringify(state, null, 2)}</code>\n              </div>\n            )}\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n    </>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}