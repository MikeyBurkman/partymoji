{"version":3,"sources":["components/Expandable.tsx","components/Help.tsx","components/ImagePicker.tsx","domain/utils.ts","domain/types.ts","components/HelpTooltip.tsx","params/intParam.tsx","params/sliderParam.tsx","effects/adjust-image.ts","params/colorPickerParam.tsx","effects/background-color.ts","domain/run.ts","params/imagePickerParam.tsx","params/radioParam.tsx","effects/background-image.ts","effects/bounce.ts","effects/bounce-animation.ts","effects/circle.ts","params/variableLengthParam.tsx","effects/colors.ts","effects/colors-background.ts","params/floatParam.tsx","effects/double-vision.ts","effects/expand.ts","effects/fill.ts","effects/fisheye.ts","effects/grid.ts","params/huePickerParam.tsx","effects/hue-change.ts","params/textParam.tsx","effects/hue-shift.ts","effects/hue-shift-pulse.ts","effects/hue-wave.ts","effects/lightning.ts","effects/nuke.ts","effects/party.ts","effects/party-two.ts","effects/pinwheel.ts","effects/pinwheel-party.ts","effects/radiance.ts","effects/radiance-party.ts","effects/reduce-color-palette.ts","effects/repeat-animation.ts","effects/resize-image.ts","effects/reverse-animation.ts","effects/ripple.ts","effects/rotate.ts","effects/roxbury.ts","effects/shake.ts","effects/slow-animation.ts","effects/spin.ts","effects/static.ts","params/checkboxParam.tsx","effects/transparency.ts","effects/transpose.ts","effects/index.ts","components/ImageEffect.tsx","components/ImageEffectList.tsx","components/ImportExport.tsx","domain/effect.worker.ts","domain/runAsync.ts","domain/computeGifs.ts","localStorage.ts","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["Expandable","mainEle","children","React","useState","collapsed","setCollapsed","ClickAwayListener","onClickAway","Box","Button","onClick","style","textTransform","color","Stack","direction","spacing","Icon","Collapse","in","HELP","header","data","Help","Typography","variant","map","section","sectionIdx","Divider","subsection","paddingLeft","subsectionData","ImagePicker","currentImageUrl","name","onChange","startIcon","sx","maxWidth","component","type","hidden","accept","event","a","files","Array","from","target","file","readFile","baseImage","maxHeight","src","alt","Promise","resolve","reader","FileReader","onload","result","readAsDataURL","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","clamp","n","min","max","clampColor","TRANSPARENT_COLOR","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","frame","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","scaleImage","args","newWidth","newHeight","xRatio","yRatio","newImage","createNewImage","srcX","srcY","getPixel","setPixel","resizeImage","sourceWidth","sourceHeight","xPadding","round","yPadding","range","weightedValue","percent","v1","v2","shiftTowardsHue","hue","amount","convert","hsl","l","rgb","newR","newG","newB","shiftHue","h","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","colorFromHue","adjustSaturation","newSat","abs","colorDiff","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","sqrt","changeFrameCount","currentFrames","i","frameToCopy","replaceIndex","arr","index","newValueFn","buildEffect","params","description","fn","disabled","HelpTooltip","Tooltip","title","fontSize","IntParam","value","parse","val","setVal","invalidText","setInvalidText","FormControl","TextField","error","onBlur","valid","reason","e","FormHelperText","intParam","defaultValue","isNaN","undefined","SliderParam","step","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","sliderParam","adjustImage","resizeToWidth","resizeToHeight","brightness","contrast","saturation","hasFrameCount","oldWidth","oldHeight","hasScaleChange","ceil","isBiggerImage","currImage","currColor","d","adjustBrightness","adjustContrast","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","p","runEffects","effectInput","randomSeed","fps","seedrandom","effect","effectByName","effectName","transparentColor","getTransparentColor","createGif","encodeTransparency","gif","newFrames","img","gifEncoder","setFrameRate","setRepeat","writeHeader","hexColor","slice","setTransparent","on","chunk","push","dataUrl","URL","createObjectURL","Blob","forEach","f","addFrame","finish","readImage","res","rej","getPixels","err","results","shape","numFrames","sliceSize","subarray","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","DEFAULT_IMAGE","RadioParam","options","RadioGroup","t","FormControlLabel","control","Radio","label","radioParam","backgroundImage","imagePickerParam","otherImagePreResize","otherImage","otherImageFrame","otherImageSrc","bounce","speed","yOffset","sin","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","cos","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","oldP","IconButton","newParams","filter","visibility","variableLengthParam","DEFAULT_COLORS","colors","chosenColor","srcPixel","gray","getAveragePixelValue","colorsBackground","bgColor","FloatParam","floatParam","parseFloat","doubleVision","dir","expand","dist","centerX","centerY","fill","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","degrees","HuePickerParam","huePickerParam","hueChange","newHue","hueShift","hueShiftPulse","hueWave","shift","amplitude","period","TextParam","lightningIntensities","lightning","seed","flashIntensity","icf","nuke","party","shiftSpeed","isBackground","newH","partyTwo","pinwheel","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","offsetX","offsetY","center","pointAngle","colorIdx","pinwheelParty","radiance","colorList","flatMap","maxDist","distFromCenter","radianceParty","reduceColorPalette","percentReduction","allColorsSet","allColors","numColors","colorMap","numClosestColors","closestColorIdx","closetsColorDist","k","colorPalette","sortBy","minBy","top","repeatAnimation","numRepeats","resizeImageUtil","reverseAnimation","ripple","rotate","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","shake","slowAnimation","ogFrameIdx","r1","g1","b1","a1","spin","staticc","strength","inverse","grey","isStatic","CheckboxParam","paddingTop","Checkbox","checked","transparency","checkboxParam","matchesTransparent","selectedColor","tolerance","withinTolerance","transpose","POSSIBLE_EFFECTS","reject","find","ImageEffect","selectedEffect","possibleEffect","onSelect","onRemove","onMoveBefore","onMoveAfter","paramsOpen","setParamsOpen","paramValues","currParams","setCurrParams","dirty","setDirty","closeDialog","save","padding","elevation","fullWidth","Autocomplete","disableClearable","newEffectName","renderInput","Dialog","open","DialogTitle","DialogContent","divider","Fragment","DialogActions","autoFocus","ImageEffectList","currentEffect","possibleEffects","onEffectsChange","tIdx","paramsValues","nextT","newIdx","selected","state","status","CircularProgress","size","substring","effectKey","ImportExport","onImport","info","setInfo","isInvalid","setInvalid","showError","setTimeout","output","lz","JSON","stringify","navigator","clipboard","writeText","readText","clipboardContents","isArray","effects","console","Alert","severity","Worker_fn","Worker","runEffectsAsync","worker","RunEffectWorker","addEventListener","onmessage","postMessage","ENV","window","computeGifs","appState","onCompute","effectInputs","run","start","Date","now","ga","hitType","timingCategory","timingVar","timingValue","LOCAL_STORAGE_KEY","clearAppState","localStorage","removeItem","stack","serializeAppState","toStore","fpsParam","DEFAULT_STATE","version","App","setStateRaw","doCompute","setDoCompute","computeTimer","setComputeTimer","useEffect","stored","getItem","savedState","setState","useCallback","oldState","newState","setItem","clearTimeout","prevState","computeIdx","ScopedCssBaseline","Container","justifyContent","pt","o","href","rel","TopLevelErrorBoundary","hasError","errorInfo","this","endIcon","props","onClearLocalStorage","Component","ReactDOM","render","StrictMode","location","reload","document","getElementById"],"mappings":"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","file":"static/js/main.382fd56d.chunk.js","sourcesContent":["import {\n  Box,\n  Button,\n  ClickAwayListener,\n  Collapse,\n  Icon,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Box>\n        <Button\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ textTransform: 'none', color: 'black' }}\n        >\n          <Stack direction=\"row\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'expand_less' : 'expand_more'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Box>\n    </ClickAwayListener>\n  );\n};\n","import { Divider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { Expandable } from './Expandable';\n\nconst HELP = [\n  {\n    header: 'Getting Started',\n    data: [\n      {\n        header: 'Start by importing an image from your device',\n        data: [\n          'You may choose a png, jpg, or gif',\n          'The frames per second controls how fast the final gif will animate',\n        ],\n      },\n    ],\n  },\n  {\n    header: 'Adding effects',\n    data: [\n      {\n        header: 'Effects are applied to an image to manipulate it',\n        data: [\n          'Some may adjust the basic attributes of an image, such as size, or number of animation frames.',\n          'Others may apply animated effects, such as making the image spin, or cycle through colors.',\n        ],\n      },\n      {\n        header: 'Animation effects require multiple animaion frames',\n        data: [\n          'The \"Adjust Image\" effect has a \"Frame Count\" paramter.',\n          'This controls how many frames are in the animation. Typically this is between 10 and 20',\n          'More frames will increase both the time to compute the image, and the final file size',\n          'Remember that some places (like Slack and Discord) have strict limits on the size of emojis.',\n        ],\n      },\n      {\n        header: 'The order of effects matters',\n        data: [\n          'The result of each effect is send to the next effect.',\n          'Because of this, the order of effects matter.',\n          'Experiment with moving effects around to see different effects.',\n          'For instance, applying a background color before rotating the image will have a very different effect than rotating before setting a background color',\n        ],\n      },\n    ],\n  },\n  {\n    header: 'Creating Gifs',\n    data: [\n      {\n        header: 'Gifs will compute automatically',\n        data: [\n          'Whenever you add or change an effect, it will compute a new gif next to that effect',\n          'The gif next to each effect shows what the results of that effect on the previous gif were',\n        ],\n      },\n      {\n        header: 'Exporting a GIF',\n        data: [\n          'To export a gif, just right click on the gif next to an effect, and click \"Save Image As...\"',\n          'Importing/exporting further down on the page is used if you want to share your Partymoji steps with someone else!',\n        ],\n      },\n    ],\n  },\n];\n\nexport const Help: React.FC = () => (\n  <Expandable\n    mainEle={<Typography variant=\"h5\">Click here for Help</Typography>}\n  >\n    <Stack spacing={1}>\n      {HELP.map((section, sectionIdx) => (\n        <>\n          {sectionIdx > 0 && <Divider />}\n          <Typography variant=\"h6\">{section.header}</Typography>\n          {section.data.map((subsection) => (\n            <>\n              <Typography variant=\"body1\" paddingLeft=\"0.5rem\">\n                {subsection.header}\n              </Typography>\n              {subsection.data.map((subsectionData) => (\n                <Typography variant=\"caption\" paddingLeft=\"1.0rem\">\n                  * {subsectionData}\n                </Typography>\n              ))}\n            </>\n          ))}\n        </>\n      ))}\n    </Stack>\n  </Expandable>\n);\n","import { Button, Icon, Stack } from '@material-ui/core';\nimport React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  onChange,\n}) => (\n  <Stack spacing={4}>\n    <Button\n      startIcon={<Icon>image</Icon>}\n      sx={{ maxWidth: '300px' }}\n      variant=\"contained\"\n      component=\"label\"\n    >\n      {name}\n      <input\n        type=\"file\"\n        hidden\n        accept=\"image/png,image/jpg,image/jpeg,image/gif\"\n        name=\"source-png\"\n        onChange={async (event) => {\n          const files = Array.from(event.target.files ?? []);\n          const file = files[0];\n          if (file) {\n            // Will be undefined if user clicked the cancel button\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }\n        }}\n      />\n    </Button>\n    {currentImageUrl && (\n      <img\n        style={{ maxWidth: '200px', maxHeight: 'auto' }}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </Stack>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import { AssertionError } from 'assert';\nimport * as convert from 'color-convert';\nimport { range } from 'remeda';\nimport seedrandom from 'seedrandom';\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  Image,\n  ImageData,\n  Random,\n  EffectFn,\n  EffectFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our effect functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress: frameIndex / frameCount,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/**\n * Similar to mapImage, but the first argument pre-computes some things for\n *  each frame, which is then passed to the second callback function.\n * This is useful for performance (only compute things every frame rather than every pixel),\n *  and also allows you to generate some random value that will be the same for every frame.\n */\nexport const mapImageWithPrecompute = <T, R>(\n  compute: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n  }) => R,\n  cb: (args: {\n    computed: R;\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const computed = compute({\n        image,\n        dimensions: image.dimensions,\n        random,\n        parameters,\n        frameCount,\n        frameIndex,\n        animationProgress,\n      });\n\n      return mapCoords(image.dimensions, (coord) =>\n        cb({\n          computed,\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      );\n    });\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Change the dimensions of the image, scaling it to make it fit the new dimensions\n */\nexport const scaleImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const color = getPixel({\n          image,\n          frameIndex,\n          coord: [srcX, srcY],\n        });\n        setPixel({\n          image: newImage,\n          frameIndex,\n          color,\n          coord: [x, y],\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\n/**\n * Will change the image dimensions without altering the scale.\n * If the new dimensions are larger, the image will be centered.\n * If the new dimensions are smaller, it'll be cropped\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const [sourceWidth, sourceHeight] = image.dimensions;\n\n  const xPadding = Math.round((newWidth - sourceWidth) / 2);\n  const yPadding = Math.round((newHeight - sourceHeight) / 2);\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        const color: Color =\n          x > xPadding &&\n          x < newWidth - xPadding &&\n          y > yPadding &&\n          y < newHeight - yPadding\n            ? getPixel({\n                image,\n                frameIndex,\n                coord: [x - xPadding, y - yPadding],\n              })\n            : TRANSPARENT_COLOR;\n        setPixel({\n          image: newImage,\n          frameIndex,\n          coord: [x, y],\n          color,\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8Array(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const duplicateImage = (image: Image): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((f) => new Uint8Array(f)),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftTowardsHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Adds the given amount to the hue of the color.\n * Amount should be between 0 and 360\n */\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\n  return [newR, newG, newB, a];\n};\n\n/**\n * Returns the angle in degrees (0 to 360) betwee the two coordinates\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n\nexport const adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nexport const adjustBrightness = (color: Color, amount: number): Color => {\n  const d = (amount / 100) * 128;\n  const [r, g, b, a] = color;\n  return clampColor([r + d, g + d, b + d, a]);\n};\n\n// Amount: -100 to 100\nexport const adjustContrast = (color: Color, amount: number): Color => {\n  const d = amount / 100 + 1;\n  const [r, g, b, a] = color;\n  return clampColor([\n    d * (r - 128) + 128,\n    d * (g - 128) + 128,\n    d * (b - 128) + 128,\n    a,\n  ]);\n};\n\n/**\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\n */\nexport const colorDiff = (c1: Color, c2: Color): number => {\n  // Red-mean color diff algorithm\n  // https://en.wikipedia.org/wiki/Color_difference\n  const deltaRed = c1[0] - c2[0];\n  const deltaBlue = c1[1] - c2[1];\n  const deltaGreen = c1[2] - c2[2];\n  const rSomething = (c1[0] + c2[0]) / 2;\n\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\n  const gComponent = 4 * deltaGreen * deltaGreen;\n  // 765 = ~ difference between black and white pixels\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\n};\n\nexport const changeFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had fewer than that, then we'll\n  //  duplicate some frames to approximately slow the animation.\n  // If the original has more frames, then we'll discard some frames.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) => {\n      const frameToCopy = Math.floor((i / frameCount) * currentFrames.length);\n      return currentFrames[frameToCopy];\n    }),\n  };\n};\n\n/** Returns a new array where the item at the given index is replaced by the given value */\nexport const replaceIndex = <T>(\n  arr: T[],\n  index: number,\n  newValueFn: (oldValue: T) => T\n): T[] => arr.map((x, i) => (index === i ? newValueFn(x) : x));\n","import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: ImageData[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface EffectFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: T;\n  onChange: (v: T) => void;\n}\n\nexport type ParamFunction<T = any> = {\n  name: string;\n  defaultValue: T;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type EffectFn<Params> = (opts: EffectFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Effect<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  description?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled: boolean;\n}\n\nexport interface EffectWithParams<T extends readonly ParamFunction<any>[]> {\n  effectName: string;\n  paramsValues: T[];\n}\n\nexport interface EffectInput {\n  effectName: string;\n  params: any;\n}\n\nexport const buildEffect = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled?: boolean;\n}): Effect<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  fn: args.fn,\n  disabled: args.disabled ?? false,\n});\n\nexport interface AppStateEffect {\n  effectName: string;\n  paramsValues: any[];\n  state:\n    | { status: 'init' }\n    | { status: 'computing' }\n    | { status: 'done'; image: ImageEffectResult };\n}\n\nexport interface AppState {\n  version: number;\n  baseImage?: string;\n  effects: AppStateEffect[];\n  fps: number;\n}\n\nexport interface ImageEffectResult {\n  gif: string;\n  image: Image;\n}\n\nexport type AsyncRunMessage = {\n  status: 'complete';\n  result: ImageEffectResult;\n};\n","import { Icon, Tooltip } from '@material-ui/core';\nimport React from 'react';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={value}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) => onChange(value as number)}\n        />\n        <Typography variant=\"body2\">{value}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  adjustBrightness,\n  adjustContrast,\n  adjustSaturation,\n  changeFrameCount,\n  getPixelFromSource,\n  mapCoords,\n  mapFrames,\n  scaleImage,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const adjustImage = buildEffect({\n  name: 'Adjust Image',\n  description: 'Leave a parameter at 0 if you want to not change it',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description:\n        'Set how many frames of animation there will be. Leave at 0 to not change the current frame count.',\n      defaultValue: 0,\n      min: 0,\n      max: 60,\n    }),\n    intParam({\n      name: 'Width',\n      description:\n        'Leave at 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Leave at 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [\n      frameCount,\n      resizeToWidth,\n      resizeToHeight,\n      brightness,\n      contrast,\n      saturation,\n    ],\n  }) => {\n    const hasFrameCount = frameCount !== 0;\n\n    const [oldWidth, oldHeight] = image.dimensions;\n\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\n\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\n    const newWidth =\n      hasScaleChange && resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      hasScaleChange && resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\n\n    let currImage = image;\n\n    if (hasFrameCount && frameCount < image.frames.length) {\n      // Reducing the number of frames, so do that first so we have fewer pixels to change\n      currImage = changeFrameCount(currImage, frameCount);\n    }\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = scaleImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n      });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      mapCoords(currImage.dimensions, (coord) => {\n        let currColor = getPixelFromSource(\n          currImage.dimensions,\n          imageData,\n          coord\n        );\n\n        if (brightness !== 0) {\n          currColor = adjustBrightness(currColor, brightness);\n        }\n\n        if (contrast !== 0) {\n          currColor = adjustContrast(currColor, contrast);\n        }\n\n        if (saturation !== 0) {\n          currColor = adjustSaturation(currColor, saturation);\n        }\n\n        return currColor;\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = scaleImage({ image: currImage, newWidth, newHeight });\n    }\n\n    // Finally change the number of frames if we're adding frames\n    if (hasFrameCount && frameCount > image.frames.length) {\n      currImage = changeFrameCount(currImage, frameCount);\n    }\n\n    return currImage;\n  },\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { Color, ParamFunction } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value: Color;\n  description?: string;\n  onChange: (v: Color) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={toHexColor(value)}\n        onChangeComplete={(c) => {\n          onChange(fromHexColor(c.hex));\n        }}\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue: Color;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, isTransparent, mapImage } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\n\nexport const backgroundColor = buildEffect({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [color] }) => {\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\nimport { effectByName } from '../effects';\nimport {\n  Color,\n  Image,\n  ImageData,\n  ImageEffectResult,\n  EffectInput,\n} from './types';\nimport {\n  fromHexColor,\n  getPixelFromSource,\n  isTransparent,\n  randomColor,\n  toHexColor,\n} from './utils';\n\nexport interface RunArgs {\n  randomSeed: string;\n  image: Image;\n  effectInput: EffectInput;\n  fps: number;\n}\n\n// Returns a list of gif data URLs, for each effect\nexport const runEffects = async ({\n  image,\n  effectInput,\n  randomSeed,\n  fps,\n}: RunArgs): Promise<ImageEffectResult> => {\n  const random = seedrandom(randomSeed);\n\n  const effect = effectByName(effectInput.effectName);\n  const result = effect.fn({\n    image,\n    parameters: effectInput.params,\n    random,\n  });\n\n  const transparentColor = getTransparentColor(result, random);\n\n  const gif = await createGif({\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    image: encodeTransparency(result, transparentColor),\n    transparentColor,\n    fps,\n  });\n\n  return {\n    gif,\n    image: result,\n  };\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  image: Image,\n  transparentColor: Color | undefined\n): Image => {\n  const newFrames = image.frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = 0;\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 0; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return {\n    dimensions: image.dimensions,\n    frames: newFrames,\n  };\n};\n\nconst createGif = async ({\n  image,\n  transparentColor,\n  fps,\n}: {\n  image: Image;\n  transparentColor: Color | undefined;\n  fps: number;\n}): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = image.dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    image.frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          const [width, height] = results.shape;\n          // Single frame\n          return res({\n            frames: [Uint8Array.from(results.data)],\n            dimensions: [width, height],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8Array[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          frames.push(\n            results.data.subarray(i * sliceSize, (i + 1) * sliceSize)\n          );\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import React from 'react';\nimport { ImagePicker } from '../components/ImagePicker';\nimport { readImage } from '../domain/run';\nimport { Image, ParamFunction } from '../domain/types';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\ninterface ParamType {\n  dataUrl: string;\n  image: Image;\n}\n\n// Just a 1x1 black jpg. Surprisingly big!\nconst DEFAULT_IMAGE: ParamType = {\n  dataUrl:\n    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\n  image: {\n    dimensions: [1, 1],\n    frames: [new Uint8Array([0, 0, 0, 255])],\n  },\n};\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<ParamType> {\n  return {\n    name,\n    defaultValue: DEFAULT_IMAGE,\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={params.value.dataUrl}\n        name={name}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ dataUrl, image });\n        }}\n      />\n    ),\n  };\n}\n","import {\n  FormControl,\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst RadioParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value: string;\n  description?: string;\n  onChange: (s: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label={name}\n          defaultValue={value}\n          onChange={(event) => onChange(event.target.value)}\n        >\n          {options.map((t) => (\n            <FormControlLabel\n              value={t.value}\n              control={<Radio />}\n              label={t.name}\n              key={t.value}\n            />\n          ))}\n        </RadioGroup>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function radioParam<T extends string>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <RadioParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={(s) => params.onChange(s as T)}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  getPixel,\n  isTransparent,\n  resizeImage,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { radioParam } from '../params/radioParam';\n\nexport const backgroundImage = buildEffect({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image: { dimensions }, parameters: [otherImagePreResize, type] }) => {\n      const otherImage = resizeImage({\n        image: otherImagePreResize.image,\n        newWidth: dimensions[0],\n        newHeight: dimensions[1],\n      });\n      return { otherImage, type };\n    },\n    ({\n      coord,\n      animationProgress,\n      computed: { otherImage, type },\n      getSrcPixel,\n    }) => {\n      const otherImageFrame = Math.floor(\n        animationProgress * otherImage.frames.length\n      );\n      const otherImageSrc = getPixel({\n        image: otherImage,\n        frameIndex: otherImageFrame,\n        coord,\n      });\n\n      const src = getSrcPixel(coord);\n\n      if (type === 'background') {\n        // Only print the other image if the src image is transparent here\n        return isTransparent(src) ? otherImageSrc : src;\n      } else {\n        return isTransparent(otherImageSrc) ? src : otherImageSrc;\n      }\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildEffect({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [speed] }) => ({\n      yOffset: Math.round(speed * Math.sin(animationProgress * 2 * Math.PI)),\n    }),\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x, y + yOffset])\n  ),\n});\n","import { concat, drop, pipe, reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const bounceAnimation = buildEffect({\n  name: 'Bounce Animation',\n  description: 'When the animation finishes, it will be replayed in reverse',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: concat(\n      image.frames,\n      pipe(image.frames, drop(1), reverse(), drop(1))\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildEffect({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [radius] }) => ({\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\n    }),\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y + yOffset])\n  ),\n});\n","import {\n  Button,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ninterface VariableLengthProps<T> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value: T[];\n  description?: string;\n  onChange: (v: T) => void;\n}\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<\n    { param: ParamFunction<any>; pValue: any }[]\n  >(value.map((v) => ({ param: createNewParam(), pValue: v })));\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: pValue,\n            onChange: (newValue) => {\n              const p = params.map((oldP, i) => {\n                if (idx === i) {\n                  return {\n                    param,\n                    pValue: newValue,\n                  };\n                }\n                return oldP;\n              });\n              setParams(p);\n              onChange(p.map((n) => n.pValue));\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange(newParams.map((n) => n.pValue));\n                }}\n                style={{\n                  visibility:\n                    idx === 0 /* Hide delete on first item */\n                      ? 'hidden'\n                      : undefined,\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue,\n              },\n            ];\n            setParams(newParams);\n            onChange(newParams.map((n) => n.pValue));\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue: T[];\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  getAveragePixelValue,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildEffect({\n  name: 'Colors',\n  description: 'Make the image flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { chosenColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (isTransparent(srcPixel)) {\n        return [0, 0, 0, 0];\n      }\n\n      const gray = getAveragePixelValue(srcPixel);\n\n      return [\n        (gray * chosenColor[0]) / 255,\n        (gray * chosenColor[1]) / 255,\n        (gray * chosenColor[2]) / 255,\n        255,\n      ];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildEffect({\n  name: 'Colors Background',\n  description: 'Transparent pixels will flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      bgColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { bgColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      // Make the transparent parts colorful\n      if (isTransparent(srcPixel)) {\n        return bgColor;\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildEffect({\n  name: 'Double Vision',\n  description: 'See the image in double',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\n      const dir = x % 2 === 0 ? -1 : 1;\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildEffect({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      animationProgress,\n      parameters: [radius],\n    }) => ({\n      dist: Math.cos(animationProgress * 2 * Math.PI) * radius,\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, dist },\n      dimensions: [width, height],\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildEffect, Coord, Image } from '../domain/types';\nimport { mapImage, setPixel, TRANSPARENT_COLOR } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const fill = buildEffect({\n  disabled: true,\n  name: 'Fill Transparent',\n  description:\n    'Makes transparent all pixels of similar color surrounding a point',\n  params: [\n    sliderParam({\n      name: 'Tolerance',\n      defaultValue: 50,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [tolerance] }) => {\n    const matchP = getSrcPixel([0, 0]);\n\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    return [0, 0, 0, 0];\n  }),\n});\n\nconst fillFn = (image: Image, frameIndex: number, coord: Coord) => {\n  const visited = (() => {\n    const set = new Set<string>();\n    return {\n      set: (x: number, y: number) => {\n        set.add(`${x}-${y}`);\n      },\n      has: (x: number, y: number) => set.has(`${x}-${y}`),\n    };\n  })();\n\n  const set = (x: number, y: number) =>\n    setPixel({\n      image,\n      frameIndex,\n      color: TRANSPARENT_COLOR,\n      coord: [x - 1, y],\n    });\n\n  const s: { x1: number; x2: number; y: number; dy: number }[] = [];\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1], dy: 1 });\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1] - 1, dy: -1 });\n\n  while (s.length > 0) {\n    const n = s.pop()!;\n    let x = n.x1;\n    let y = n.y;\n    if (visited.has(x, y)) {\n      while (visited.has(x - 1, y)) {\n        set(x - 1, y);\n        x = x - 1;\n      }\n    }\n\n    if (x < n.x1) {\n      s.push({ x1: x, x2: n.x1 - 1, y: y - n.dy, dy: n.dy * -1 });\n    }\n\n    while (n.x1 < n.x2) {\n      while (visited.has(n.x1, y)) {\n        set(n.x1, y);\n      }\n    }\n  }\n};\n\n/*\nfn fill(x, y):\n  if not Inside(x, y) then return\n  let s = new empty queue or stack\n  Add (x, x, y, 1) to s\n  Add (x, x, y - 1, -1) to s\n  while s is not empty:\n    Remove an (x1, x2, y, dy) from s\n    let x = x1\n    if Inside(x, y):\n      while Inside(x - 1, y):\n        Set(x - 1, y)\n        x = x - 1\n    if x < x1:\n      Add (x, x1-1, y-dy, -dy) to s\n    while x1 < x2:\n      while Inside(x1, y):\n        Set(x1, y)\n        x1 = x1 + 1\n      Add (x, x1 - 1, y+dy, dy) to s\n      if x1 - 1 > x2:\n        Add (x2 + 1, x1 - 1, y-dy, -dy)\n      while x1 < x2 and not Inside(x1, y):\n        x1 = x1 + 1\n      x = x1\n*/\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildEffect({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      animationProgress,\n      dimensions: [width, height],\n      parameters: [radius],\n    }) => {\n      const expanding = animationProgress < 0.5;\n      return {\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\n        centerX: width / 2,\n        centerY: height / 2,\n      };\n    },\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { adjustSaturation, mapImage } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nconst MAX_GRID_SIZE = 64;\n\nexport const grid = buildEffect({\n  name: 'Grid',\n  description: 'Removes the color from all pixels not aligned with a grid',\n  params: [\n    sliderParam({\n      name: 'Grid Size',\n      description: 'The length of each square in the grid',\n      defaultValue: 24,\n      min: 2,\n      max: MAX_GRID_SIZE,\n      step: 2,\n    }),\n    sliderParam({\n      name: 'Grid Angle',\n      defaultValue: 45,\n      min: 0,\n      max: 90,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    let isOnGrid = false;\n    if (gridAngle % 90 === 0) {\n      // Vertical/Horizonal lines\n      isOnGrid = x % gridSize === 0 || y % gridSize === 0;\n    } else {\n      // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\n      // Larger threshold = thicker lines.\n      const threshold =\n        ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\n\n      const onGrid = (angleDegrees: number) => {\n        const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\n        return Math.abs(Math.round(n) - n) < threshold;\n      };\n\n      isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\n    }\n\n    return isOnGrid ? p : adjustSaturation(p, -100);\n  }),\n});\n\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\n","import { Stack, Typography } from '@material-ui/core';\nimport * as convert from 'color-convert';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\nimport { toHexColor } from '../domain/utils';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor =\n    value === undefined\n      ? undefined\n      : toHexColor([...convert.hsl.rgb([value, 255, 255]), 255]);\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        onChangeComplete={({ hsl }) => onChange(hsl.h)}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueChange = buildEffect({\n  name: 'Hue Change',\n  description: 'Change the hue of the image to some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftTowardsHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value: string;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() => {\n            if (val.length > 0) {\n              onChange(val);\n            }\n          }}\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value}\n    />\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage, shiftHue } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildEffect({\n  name: 'Hue Shift',\n  description: 'Shift the hue of each pixel in the image by some amount',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How much to shift the hue of each pixel',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [amount] }) =>\n    shiftHue(getSrcPixel(coord), (amount / 100) * 360)\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShiftPulse = buildEffect({\n  name: 'Hue Shift Pulse',\n  description: 'Shift the hue to the given value in a pulsating manner',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, frameCount, frameIndex, parameters: [hue] }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      if (isBackground) {\n        return srcPixel;\n      }\n\n      const amount = Math.abs(Math.sin(Math.PI * (frameIndex / frameCount)));\n      return shiftTowardsHue(srcPixel, hue, amount * 360);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute, shiftHue } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueWave = buildEffect({\n  name: 'Hue Wave',\n  description: 'Shifts the hue of pixels in the image in a wave motion',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the hue shift effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many waves you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: -1 * animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord,\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const [x, y] = coord;\n      const amount = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return shiftHue(getSrcPixel(coord), (amount / 100) * 360);\n    }\n  ),\n});\n","import seedrandom from 'seedrandom';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n} from '../domain/utils';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildEffect({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [seed] }) => {\n    const random = seedrandom(seed);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import * as convert from 'color-convert';\nimport { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const nuke = buildEffect({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const threshold = animationProgress * 255;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImage,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildEffect({\n  name: 'Party',\n  description: 'Shift the hue of the image over the course of the animation',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      animationProgress,\n      parameters: [type, amount, shiftSpeed],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n\n      if (isBackground && type === 'background') {\n        return colorFromHue(newH);\n      }\n\n      if (!isBackground && type === 'foreground') {\n        return shiftTowardsHue(srcPixel, newH, amount);\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage, shiftHue } from '../domain/utils';\n\nexport const partyTwo = buildEffect({\n  name: 'Party Two',\n  description:\n    'Shift the hue of each individual pixel over the course of the animation',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const srcPixel = getSrcPixel(coord);\n    const isBackground = isTransparent(srcPixel);\n\n    return isBackground\n      ? srcPixel\n      : shiftHue(srcPixel, animationProgress * 360);\n  }),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheel = buildEffect({\n  name: 'Pinwheel',\n  description: 'Create a pinwheel of colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ parameters: [groupCount, colors, offsetX, offsetY] }) => {\n      const ribbonCount = colors.length * groupCount;\n      const ribbonArcDegrees = Math.round(360 / ribbonCount);\n      // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n      //  won't get a smooth transition.\n      // We'll cut off colors from the end of the list until we get an even multiple.\n      let colorsLength = colors.length;\n      while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n        colorsLength -= 1;\n      }\n\n      return {\n        colorsLength,\n        ribbonArcDegrees,\n      };\n    },\n    ({\n      computed: { ribbonArcDegrees, colorsLength },\n      coord,\n      dimensions,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, colors, offsetX, offsetY],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const center: Coord = [\n        dimensions[0] / 2 + offsetX,\n        dimensions[1] / 2 - offsetY,\n      ];\n      const pointAngle = calculateAngle(coord, center);\n\n      const colorIdx = Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorsLength) + colorIdx) %\n        colorsLength;\n      return colors[idx];\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelParty = buildEffect({\n  name: 'Pinwheel Party',\n  description: 'Create a pinwheel of party colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n    }) => {\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n      return { center };\n    },\n    ({\n      computed: { center },\n      coord,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, type, amount],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const isBackground = isTransparent(srcPixel);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return srcPixel;\n      }\n\n      const pointAngle = calculateAngle(coord, center);\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(srcPixel, newH, amount);\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radiance = buildEffect({\n  name: 'Radiance',\n  description: 'Radiate colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], parameters: [groupCount, colors] }) => ({\n      colorList: range(0, groupCount).flatMap(() => colors),\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, colorList },\n      dimensions: [width, height],\n      coord,\n      animationProgress,\n      parameters: [_groupCount, _colors, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const maxDist = Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      );\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const colorIdx =\n        Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n        colorList.length;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorList.length) + colorIdx) %\n        colorList.length;\n      return colorList[idx];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceParty = buildEffect({\n  name: 'Radiance Party',\n  description: 'Radiate party colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height] }) => ({\n      centerX: width / 2,\n      centerY: height / 2,\n      maxDist: Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      ),\n    }),\n    ({\n      computed: { centerX, centerY, maxDist },\n      coord,\n      animationProgress,\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const newH =\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\n          360 * animationProgress) %\n        360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(src, newH, amount);\n    }\n  ),\n});\n","import { minBy, sortBy } from 'remeda';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  colorDiff,\n  fromHexColor,\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n  mapImageWithPrecompute,\n  toHexColor,\n  TRANSPARENT_COLOR,\n} from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const reduceColorPalette = buildEffect({\n  name: 'Reduce Color Palette',\n  description:\n    'Reduce the number of unique colors in the gif, to reduce the file size.' +\n    'This can be a slow operation depending on the number of final colors',\n  params: [\n    sliderParam({\n      name: 'Percent Reduction',\n      description:\n        '0% will have no effect, 100% will result in just one unique color in the result',\n      defaultValue: 70,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image, parameters: [percentReduction] }) => {\n      // Buid up a set of all unique colors.\n      // These will be our data points that we're going to group into to N clusters\n      const allColorsSet = new Set<string>();\n      mapFrames(image, (frame) =>\n        mapCoords(image.dimensions, (coord) => {\n          const px = getPixelFromSource(image.dimensions, frame, coord);\n          if (!isTransparent(px)) {\n            allColorsSet.add(toHexColor(px));\n          }\n          return TRANSPARENT_COLOR; // Not actually used, just makes TS happy\n        })\n      );\n\n      const allColors = Array.from(allColorsSet).map(fromHexColor);\n      const numColors = Math.max(\n        Math.floor((allColors.length * (100 - percentReduction)) / 100),\n        1\n      );\n\n      // Create a mapping of each unique color to the list of colors are the closest to it.\n      // We'll then pick the top N colors.\n      // Lastly, we'll replace every pixel with the color that it reduces to.\n\n      // colorMap[i].numClosestColors is the number of colors closest to allColors[i]\n      const colorMap: { color: Color; numClosestColors: number }[] =\n        allColors.map((c) => ({\n          color: c,\n          numClosestColors: 0,\n        }));\n\n      for (let i = 1; i < allColors.length; i += 1) {\n        let closestColorIdx = 0;\n        let closetsColorDist = colorDiff(\n          allColors[i],\n          allColors[closestColorIdx]\n        );\n        // Find the other color that is closest to this one\n        for (let k = 0; k < allColors.length; k += 1) {\n          if (k === i) {\n            // Don't check the distance between this color and itself\n            continue;\n          }\n          const dist = colorDiff(allColors[k], allColors[i]);\n          if (dist < closetsColorDist) {\n            closestColorIdx = k;\n            closetsColorDist = dist;\n          }\n        }\n        colorMap[closestColorIdx].numClosestColors += 1;\n      }\n\n      const colorPalette = sortBy(colorMap, [(c) => c.numClosestColors, 'desc'])\n        .slice(0, numColors)\n        .map(({ color }) => color);\n\n      return { colorPalette };\n    },\n    ({ coord, getSrcPixel, computed: { colorPalette } }) => {\n      const px = getSrcPixel(coord);\n      if (isTransparent(px)) {\n        return px;\n      }\n      // Find the color in the palette this one is closest to\n      const closestColor = minBy(colorPalette, (top) => colorDiff(top, px))!;\n      return closestColor;\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const repeatAnimation = buildEffect({\n  name: 'Repeat Animation',\n  description: 'Repeats the current animation some number of times',\n  params: [\n    sliderParam({\n      name: 'Number of Repeats',\n      defaultValue: 1,\n      min: 1,\n      max: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [numRepeats] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\n      (i) => image.frames[i % image.frames.length]\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildEffect({\n  name: 'Resize Image',\n  description:\n    'Change the dimensions of the image. ' +\n    'If bigger than original, the extra space will be transparent. ' +\n    'If smaller, the image will be cropped. ',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight] }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n    const newWidth =\n      resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n    return resizeImageUtil({\n      image,\n      newWidth,\n      newHeight,\n    });\n  },\n});\n","import { reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const reverseAnimation = buildEffect({\n  name: 'Reverse Animation',\n  description: 'Reverses the animation',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: reverse(image.frames),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const ripple = buildEffect({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the ripple effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many ripples you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord: [x, y],\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const offset = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return getSrcPixel([x + offset, y]);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const rotate = buildEffect({\n  name: 'Rotate',\n  description: 'Make the image rotate about the center point',\n  params: [\n    radioParam<'clockwise' | 'counter'>({\n      name: 'Direction',\n      defaultValue: 'clockwise',\n      options: [\n        { name: 'Clockwise', value: 'clockwise' },\n        { name: 'Counter-Clockwise', value: 'counter' },\n      ],\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [direction] }) => {\n      const amount = animationProgress * (direction === 'counter' ? 1 : -1);\n      return {\n        cos: Math.cos(2 * Math.PI * amount),\n        sin: Math.sin(2 * Math.PI * amount),\n      };\n    },\n    ({\n      dimensions: [width, height],\n      coord: [x, y],\n      computed: { cos, sin },\n      getSrcPixel,\n    }) => {\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\n\nexport const roxbury = buildEffect({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], animationProgress }) => {\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(animationProgress * 4);\n      const phaseIdx = (animationProgress - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      return {\n        angle,\n        cos: Math.cos(-angle * 1.35),\n        sin: Math.sin(-angle * 1.35),\n        rotatePointX: width * 0.25,\n        rotatePointY: height * 0.7,\n      };\n    },\n    ({\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n      const newCoord: Coord = [\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildEffect({\n  name: 'Shake',\n  description: 'Make the image shake back and forth',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: Math.round(\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\n      ),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y])\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { getPixelFromSource, mapCoords } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const slowAnimation = buildEffect({\n  name: 'Slow Animation',\n  description: 'Attempts to slow the animation by adding intermediate frames',\n  params: [\n    radioParam<'basic' | 'smooth'>({\n      name: 'Interpolation Type',\n      options: [\n        { name: 'Basic', value: 'basic' },\n        { name: 'Smooth', value: 'smooth' },\n      ],\n      defaultValue: 'basic',\n      description:\n        'With basic interpolation, frames are simply duplicated. ' +\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\n    }),\n  ],\n  fn: ({ image, parameters: [type] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\n\n      // Even numbered frames are just the original frames\n      if (i % 2 === 0) {\n        return image.frames[i / 2];\n      }\n\n      const ogFrameIdx = (i - 1) / 2;\n\n      if (type === 'basic') {\n        // Intermediate frame is simply the previous OG frame\n        return image.frames[ogFrameIdx];\n      }\n\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\n      return mapCoords(image.dimensions, (coord) => {\n        const [r1, g1, b1, a1] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx],\n          coord\n        );\n        const [r2, g2, b2, a2] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx + 1],\n          coord\n        );\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\n      });\n    }),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const spin = buildEffect({\n  disabled: true,\n  name: 'Spin',\n  description: 'Make the image spin in a 3D-like way',\n  params: [],\n  fn: mapImage(\n    ({ image, coord: [x, y], frameCount, frameIndex, getSrcPixel }) => {\n      const centerX = image.dimensions[0] / 2;\n      const idx = frameIndex / frameCount;\n      // 0% -> 0\n      // 25% -> Pi / 2\n      // 50% -> Pi\n      // 75% -> 3/2 * Pi\n      // 100% -> 2 * Pi\n      const angle = 2 * Math.PI * idx;\n      const newX = Math.round(centerX + x * Math.cos(angle));\n      return getSrcPixel([newX, y]);\n    }\n  ),\n});\n\n/*\nx = centerX\nnewX = centerX\n\nx = 0, idx = 0, angle = cos(0) = 1, relX = centerX - 0\n  newX = 0\nx = 0, idx = 25%, angle = cos(45deg) ~ 0.5, relX = centerX - 0\n  newX = centerX - cos(45) * x\nx = 0, idx = 50%, angle = cos(90deg) = 0, relX = centerX - 0\n  newX = (centerX - 0)\n\nx = 25%, idx = 25%, angle ~ 0.5, relX = centerX - 0\n  newX = centerX - angle * x\n*/\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildEffect({\n  name: 'Static',\n  description: 'Adds random static to the image',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      if (isBackground && type === 'background') {\n        const inverse = Math.ceil(random() * 100) < strength;\n        const grey = Math.ceil(random() * 255);\n\n        return inverse ? [grey, grey, grey, 255] : src;\n      }\n\n      const isStatic = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return isStatic ? [grey, grey, grey, src[3]] : src;\n    }\n  ),\n});\n","import { Checkbox, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst CheckboxParam: React.FC<{\n  name: string;\n  value?: boolean;\n  description?: string;\n  onChange: (v: boolean) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Checkbox\n          aria-label={name}\n          checked={value}\n          onChange={(e, value) => onChange(value)}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function checkboxParam(args: {\n  name: string;\n  defaultValue: boolean;\n  description?: string;\n}): ParamFunction<boolean> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <CheckboxParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, mapImage, colorDiff } from '../domain/utils';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparency = buildEffect({\n  name: 'Transparency',\n  description: 'Set certain pixels to be transparent',\n  params: [\n    checkboxParam({\n      name: 'Matches are Transparent',\n      description:\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\n      defaultValue: true,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n      step: 2,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      parameters: [matchesTransparent, selectedColor, tolerance],\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const withinTolerance = colorDiff(src, selectedColor) * 100 <= tolerance;\n\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\n        return [src[0], src[1], src[2], 0];\n      }\n      return src;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildEffect({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ] as const,\n  fn: mapImage(({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\n    getSrcPixel([x + transX, y + transY])\n  ),\n});\n","import { pipe, reject, sortBy } from 'remeda';\nimport { ParamFunction, Effect } from '../domain/types';\nimport { assert } from '../domain/utils';\nimport { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { bounceAnimation } from './bounce-animation';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { expand } from './expand';\nimport { fill } from './fill';\nimport { fisheye } from './fisheye';\nimport { grid } from './grid';\nimport { hueChange } from './hue-change';\nimport { hueShift } from './hue-shift';\nimport { hueShiftPulse } from './hue-shift-pulse';\nimport { hueWave } from './hue-wave';\nimport { lightning } from './lightning';\nimport { nuke } from './nuke';\nimport { party } from './party';\nimport { partyTwo } from './party-two';\nimport { pinwheel } from './pinwheel';\nimport { pinwheelParty } from './pinwheel-party';\nimport { radiance } from './radiance';\nimport { radianceParty } from './radiance-party';\nimport { reduceColorPalette } from './reduce-color-palette';\nimport { repeatAnimation } from './repeat-animation';\nimport { resizeImage } from './resize-image';\nimport { reverseAnimation } from './reverse-animation';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { slowAnimation } from './slow-animation';\nimport { spin } from './spin';\nimport { staticc } from './static';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nexport const POSSIBLE_EFFECTS = pipe(\n  [\n    adjustImage,\n    backgroundColor,\n    backgroundImage,\n    bounce,\n    bounceAnimation,\n    circle,\n    colors,\n    colorsBackground,\n    doubleVision,\n    expand,\n    fill,\n    fisheye,\n    grid,\n    hueChange,\n    hueShift,\n    hueShiftPulse,\n    hueWave,\n    lightning,\n    nuke,\n    party,\n    partyTwo,\n    pinwheel,\n    pinwheelParty,\n    radiance,\n    radianceParty,\n    reduceColorPalette,\n    repeatAnimation,\n    resizeImage,\n    reverseAnimation,\n    ripple,\n    rotate,\n    roxbury,\n    shake,\n    slowAnimation,\n    spin,\n    staticc,\n    transparency,\n    transpose,\n  ],\n  sortBy((x) => x.name),\n  reject((x) => x.disabled)\n);\n\nexport const effectByName = (\n  name: string\n): Effect<readonly ParamFunction<any>[]> => {\n  const t = POSSIBLE_EFFECTS.find((t) => t.name === name);\n  assert(t, `Could not find matching effect: ${name}`);\n  return t as any as Effect<readonly ParamFunction<any>[]>;\n};\n","import {\n  Autocomplete,\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  Divider,\n  FormControl,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Effect } from '../domain/types';\n\ninterface SelectedEffect {\n  effect: Effect<any>;\n  paramValues: any[];\n}\n\ninterface ImageEffectProps {\n  selectedEffect: SelectedEffect;\n  possibleEffect: Effect<any>[];\n  index: number;\n  onSelect: (selected: SelectedEffect) => void;\n  onRemove: () => void;\n  onMoveBefore?: () => void;\n  onMoveAfter?: () => void;\n}\n\nexport const ImageEffect: React.FC<ImageEffectProps> = ({\n  selectedEffect,\n  possibleEffect,\n  index,\n  onSelect,\n  onRemove,\n  onMoveBefore,\n  onMoveAfter,\n}) => {\n  const [paramsOpen, setParamsOpen] = React.useState(false);\n  const [currParams, setCurrParams] = React.useState([\n    ...selectedEffect.paramValues,\n  ]);\n  const [dirty, setDirty] = React.useState(false);\n  const closeDialog = ({ save }: { save: boolean }) => {\n    setParamsOpen(false);\n    if (save && dirty) {\n      onSelect({\n        ...selectedEffect,\n        paramValues: currParams,\n      });\n    } else {\n      setCurrParams([...selectedEffect.paramValues]);\n    }\n    setDirty(false);\n  };\n\n  return (\n    <Paper style={{ padding: 8 }} elevation={3} sx={{ width: 300 }}>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={2}>\n          <Typography variant=\"subtitle1\">{index + 1}</Typography>\n          <Tooltip title=\"Delete effect\">\n            <IconButton aria-label=\"delete\" onClick={onRemove}>\n              <Icon>delete</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move effect earlier\">\n            <IconButton\n              aria-label=\"move-before\"\n              onClick={onMoveBefore}\n              disabled={!onMoveBefore}\n            >\n              <Icon>arrow_upward</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move effect later\">\n            <IconButton\n              aria-label=\"move-after\"\n              onClick={onMoveAfter}\n              disabled={!onMoveAfter}\n            >\n              <Icon>arrow_downward</Icon>\n            </IconButton>\n          </Tooltip>\n        </Stack>\n        <Stack direction=\"row\" spacing={4}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={selectedEffect.effect.name}\n              options={possibleEffect.map((t) => t.name)}\n              onChange={(event, newEffectName) => {\n                const t = possibleEffect.find((t) => t.name === newEffectName)!;\n                // Reset all the params when you select a new effect\n                onSelect({\n                  effect: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n              renderInput={(params) => <TextField {...params} label=\"Effect\" />}\n            />\n          </FormControl>\n        </Stack>\n        {selectedEffect.effect.params.length > 0 ? (\n          <Button\n            variant=\"contained\"\n            startIcon={<Icon>edit</Icon>}\n            onClick={() => setParamsOpen(!paramsOpen)}\n          >\n            Edit Parameters\n          </Button>\n        ) : (\n          <Button variant=\"contained\" disabled>\n            (No Parameters Available)\n          </Button>\n        )}\n        <Dialog fullWidth maxWidth=\"sm\" open={paramsOpen}>\n          <DialogTitle>{selectedEffect.effect.name} Parameters</DialogTitle>\n          <DialogContent>\n            <Stack divider={<Divider />} spacing={2}>\n              {selectedEffect.effect.description && (\n                <Typography variant=\"caption\">\n                  {selectedEffect.effect.description}\n                </Typography>\n              )}\n              {selectedEffect.effect.params.map(\n                // Create elements for each of the parameters for the selectect effect.\n                // Each of these would get an onChange event so we know when the user has\n                //  selected a value.\n                (param: ParamFunction<any>, idx: number) => {\n                  const ele = param.fn({\n                    value: currParams[idx],\n                    onChange: (v) => {\n                      setDirty(true);\n                      setCurrParams(\n                        currParams.map((x, i) => {\n                          if (i === idx) {\n                            return v;\n                          }\n                          return x;\n                        })\n                      );\n                    },\n                  });\n                  return (\n                    <React.Fragment\n                      key={`${selectedEffect.effect.name}-${param.name}`}\n                    >\n                      {ele}\n                    </React.Fragment>\n                  );\n                }\n              )}\n            </Stack>\n          </DialogContent>\n          <DialogActions>\n            <Button\n              variant=\"outlined\"\n              autoFocus\n              onClick={() => {\n                closeDialog({ save: false });\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"contained\"\n              autoFocus\n              disabled={!dirty}\n              onClick={() => {\n                closeDialog({ save: true });\n              }}\n            >\n              Save and Close\n            </Button>\n          </DialogActions>\n        </Dialog>\n      </Stack>\n    </Paper>\n  );\n};\n","import {\n  Button,\n  CircularProgress,\n  Icon,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Effect, AppStateEffect } from '../domain/types';\nimport { replaceIndex } from '../domain/utils';\nimport { effectByName } from '../effects';\nimport { ImageEffect } from './ImageEffect';\n\ninterface EffectListProps {\n  currentEffect: AppStateEffect[];\n  possibleEffects: Effect<any>[];\n  onEffectsChange: (t: AppStateEffect[]) => void;\n}\n\nconst effectKey = (t: AppStateEffect, idx: number): string =>\n  `${t.effectName}-${idx}-${\n    t.state.status === 'done' ? t.state.image.gif.substring(0, 10) : 'pending'\n  }`;\n\nexport const ImageEffectList: React.FC<EffectListProps> = ({\n  currentEffect,\n  possibleEffects,\n  onEffectsChange,\n}) => (\n  <Stack spacing={4}>\n    <Typography variant=\"h5\">Image Effects</Typography>\n    {currentEffect.map((t, tIdx) => (\n      <Stack direction={'row'} key={effectKey(t, tIdx)} spacing={4}>\n        <ImageEffect\n          index={tIdx}\n          possibleEffect={possibleEffects}\n          selectedEffect={{\n            effect: effectByName(t.effectName),\n            paramValues: t.paramsValues,\n          }}\n          onRemove={() =>\n            onEffectsChange(\n              currentEffect.filter((nextT, newIdx) => newIdx !== tIdx)\n            )\n          }\n          onMoveBefore={\n            tIdx > 0\n              ? () =>\n                  onEffectsChange(\n                    currentEffect.map((nextT, newIdx) => {\n                      if (newIdx === tIdx - 1) {\n                        // This is the next item in the list\n                        return currentEffect[newIdx + 1];\n                      } else if (tIdx === newIdx) {\n                        // This is the previous item\n                        return currentEffect[tIdx - 1];\n                      } else {\n                        return nextT;\n                      }\n                    })\n                  )\n              : undefined\n          }\n          onMoveAfter={\n            tIdx < currentEffect.length - 1\n              ? () =>\n                  onEffectsChange(\n                    currentEffect.map((nextT, newIdx) => {\n                      if (newIdx === tIdx + 1) {\n                        // This is the previous item in the list\n                        return currentEffect[newIdx - 1];\n                      } else if (tIdx === newIdx) {\n                        // This is the next item\n                        return currentEffect[tIdx + 1];\n                      } else {\n                        return nextT;\n                      }\n                    })\n                  )\n              : undefined\n          }\n          onSelect={(selected) =>\n            onEffectsChange(\n              replaceIndex(\n                currentEffect,\n                tIdx,\n                (t): AppStateEffect => ({\n                  ...t,\n                  effectName: selected.effect.name,\n                  paramsValues: selected.paramValues,\n                })\n              )\n            )\n          }\n        />\n        {t.state.status === 'done' && (\n          <Stack sx={{ width: 200 }}>\n            <img\n              src={t.state.image.gif}\n              alt={`gif-${t.effectName}-${tIdx}`}\n              style={{ maxWidth: '300px', maxHeight: 'auto' }}\n            ></img>\n          </Stack>\n        )}\n        {t.state.status === 'computing' && <CircularProgress size={100} />}\n      </Stack>\n    ))}\n    <Button\n      fullWidth={false}\n      variant=\"contained\"\n      startIcon={<Icon>add</Icon>}\n      size=\"large\"\n      onClick={() =>\n        onEffectsChange([\n          ...currentEffect,\n          {\n            effectName: possibleEffects[0].name,\n            paramsValues: possibleEffects[0].params.map(\n              (p: ParamFunction<any>) => p.defaultValue\n            ),\n            state: { status: 'init' },\n          },\n        ])\n      }\n    >\n      New Effect\n    </Button>\n  </Stack>\n);\n","import { Alert, Button, Icon, Stack, Typography } from '@material-ui/core';\nimport * as lz from 'lz-string';\nimport React from 'react';\nimport { AppState } from '../domain/types';\n\ninterface ImportExportProps {\n  state: AppState;\n  onImport: (o: AppState) => void;\n}\n\nexport const ImportExport: React.FC<ImportExportProps> = ({\n  state,\n  onImport,\n}) => {\n  const [info, setInfo] = React.useState<string | undefined>();\n  const [isInvalid, setInvalid] = React.useState(false);\n\n  const showInfo = (text: string) => {\n    setInfo(text);\n    setTimeout(() => setInfo(undefined), 3000);\n  };\n\n  const showError = () => {\n    setInvalid(true);\n    setTimeout(() => setInvalid(false), 3000);\n  };\n\n  return (\n    <Stack spacing={3}>\n      <Typography variant=\"h5\">Import/Export</Typography>\n      <Button\n        startIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(JSON.stringify(state));\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard\n      </Button>\n\n      <Button\n        startIcon={<Icon>file_download</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={async () => {\n          try {\n            const clipboardContents = await navigator.clipboard.readText();\n            if (!clipboardContents) {\n              showError();\n              return;\n            }\n            const data = JSON.parse(\n              lz.decompressFromBase64(clipboardContents)!\n            );\n            if (!Array.isArray(data.effects)) {\n              showError();\n              return;\n            }\n            onImport(data);\n            setInvalid(false);\n          } catch (e) {\n            console.error(e);\n            showError();\n          }\n        }}\n      >\n        Import from clipboard\n      </Button>\n      {info && (\n        <Alert severity=\"info\" sx={{ maxWidth: '300px' }}>\n          {info}\n        </Alert>\n      )}\n      {isInvalid && (\n        <Alert severity=\"error\" sx={{ maxWidth: '300px' }}>\n          Error importing from clipboard\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/effect.worker.3ee217db.worker.js\");\n}\n","import { RunArgs } from './run';\n// @ts-ignore\nimport RunEffectWorker from './effect.worker';\nimport { AsyncRunMessage, ImageEffectResult } from './types';\n\nexport const runEffectsAsync = (args: RunArgs) =>\n  new Promise<ImageEffectResult>((resolve, reject) => {\n    const worker = new RunEffectWorker();\n\n    worker.addEventListener('error', reject);\n    worker.addEventListener('messageerror', reject);\n\n    worker.onmessage = (message: { data: AsyncRunMessage }) => {\n      // See effect.worker.ts for what messages look like\n      const data = message.data;\n      if (data.status === 'complete') {\n        resolve(data.result);\n      }\n    };\n\n    worker.postMessage(args);\n  });\n","import { readImage, runEffects } from './run';\nimport { runEffectsAsync } from './runAsync';\nimport { AppState, ImageEffectResult, EffectInput } from './types';\nimport { assert } from './utils';\n\nconst ENV = (window as any).ENV as 'DEV' | 'PROD';\n\nexport const computeGifs = async (\n  appState: AppState,\n  onCompute: (image: ImageEffectResult, idx: number) => void\n): Promise<void> => {\n  const effectInputs = appState.effects.map(\n    (t): EffectInput => ({\n      effectName: t.effectName,\n      params: t.paramsValues,\n    })\n  );\n\n  assert(\n    appState.baseImage,\n    'No source image, this button should be disabled!'\n  );\n\n  let image = await readImage(appState.baseImage);\n\n  // Can't get web workers working with the dev build, so just use the synchrounous version\n  //  if not a prod build.\n  const run = ENV === 'DEV' ? runEffects : runEffectsAsync;\n  for (let i = 0; i < effectInputs.length; i += 1) {\n    const start = Date.now();\n\n    const result = await run({\n      randomSeed: appState.baseImage,\n      image,\n      effectInput: effectInputs[i],\n      fps: appState.fps,\n    });\n\n    // Google analytics\n    ga('send', {\n      hitType: 'timing',\n      timingCategory: 'computeStep',\n      timingVar: effectInputs[i].effectName,\n      timingValue: Math.ceil((Date.now() - start) / 1000),\n    });\n\n    image = result.image;\n\n    onCompute(result, i);\n  }\n};\n","import { AppState, AppStateEffect } from './domain/types';\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nexport const getStoredAppState = (): AppState | undefined => {\n  try {\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (stored) {\n      const savedState = JSON.parse(stored);\n      if (Array.isArray(savedState.effects)) {\n        return savedState;\n      }\n    }\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error loading state from local storage', err.stack || err);\n  }\n\n  return undefined;\n};\n\nexport const saveAppState = (state: AppState) => {\n  try {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, serializeAppState(state));\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error saving state to local storage', err.stack || err);\n  }\n};\n\nexport const clearAppState = () => {\n  try {\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error clearing state from local storage', err.stack || err);\n  }\n};\n\nconst serializeAppState = (state: AppState): string => {\n  const toStore: AppState = {\n    ...state,\n    effects: state.effects.map(\n      (t): AppStateEffect => ({\n        ...t,\n        // Remove the computed image for the state before storing.\n        // This just bloats the storage and doesn't keep anything that isn't reproduceable.\n        state: { status: 'init' },\n      })\n    ),\n  };\n  return JSON.stringify(toStore);\n};\n","import {\n  Button,\n  Container,\n  Divider,\n  Icon,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\nimport React from 'react';\n\nimport { Help } from './components/Help';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageEffectList } from './components/ImageEffectList';\nimport { ImportExport } from './components/ImportExport';\nimport { computeGifs } from './domain/computeGifs';\nimport { AppState, AppStateEffect } from './domain/types';\nimport { replaceIndex } from './domain/utils';\nimport * as localStorage from './localStorage';\nimport { sliderParam } from './params/sliderParam';\nimport { POSSIBLE_EFFECTS } from './effects';\n\n// Set to true to expose the current state as window.STATE.\nconst DEBUG = false;\n\n// Number of millis to wait after a change before recomputing the gif\nconst COMPUTE_DEBOUNCE_MILLIS = 1000;\n\n// Increase this by 1 when there's a breaking change to the app state.\n// Don't change this unless we have to!\nconst CURRENT_APP_STATE_VERSION = 2;\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Final Gif Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nconst DEFAULT_STATE: AppState = {\n  version: CURRENT_APP_STATE_VERSION,\n  effects: [],\n  baseImage: undefined,\n  fps: DEFAULT_FPS,\n};\n\nexport const App: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n  const [doCompute, setDoCompute] = React.useState(false);\n  const [computeTimer, setComputeTimer] = React.useState<null | NodeJS.Timeout>(\n    null\n  );\n\n  React.useEffect(() => {\n    // If we have local storage state on startup, then reload that\n    const stored = localStorage.getStoredAppState();\n    if (stored) {\n      if (stored.version === CURRENT_APP_STATE_VERSION) {\n        setStateRaw(stored);\n        setDoCompute(true);\n      } else {\n        // TODO Might be nice to tell the user we erased their previous stuff\n        localStorage.clearAppState();\n      }\n    }\n  }, []);\n\n  const setState = React.useCallback(\n    (\n      fn: (oldState: AppState) => AppState,\n      { compute }: { compute: 'no' | 'now' | 'later' }\n    ) => {\n      setStateRaw((oldState) => {\n        const newState = fn(oldState);\n        localStorage.saveAppState(newState);\n\n        if (DEBUG) {\n          (window as any).STATE = newState;\n        }\n\n        if (compute !== 'no') {\n          // Compute the gif some time from now.\n          // Other changes within this time should push the compute time back\n          if (computeTimer) {\n            clearTimeout(computeTimer);\n            setComputeTimer(null);\n          }\n\n          if (compute === 'now') {\n            setDoCompute(true);\n          } else {\n            setDoCompute(false);\n            setComputeTimer(\n              setTimeout(() => {\n                setComputeTimer(null);\n                setDoCompute(true);\n              }, COMPUTE_DEBOUNCE_MILLIS)\n            );\n          }\n        }\n\n        return newState;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  React.useEffect(() => {\n    if (!doCompute) {\n      return;\n    }\n\n    // TODO What happens if new changes come in while we're already computing?\n    // Need to throw away previous results and calculate new ones.\n    setDoCompute(false);\n    (async () => {\n      setState(\n        (prevState) => ({\n          ...prevState,\n          effects: prevState.effects.map(\n            (t): AppStateEffect => ({\n              ...t,\n              state: { status: 'computing' },\n            })\n          ),\n        }),\n        { compute: 'no' }\n      );\n      // TODO error handling\n      await computeGifs(state, (image, computeIdx) => {\n        setState(\n          (prevState) => ({\n            ...prevState,\n            effects: replaceIndex(\n              prevState.effects,\n              computeIdx,\n              (t): AppStateEffect => ({\n                ...t,\n                state: { status: 'done', image },\n              })\n            ),\n          }),\n          { compute: 'no' }\n        );\n      });\n    })();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [doCompute]);\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container maxWidth=\"md\">\n        <Stack spacing={4} justifyContent=\"space-evenly\" divider={<Divider />}>\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />}>\n            <Paper style={{ padding: 16 }}>\n              <Help />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={1}>\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Choose a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState(\n                      (prevState) => ({\n                        ...prevState,\n                        baseImage,\n                      }),\n                      { compute: 'now' }\n                    );\n                  }}\n                />\n                <div style={{ maxWidth: '300px' }}>\n                  {fpsParam.fn({\n                    value: state.fps,\n                    onChange: (fps) =>\n                      setState(\n                        (prevState) => ({\n                          ...prevState,\n                          fps,\n                        }),\n                        { compute: 'later' }\n                      ),\n                  })}\n                </div>\n              </Stack>\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImageEffectList\n                currentEffect={state.effects}\n                possibleEffects={POSSIBLE_EFFECTS}\n                onEffectsChange={(effects) =>\n                  setState(\n                    (prevState) => ({\n                      ...prevState,\n                      effects,\n                    }),\n                    { compute: 'now' }\n                  )\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImportExport\n                state={state}\n                onImport={(o) => setState(() => o, { compute: 'now' })}\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear State</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear the source image and all\n                  effects\n                </Typography>\n                <Button\n                  startIcon={<Icon>clear</Icon>}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  color=\"warning\"\n                  onClick={() => {\n                    localStorage.clearAppState();\n                    setStateRaw(DEFAULT_STATE);\n                  }}\n                >\n                  Clear State\n                </Button>\n              </Stack>\n            </Paper>\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n    </>\n  );\n};\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\nimport * as localStorage from './localStorage';\n\nReactDOM.render(\n  <React.StrictMode>\n    <TopLevelErrorBoundary\n      onClearLocalStorage={() => {\n        localStorage.clearAppState();\n        window.location.reload();\n      }}\n    >\n      <App />\n    </TopLevelErrorBoundary>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}