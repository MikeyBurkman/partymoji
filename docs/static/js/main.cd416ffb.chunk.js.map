{"version":3,"sources":["components/Expandable.tsx","components/Help.tsx","components/ImagePicker.tsx","domain/utils.ts","domain/types.ts","components/HelpTooltip.tsx","params/intParam.tsx","params/sliderParam.tsx","effects/adjust-image.ts","params/colorPickerParam.tsx","effects/background-color.ts","domain/run.ts","params/imagePickerParam.tsx","params/radioParam.tsx","effects/background-image.ts","effects/bounce.ts","effects/bounce-animation.ts","effects/circle.ts","params/variableLengthParam.tsx","effects/colors.ts","effects/colors-background.ts","params/floatParam.tsx","effects/double-vision.ts","effects/expand.ts","effects/fill.ts","effects/fisheye.ts","effects/grid.ts","params/huePickerParam.tsx","effects/hue-change.ts","params/textParam.tsx","effects/hue-shift.ts","effects/hue-shift-pulse.ts","effects/hue-wave.ts","effects/lightning.ts","effects/nuke.ts","effects/party.ts","effects/party-two.ts","effects/pinwheel.ts","effects/pinwheel-party.ts","effects/radiance.ts","effects/radiance-party.ts","effects/reduce-color-palette.ts","effects/repeat-animation.ts","effects/resize-image.ts","effects/reverse-animation.ts","effects/ripple.ts","effects/rotate.ts","effects/roxbury.ts","effects/shake.ts","effects/slow-animation.ts","effects/spin.ts","effects/static.ts","params/checkboxParam.tsx","effects/transparency.ts","effects/transpose.ts","effects/index.ts","components/ImageEffect.tsx","components/ImageEffectList.tsx","components/ImportExport.tsx","domain/effect.worker.ts","domain/runAsync.ts","domain/computeGifs.ts","localStorage.ts","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["Expandable","mainEle","children","React","useState","collapsed","setCollapsed","ClickAwayListener","onClickAway","Box","Button","onClick","style","textTransform","color","Stack","direction","spacing","Icon","Collapse","in","Help","Typography","variant","Divider","Group","Section","SectionHeader","paddingLeft","SectionText","sx","fontSize","marginRight","ImagePicker","currentImageUrl","name","onChange","startIcon","maxWidth","component","type","hidden","accept","event","a","files","Array","from","target","file","readFile","baseImage","maxHeight","src","alt","Promise","resolve","reader","FileReader","onload","result","readAsDataURL","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","clamp","n","min","max","clampColor","TRANSPARENT_COLOR","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","map","frame","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","scaleImage","args","newWidth","newHeight","xRatio","yRatio","newImage","createNewImage","srcX","srcY","getPixel","setPixel","resizeImage","sourceWidth","sourceHeight","xPadding","round","yPadding","range","weightedValue","percent","v1","v2","shiftTowardsHue","hue","amount","convert","hsl","l","rgb","newR","newG","newB","shiftHue","h","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","colorFromHue","adjustSaturation","newSat","abs","colorDiff","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","sqrt","changeFrameCount","currentFrames","i","frameToCopy","replaceIndex","arr","index","newValueFn","buildEffect","params","description","fn","disabled","HelpTooltip","Tooltip","title","IntParam","value","parse","val","setVal","invalidText","setInvalidText","FormControl","TextField","error","onBlur","valid","reason","e","FormHelperText","intParam","defaultValue","isNaN","undefined","SliderParam","step","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","sliderParam","adjustImage","resizeToWidth","resizeToHeight","brightness","contrast","saturation","hasFrameCount","oldWidth","oldHeight","hasScaleChange","ceil","isBiggerImage","currImage","currColor","d","adjustBrightness","adjustContrast","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","p","runEffects","effectInput","randomSeed","fps","seedrandom","effect","effectByName","effectName","transparentColor","getTransparentColor","createGif","encodeTransparency","gif","newFrames","img","gifEncoder","setFrameRate","setRepeat","writeHeader","hexColor","slice","setTransparent","data","on","chunk","push","dataUrl","URL","createObjectURL","Blob","forEach","f","addFrame","finish","readImage","res","rej","getPixels","err","results","shape","numFrames","sliceSize","subarray","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","DEFAULT_IMAGE","RadioParam","options","RadioGroup","t","FormControlLabel","control","Radio","label","radioParam","backgroundImage","imagePickerParam","otherImagePreResize","otherImage","otherImageFrame","otherImageSrc","bounce","speed","yOffset","sin","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","cos","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","oldP","IconButton","newParams","filter","visibility","variableLengthParam","DEFAULT_COLORS","colors","chosenColor","srcPixel","gray","getAveragePixelValue","colorsBackground","bgColor","FloatParam","floatParam","parseFloat","doubleVision","dir","expand","dist","centerX","centerY","fill","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","degrees","HuePickerParam","huePickerParam","hueChange","newHue","hueShift","hueShiftPulse","hueWave","shift","amplitude","period","TextParam","lightningIntensities","lightning","seed","flashIntensity","icf","nuke","party","shiftSpeed","isBackground","newH","partyTwo","pinwheel","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","offsetX","offsetY","center","pointAngle","colorIdx","pinwheelParty","radiance","colorList","flatMap","maxDist","distFromCenter","radianceParty","reduceColorPalette","percentReduction","allColorsSet","allColors","numColors","colorMap","numClosestColors","closestColorIdx","closetsColorDist","k","colorPalette","sortBy","minBy","top","repeatAnimation","numRepeats","resizeImageUtil","reverseAnimation","ripple","rotate","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","shake","slowAnimation","ogFrameIdx","r1","g1","b1","a1","spin","staticc","strength","inverse","grey","isStatic","CheckboxParam","paddingTop","Checkbox","checked","transparency","checkboxParam","matchesTransparent","selectedColor","tolerance","withinTolerance","transpose","POSSIBLE_EFFECTS","reject","find","ImageEffect","selectedEffect","possibleEffect","onSelect","onRemove","onMoveBefore","onMoveAfter","paramsOpen","setParamsOpen","paramValues","currParams","setCurrParams","dirty","setDirty","closeDialog","save","padding","elevation","fullWidth","Autocomplete","disableClearable","newEffectName","renderInput","Dialog","open","DialogTitle","DialogContent","divider","Fragment","DialogActions","autoFocus","ImageEffectList","currentEffect","possibleEffects","onEffectsChange","tIdx","paramsValues","nextT","newIdx","selected","state","status","CircularProgress","size","substring","effectKey","ImportExport","onImport","info","setInfo","isInvalid","setInvalid","showError","setTimeout","output","lz","JSON","stringify","navigator","clipboard","writeText","readText","clipboardContents","isArray","effects","console","Alert","severity","Worker_fn","Worker","runEffectsAsync","worker","RunEffectWorker","addEventListener","onmessage","postMessage","ENV","window","computeGifs","appState","onCompute","effectInputs","run","start","Date","now","ga","hitType","timingCategory","timingVar","timingValue","LOCAL_STORAGE_KEY","clearAppState","localStorage","removeItem","stack","serializeAppState","toStore","fpsParam","DEFAULT_STATE","version","App","setStateRaw","doCompute","setDoCompute","computeTimer","setComputeTimer","useEffect","stored","getItem","savedState","setState","useCallback","oldState","newState","setItem","clearTimeout","prevState","computeIdx","ScopedCssBaseline","Container","justifyContent","pt","o","href","rel","TopLevelErrorBoundary","hasError","errorInfo","this","endIcon","props","onClearLocalStorage","Component","ReactDOM","render","StrictMode","location","reload","document","getElementById"],"mappings":"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","file":"static/js/main.cd416ffb.chunk.js","sourcesContent":["import {\n  Box,\n  Button,\n  ClickAwayListener,\n  Collapse,\n  Icon,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Box>\n        <Button\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ textTransform: 'none', color: 'black' }}\n        >\n          <Stack direction=\"row\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'add' : 'remove'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Box>\n    </ClickAwayListener>\n  );\n};\n","import { Divider, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { Expandable } from './Expandable';\n\nexport const Help: React.FC = () => (\n  <Expandable\n    mainEle={<Typography variant=\"h5\">Click here for Help</Typography>}\n  >\n    <Group>\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Getting Started</Typography>}\n      >\n        <Section>\n          <SectionHeader>\n            Start by importing an image from your device\n          </SectionHeader>\n          <SectionText>You may choose a png, jpg, or gif</SectionText>\n          <SectionText>\n            The frames per second controls how fast the final gif will animate\n          </SectionText>\n        </Section>\n      </Expandable>\n\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Adding Effects</Typography>}\n      >\n        <Group>\n          <Section>\n            <Section>\n              <SectionHeader>\n                Effects are applied to an image to manipulate it\n              </SectionHeader>\n              <SectionText>\n                Some may adjust the basic attributes of an image, such as size,\n                or number of animation frames.\n              </SectionText>\n              <SectionText>\n                thers may apply animated effects, such as making the image spin,\n                or cycle through colors.\n              </SectionText>\n            </Section>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>\n              Animation effects require multiple animaion frames\n            </SectionHeader>\n            <SectionText>\n              The \"Adjust Image\" effect has a \"Frame Count\" paramter.\n            </SectionText>\n            <SectionText>\n              This controls how many frames are in the animation. Typically this\n              is between 10 and 20.\n            </SectionText>\n            <SectionText>\n              More frames will increase both the time to compute the image, and\n              the final file size.\n            </SectionText>\n            <SectionText>\n              Remember that some places (like Slack and Discord) have strict\n              limits on the size of emojis.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>The order of effects matters</SectionHeader>\n            <SectionText>\n              The result of each effect is send to the next effect.\n            </SectionText>\n            <SectionText>\n              Because of this, the order of effects matter.\n            </SectionText>\n            <SectionText>\n              Experiment with moving effects around to see different effects.\n            </SectionText>\n            <SectionText>\n              For instance, applying a background color before rotating the\n              image will have a very different effect than rotating before\n              setting a background color.\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n\n      <Expandable mainEle={<Typography variant=\"h6\">Creating Gifs</Typography>}>\n        <Group>\n          <Section>\n            <SectionHeader>Gifs will compute automatically</SectionHeader>\n            <SectionText>\n              Whenever you add or change an effect, it will compute a new gif\n              next to that effect.\n            </SectionText>\n            <SectionText>\n              The gif next to each effect shows what the results of that effect\n              on the previous gif were.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>Exporting a GIF</SectionHeader>\n            <SectionText>\n              To export a gif, just right click on the gif next to an effect,\n              and click \"Save Image As...\".\n            </SectionText>\n            <SectionText>\n              Importing/exporting further down on the page is used if you want\n              to share your Partymoji steps with someone else!\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n    </Group>\n  </Expandable>\n);\n\nconst Group: React.FC = ({ children }) => <Stack spacing={2}>{children}</Stack>;\n\nconst Section: React.FC = ({ children }) => (\n  <Stack spacing={1}>{children}</Stack>\n);\n\nconst SectionHeader: React.FC = ({ children }) => (\n  <Typography variant=\"body1\" paddingLeft=\"0.5rem\">\n    {children}\n  </Typography>\n);\n\nconst SectionText: React.FC = ({ children }) => (\n  <Typography variant=\"caption\" paddingLeft=\"1.0rem\">\n    <Icon sx={{ fontSize: 8, marginRight: 2 }}>circle</Icon> {children}\n  </Typography>\n);\n","import { Button, Icon, Stack } from '@material-ui/core';\nimport React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  onChange,\n}) => (\n  <Stack spacing={4}>\n    <Button\n      startIcon={<Icon>image</Icon>}\n      sx={{ maxWidth: '300px' }}\n      variant=\"contained\"\n      component=\"label\"\n    >\n      {name}\n      <input\n        type=\"file\"\n        hidden\n        accept=\"image/png,image/jpg,image/jpeg,image/gif\"\n        name=\"source-png\"\n        onChange={async (event) => {\n          const files = Array.from(event.target.files ?? []);\n          const file = files[0];\n          if (file) {\n            // Will be undefined if user clicked the cancel button\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }\n        }}\n      />\n    </Button>\n    {currentImageUrl && (\n      <img\n        style={{ maxWidth: '200px', maxHeight: 'auto' }}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </Stack>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import { AssertionError } from 'assert';\nimport * as convert from 'color-convert';\nimport { range } from 'remeda';\nimport seedrandom from 'seedrandom';\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  Image,\n  ImageData,\n  Random,\n  EffectFn,\n  EffectFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our effect functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress: frameIndex / frameCount,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/**\n * Similar to mapImage, but the first argument pre-computes some things for\n *  each frame, which is then passed to the second callback function.\n * This is useful for performance (only compute things every frame rather than every pixel),\n *  and also allows you to generate some random value that will be the same for every frame.\n */\nexport const mapImageWithPrecompute = <T, R>(\n  compute: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n  }) => R,\n  cb: (args: {\n    computed: R;\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const computed = compute({\n        image,\n        dimensions: image.dimensions,\n        random,\n        parameters,\n        frameCount,\n        frameIndex,\n        animationProgress,\n      });\n\n      return mapCoords(image.dimensions, (coord) =>\n        cb({\n          computed,\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      );\n    });\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Change the dimensions of the image, scaling it to make it fit the new dimensions\n */\nexport const scaleImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const color = getPixel({\n          image,\n          frameIndex,\n          coord: [srcX, srcY],\n        });\n        setPixel({\n          image: newImage,\n          frameIndex,\n          color,\n          coord: [x, y],\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\n/**\n * Will change the image dimensions without altering the scale.\n * If the new dimensions are larger, the image will be centered.\n * If the new dimensions are smaller, it'll be cropped\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const [sourceWidth, sourceHeight] = image.dimensions;\n\n  const xPadding = Math.round((newWidth - sourceWidth) / 2);\n  const yPadding = Math.round((newHeight - sourceHeight) / 2);\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        const color: Color =\n          x > xPadding &&\n          x < newWidth - xPadding &&\n          y > yPadding &&\n          y < newHeight - yPadding\n            ? getPixel({\n                image,\n                frameIndex,\n                coord: [x - xPadding, y - yPadding],\n              })\n            : TRANSPARENT_COLOR;\n        setPixel({\n          image: newImage,\n          frameIndex,\n          coord: [x, y],\n          color,\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8Array(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const duplicateImage = (image: Image): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((f) => new Uint8Array(f)),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftTowardsHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Adds the given amount to the hue of the color.\n * Amount should be between 0 and 360\n */\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\n  return [newR, newG, newB, a];\n};\n\n/**\n * Returns the angle in degrees (0 to 360) betwee the two coordinates\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n\nexport const adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nexport const adjustBrightness = (color: Color, amount: number): Color => {\n  const d = (amount / 100) * 128;\n  const [r, g, b, a] = color;\n  return clampColor([r + d, g + d, b + d, a]);\n};\n\n// Amount: -100 to 100\nexport const adjustContrast = (color: Color, amount: number): Color => {\n  const d = amount / 100 + 1;\n  const [r, g, b, a] = color;\n  return clampColor([\n    d * (r - 128) + 128,\n    d * (g - 128) + 128,\n    d * (b - 128) + 128,\n    a,\n  ]);\n};\n\n/**\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\n */\nexport const colorDiff = (c1: Color, c2: Color): number => {\n  // Red-mean color diff algorithm\n  // https://en.wikipedia.org/wiki/Color_difference\n  const deltaRed = c1[0] - c2[0];\n  const deltaBlue = c1[1] - c2[1];\n  const deltaGreen = c1[2] - c2[2];\n  const rSomething = (c1[0] + c2[0]) / 2;\n\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\n  const gComponent = 4 * deltaGreen * deltaGreen;\n  // 765 = ~ difference between black and white pixels\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\n};\n\nexport const changeFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had fewer than that, then we'll\n  //  duplicate some frames to approximately slow the animation.\n  // If the original has more frames, then we'll discard some frames.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) => {\n      const frameToCopy = Math.floor((i / frameCount) * currentFrames.length);\n      return currentFrames[frameToCopy];\n    }),\n  };\n};\n\n/** Returns a new array where the item at the given index is replaced by the given value */\nexport const replaceIndex = <T>(\n  arr: T[],\n  index: number,\n  newValueFn: (oldValue: T) => T\n): T[] => arr.map((x, i) => (index === i ? newValueFn(x) : x));\n","import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: ImageData[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface EffectFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: T;\n  onChange: (v: T) => void;\n}\n\nexport type ParamFunction<T = any> = {\n  name: string;\n  defaultValue: T;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type EffectFn<Params> = (opts: EffectFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Effect<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  description?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled: boolean;\n}\n\nexport interface EffectWithParams<T extends readonly ParamFunction<any>[]> {\n  effectName: string;\n  paramsValues: T[];\n}\n\nexport interface EffectInput {\n  effectName: string;\n  params: any;\n}\n\nexport const buildEffect = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled?: boolean;\n}): Effect<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  fn: args.fn,\n  disabled: args.disabled ?? false,\n});\n\nexport interface AppStateEffect {\n  effectName: string;\n  paramsValues: any[];\n  state:\n    | { status: 'init' }\n    | { status: 'computing' }\n    | { status: 'done'; image: ImageEffectResult };\n}\n\nexport interface AppState {\n  version: number;\n  baseImage?: string;\n  effects: AppStateEffect[];\n  fps: number;\n}\n\nexport interface ImageEffectResult {\n  gif: string;\n  image: Image;\n}\n\nexport type AsyncRunMessage = {\n  status: 'complete';\n  result: ImageEffectResult;\n};\n","import { Icon, Tooltip } from '@material-ui/core';\nimport React from 'react';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={value}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) => onChange(value as number)}\n        />\n        <Typography variant=\"body2\">{value}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  adjustBrightness,\n  adjustContrast,\n  adjustSaturation,\n  changeFrameCount,\n  getPixelFromSource,\n  mapCoords,\n  mapFrames,\n  scaleImage,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const adjustImage = buildEffect({\n  name: 'Adjust Image',\n  description: 'Leave a parameter at 0 if you want to not change it',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description:\n        'Set how many frames of animation there will be. Leave at 0 to not change the current frame count.',\n      defaultValue: 0,\n      min: 0,\n      max: 60,\n    }),\n    intParam({\n      name: 'Width',\n      description:\n        'Leave at 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Leave at 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [\n      frameCount,\n      resizeToWidth,\n      resizeToHeight,\n      brightness,\n      contrast,\n      saturation,\n    ],\n  }) => {\n    const hasFrameCount = frameCount !== 0;\n\n    const [oldWidth, oldHeight] = image.dimensions;\n\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\n\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\n    const newWidth =\n      hasScaleChange && resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      hasScaleChange && resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\n\n    let currImage = image;\n\n    if (hasFrameCount && frameCount < image.frames.length) {\n      // Reducing the number of frames, so do that first so we have fewer pixels to change\n      currImage = changeFrameCount(currImage, frameCount);\n    }\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = scaleImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n      });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      mapCoords(currImage.dimensions, (coord) => {\n        let currColor = getPixelFromSource(\n          currImage.dimensions,\n          imageData,\n          coord\n        );\n\n        if (brightness !== 0) {\n          currColor = adjustBrightness(currColor, brightness);\n        }\n\n        if (contrast !== 0) {\n          currColor = adjustContrast(currColor, contrast);\n        }\n\n        if (saturation !== 0) {\n          currColor = adjustSaturation(currColor, saturation);\n        }\n\n        return currColor;\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = scaleImage({ image: currImage, newWidth, newHeight });\n    }\n\n    // Finally change the number of frames if we're adding frames\n    if (hasFrameCount && frameCount > image.frames.length) {\n      currImage = changeFrameCount(currImage, frameCount);\n    }\n\n    return currImage;\n  },\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { Color, ParamFunction } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value: Color;\n  description?: string;\n  onChange: (v: Color) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={toHexColor(value)}\n        onChangeComplete={(c) => {\n          onChange(fromHexColor(c.hex));\n        }}\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue: Color;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, isTransparent, mapImage } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\n\nexport const backgroundColor = buildEffect({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [color] }) => {\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\nimport { effectByName } from '../effects';\nimport {\n  Color,\n  Image,\n  ImageData,\n  ImageEffectResult,\n  EffectInput,\n} from './types';\nimport {\n  fromHexColor,\n  getPixelFromSource,\n  isTransparent,\n  randomColor,\n  toHexColor,\n} from './utils';\n\nexport interface RunArgs {\n  randomSeed: string;\n  image: Image;\n  effectInput: EffectInput;\n  fps: number;\n}\n\n// Returns a list of gif data URLs, for each effect\nexport const runEffects = async ({\n  image,\n  effectInput,\n  randomSeed,\n  fps,\n}: RunArgs): Promise<ImageEffectResult> => {\n  const random = seedrandom(randomSeed);\n\n  const effect = effectByName(effectInput.effectName);\n  const result = effect.fn({\n    image,\n    parameters: effectInput.params,\n    random,\n  });\n\n  const transparentColor = getTransparentColor(result, random);\n\n  const gif = await createGif({\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    image: encodeTransparency(result, transparentColor),\n    transparentColor,\n    fps,\n  });\n\n  return {\n    gif,\n    image: result,\n  };\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  image: Image,\n  transparentColor: Color | undefined\n): Image => {\n  const newFrames = image.frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = 0;\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 0; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return {\n    dimensions: image.dimensions,\n    frames: newFrames,\n  };\n};\n\nconst createGif = async ({\n  image,\n  transparentColor,\n  fps,\n}: {\n  image: Image;\n  transparentColor: Color | undefined;\n  fps: number;\n}): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = image.dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    image.frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          const [width, height] = results.shape;\n          // Single frame\n          return res({\n            frames: [Uint8Array.from(results.data)],\n            dimensions: [width, height],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8Array[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          frames.push(\n            results.data.subarray(i * sliceSize, (i + 1) * sliceSize)\n          );\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import React from 'react';\nimport { ImagePicker } from '../components/ImagePicker';\nimport { readImage } from '../domain/run';\nimport { Image, ParamFunction } from '../domain/types';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\ninterface ParamType {\n  dataUrl: string;\n  image: Image;\n}\n\n// Just a 1x1 black jpg. Surprisingly big!\nconst DEFAULT_IMAGE: ParamType = {\n  dataUrl:\n    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\n  image: {\n    dimensions: [1, 1],\n    frames: [new Uint8Array([0, 0, 0, 255])],\n  },\n};\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<ParamType> {\n  return {\n    name,\n    defaultValue: DEFAULT_IMAGE,\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={params.value.dataUrl}\n        name={name}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ dataUrl, image });\n        }}\n      />\n    ),\n  };\n}\n","import {\n  FormControl,\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst RadioParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value: string;\n  description?: string;\n  onChange: (s: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label={name}\n          defaultValue={value}\n          onChange={(event) => onChange(event.target.value)}\n        >\n          {options.map((t) => (\n            <FormControlLabel\n              value={t.value}\n              control={<Radio />}\n              label={t.name}\n              key={t.value}\n            />\n          ))}\n        </RadioGroup>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function radioParam<T extends string>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <RadioParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={(s) => params.onChange(s as T)}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  getPixel,\n  isTransparent,\n  resizeImage,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { radioParam } from '../params/radioParam';\n\nexport const backgroundImage = buildEffect({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image: { dimensions }, parameters: [otherImagePreResize, type] }) => {\n      const otherImage = resizeImage({\n        image: otherImagePreResize.image,\n        newWidth: dimensions[0],\n        newHeight: dimensions[1],\n      });\n      return { otherImage, type };\n    },\n    ({\n      coord,\n      animationProgress,\n      computed: { otherImage, type },\n      getSrcPixel,\n    }) => {\n      const otherImageFrame = Math.floor(\n        animationProgress * otherImage.frames.length\n      );\n      const otherImageSrc = getPixel({\n        image: otherImage,\n        frameIndex: otherImageFrame,\n        coord,\n      });\n\n      const src = getSrcPixel(coord);\n\n      if (type === 'background') {\n        // Only print the other image if the src image is transparent here\n        return isTransparent(src) ? otherImageSrc : src;\n      } else {\n        return isTransparent(otherImageSrc) ? src : otherImageSrc;\n      }\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildEffect({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [speed] }) => ({\n      yOffset: Math.round(speed * Math.sin(animationProgress * 2 * Math.PI)),\n    }),\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x, y + yOffset])\n  ),\n});\n","import { concat, drop, pipe, reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const bounceAnimation = buildEffect({\n  name: 'Bounce Animation',\n  description: 'When the animation finishes, it will be replayed in reverse',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: concat(\n      image.frames,\n      pipe(image.frames, drop(1), reverse(), drop(1))\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildEffect({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [radius] }) => ({\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\n    }),\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y + yOffset])\n  ),\n});\n","import {\n  Button,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ninterface VariableLengthProps<T> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value: T[];\n  description?: string;\n  onChange: (v: T) => void;\n}\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<\n    { param: ParamFunction<any>; pValue: any }[]\n  >(value.map((v) => ({ param: createNewParam(), pValue: v })));\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: pValue,\n            onChange: (newValue) => {\n              const p = params.map((oldP, i) => {\n                if (idx === i) {\n                  return {\n                    param,\n                    pValue: newValue,\n                  };\n                }\n                return oldP;\n              });\n              setParams(p);\n              onChange(p.map((n) => n.pValue));\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange(newParams.map((n) => n.pValue));\n                }}\n                style={{\n                  visibility:\n                    idx === 0 /* Hide delete on first item */\n                      ? 'hidden'\n                      : undefined,\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue,\n              },\n            ];\n            setParams(newParams);\n            onChange(newParams.map((n) => n.pValue));\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue: T[];\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  getAveragePixelValue,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildEffect({\n  name: 'Colors',\n  description: 'Make the image flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { chosenColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (isTransparent(srcPixel)) {\n        return [0, 0, 0, 0];\n      }\n\n      const gray = getAveragePixelValue(srcPixel);\n\n      return [\n        (gray * chosenColor[0]) / 255,\n        (gray * chosenColor[1]) / 255,\n        (gray * chosenColor[2]) / 255,\n        255,\n      ];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildEffect({\n  name: 'Colors Background',\n  description: 'Transparent pixels will flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      bgColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { bgColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      // Make the transparent parts colorful\n      if (isTransparent(srcPixel)) {\n        return bgColor;\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildEffect({\n  name: 'Double Vision',\n  description: 'See the image in double',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\n      const dir = x % 2 === 0 ? -1 : 1;\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildEffect({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      animationProgress,\n      parameters: [radius],\n    }) => ({\n      dist: Math.cos(animationProgress * 2 * Math.PI) * radius,\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, dist },\n      dimensions: [width, height],\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildEffect, Coord, Image } from '../domain/types';\nimport { mapImage, setPixel, TRANSPARENT_COLOR } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const fill = buildEffect({\n  disabled: true,\n  name: 'Fill Transparent',\n  description:\n    'Makes transparent all pixels of similar color surrounding a point',\n  params: [\n    sliderParam({\n      name: 'Tolerance',\n      defaultValue: 50,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [tolerance] }) => {\n    const matchP = getSrcPixel([0, 0]);\n\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    return [0, 0, 0, 0];\n  }),\n});\n\nconst fillFn = (image: Image, frameIndex: number, coord: Coord) => {\n  const visited = (() => {\n    const set = new Set<string>();\n    return {\n      set: (x: number, y: number) => {\n        set.add(`${x}-${y}`);\n      },\n      has: (x: number, y: number) => set.has(`${x}-${y}`),\n    };\n  })();\n\n  const set = (x: number, y: number) =>\n    setPixel({\n      image,\n      frameIndex,\n      color: TRANSPARENT_COLOR,\n      coord: [x - 1, y],\n    });\n\n  const s: { x1: number; x2: number; y: number; dy: number }[] = [];\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1], dy: 1 });\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1] - 1, dy: -1 });\n\n  while (s.length > 0) {\n    const n = s.pop()!;\n    let x = n.x1;\n    let y = n.y;\n    if (visited.has(x, y)) {\n      while (visited.has(x - 1, y)) {\n        set(x - 1, y);\n        x = x - 1;\n      }\n    }\n\n    if (x < n.x1) {\n      s.push({ x1: x, x2: n.x1 - 1, y: y - n.dy, dy: n.dy * -1 });\n    }\n\n    while (n.x1 < n.x2) {\n      while (visited.has(n.x1, y)) {\n        set(n.x1, y);\n      }\n    }\n  }\n};\n\n/*\nfn fill(x, y):\n  if not Inside(x, y) then return\n  let s = new empty queue or stack\n  Add (x, x, y, 1) to s\n  Add (x, x, y - 1, -1) to s\n  while s is not empty:\n    Remove an (x1, x2, y, dy) from s\n    let x = x1\n    if Inside(x, y):\n      while Inside(x - 1, y):\n        Set(x - 1, y)\n        x = x - 1\n    if x < x1:\n      Add (x, x1-1, y-dy, -dy) to s\n    while x1 < x2:\n      while Inside(x1, y):\n        Set(x1, y)\n        x1 = x1 + 1\n      Add (x, x1 - 1, y+dy, dy) to s\n      if x1 - 1 > x2:\n        Add (x2 + 1, x1 - 1, y-dy, -dy)\n      while x1 < x2 and not Inside(x1, y):\n        x1 = x1 + 1\n      x = x1\n*/\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildEffect({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      animationProgress,\n      dimensions: [width, height],\n      parameters: [radius],\n    }) => {\n      const expanding = animationProgress < 0.5;\n      return {\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\n        centerX: width / 2,\n        centerY: height / 2,\n      };\n    },\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { adjustSaturation, mapImage } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nconst MAX_GRID_SIZE = 64;\n\nexport const grid = buildEffect({\n  name: 'Grid',\n  description: 'Removes the color from all pixels not aligned with a grid',\n  params: [\n    sliderParam({\n      name: 'Grid Size',\n      description: 'The length of each square in the grid',\n      defaultValue: 24,\n      min: 2,\n      max: MAX_GRID_SIZE,\n      step: 2,\n    }),\n    sliderParam({\n      name: 'Grid Angle',\n      defaultValue: 45,\n      min: 0,\n      max: 90,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    let isOnGrid = false;\n    if (gridAngle % 90 === 0) {\n      // Vertical/Horizonal lines\n      isOnGrid = x % gridSize === 0 || y % gridSize === 0;\n    } else {\n      // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\n      // Larger threshold = thicker lines.\n      const threshold =\n        ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\n\n      const onGrid = (angleDegrees: number) => {\n        const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\n        return Math.abs(Math.round(n) - n) < threshold;\n      };\n\n      isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\n    }\n\n    return isOnGrid ? p : adjustSaturation(p, -100);\n  }),\n});\n\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\n","import { Stack, Typography } from '@material-ui/core';\nimport * as convert from 'color-convert';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\nimport { toHexColor } from '../domain/utils';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor =\n    value === undefined\n      ? undefined\n      : toHexColor([...convert.hsl.rgb([value, 255, 255]), 255]);\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        onChangeComplete={({ hsl }) => onChange(hsl.h)}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueChange = buildEffect({\n  name: 'Hue Change',\n  description: 'Change the hue of the image to some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftTowardsHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value: string;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() => {\n            if (val.length > 0) {\n              onChange(val);\n            }\n          }}\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value}\n    />\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage, shiftHue } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildEffect({\n  name: 'Hue Shift',\n  description: 'Shift the hue of each pixel in the image by some amount',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How much to shift the hue of each pixel',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [amount] }) =>\n    shiftHue(getSrcPixel(coord), (amount / 100) * 360)\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShiftPulse = buildEffect({\n  name: 'Hue Shift Pulse',\n  description: 'Shift the hue to the given value in a pulsating manner',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, frameCount, frameIndex, parameters: [hue] }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      if (isBackground) {\n        return srcPixel;\n      }\n\n      const amount = Math.abs(Math.sin(Math.PI * (frameIndex / frameCount)));\n      return shiftTowardsHue(srcPixel, hue, amount * 360);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute, shiftHue } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueWave = buildEffect({\n  name: 'Hue Wave',\n  description: 'Shifts the hue of pixels in the image in a wave motion',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the hue shift effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many waves you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: -1 * animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord,\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const [x, y] = coord;\n      const amount = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return shiftHue(getSrcPixel(coord), (amount / 100) * 360);\n    }\n  ),\n});\n","import seedrandom from 'seedrandom';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n} from '../domain/utils';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildEffect({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [seed] }) => {\n    const random = seedrandom(seed);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import * as convert from 'color-convert';\nimport { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const nuke = buildEffect({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const threshold = animationProgress * 255;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImage,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildEffect({\n  name: 'Party',\n  description: 'Shift the hue of the image over the course of the animation',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      animationProgress,\n      parameters: [type, amount, shiftSpeed],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n\n      if (isBackground && type === 'background') {\n        return colorFromHue(newH);\n      }\n\n      if (!isBackground && type === 'foreground') {\n        return shiftTowardsHue(srcPixel, newH, amount);\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage, shiftHue } from '../domain/utils';\n\nexport const partyTwo = buildEffect({\n  name: 'Party Two',\n  description:\n    'Shift the hue of each individual pixel over the course of the animation',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const srcPixel = getSrcPixel(coord);\n    const isBackground = isTransparent(srcPixel);\n\n    return isBackground\n      ? srcPixel\n      : shiftHue(srcPixel, animationProgress * 360);\n  }),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheel = buildEffect({\n  name: 'Pinwheel',\n  description: 'Create a pinwheel of colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ parameters: [groupCount, colors, offsetX, offsetY] }) => {\n      const ribbonCount = colors.length * groupCount;\n      const ribbonArcDegrees = Math.round(360 / ribbonCount);\n      // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n      //  won't get a smooth transition.\n      // We'll cut off colors from the end of the list until we get an even multiple.\n      let colorsLength = colors.length;\n      while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n        colorsLength -= 1;\n      }\n\n      return {\n        colorsLength,\n        ribbonArcDegrees,\n      };\n    },\n    ({\n      computed: { ribbonArcDegrees, colorsLength },\n      coord,\n      dimensions,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, colors, offsetX, offsetY],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const center: Coord = [\n        dimensions[0] / 2 + offsetX,\n        dimensions[1] / 2 - offsetY,\n      ];\n      const pointAngle = calculateAngle(coord, center);\n\n      const colorIdx = Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorsLength) + colorIdx) %\n        colorsLength;\n      return colors[idx];\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelParty = buildEffect({\n  name: 'Pinwheel Party',\n  description: 'Create a pinwheel of party colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n    }) => {\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n      return { center };\n    },\n    ({\n      computed: { center },\n      coord,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, type, amount],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const isBackground = isTransparent(srcPixel);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return srcPixel;\n      }\n\n      const pointAngle = calculateAngle(coord, center);\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(srcPixel, newH, amount);\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radiance = buildEffect({\n  name: 'Radiance',\n  description: 'Radiate colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], parameters: [groupCount, colors] }) => ({\n      colorList: range(0, groupCount).flatMap(() => colors),\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, colorList },\n      dimensions: [width, height],\n      coord,\n      animationProgress,\n      parameters: [_groupCount, _colors, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const maxDist = Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      );\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const colorIdx =\n        Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n        colorList.length;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorList.length) + colorIdx) %\n        colorList.length;\n      return colorList[idx];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceParty = buildEffect({\n  name: 'Radiance Party',\n  description: 'Radiate party colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height] }) => ({\n      centerX: width / 2,\n      centerY: height / 2,\n      maxDist: Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      ),\n    }),\n    ({\n      computed: { centerX, centerY, maxDist },\n      coord,\n      animationProgress,\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const newH =\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\n          360 * animationProgress) %\n        360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(src, newH, amount);\n    }\n  ),\n});\n","import { minBy, sortBy } from 'remeda';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  colorDiff,\n  fromHexColor,\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n  mapImageWithPrecompute,\n  toHexColor,\n  TRANSPARENT_COLOR,\n} from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const reduceColorPalette = buildEffect({\n  name: 'Reduce Color Palette',\n  description:\n    'Reduce the number of unique colors in the gif, to reduce the file size.' +\n    'This can be a slow operation depending on the number of final colors',\n  params: [\n    sliderParam({\n      name: 'Percent Reduction',\n      description:\n        '0% will have no effect, 100% will result in just one unique color in the result',\n      defaultValue: 70,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image, parameters: [percentReduction] }) => {\n      // Buid up a set of all unique colors.\n      // These will be our data points that we're going to group into to N clusters\n      const allColorsSet = new Set<string>();\n      mapFrames(image, (frame) =>\n        mapCoords(image.dimensions, (coord) => {\n          const px = getPixelFromSource(image.dimensions, frame, coord);\n          if (!isTransparent(px)) {\n            allColorsSet.add(toHexColor(px));\n          }\n          return TRANSPARENT_COLOR; // Not actually used, just makes TS happy\n        })\n      );\n\n      const allColors = Array.from(allColorsSet).map(fromHexColor);\n      const numColors = Math.max(\n        Math.floor((allColors.length * (100 - percentReduction)) / 100),\n        1\n      );\n\n      // Create a mapping of each unique color to the list of colors are the closest to it.\n      // We'll then pick the top N colors.\n      // Lastly, we'll replace every pixel with the color that it reduces to.\n\n      // colorMap[i].numClosestColors is the number of colors closest to allColors[i]\n      const colorMap: { color: Color; numClosestColors: number }[] =\n        allColors.map((c) => ({\n          color: c,\n          numClosestColors: 0,\n        }));\n\n      for (let i = 1; i < allColors.length; i += 1) {\n        let closestColorIdx = 0;\n        let closetsColorDist = colorDiff(\n          allColors[i],\n          allColors[closestColorIdx]\n        );\n        // Find the other color that is closest to this one\n        for (let k = 0; k < allColors.length; k += 1) {\n          if (k === i) {\n            // Don't check the distance between this color and itself\n            continue;\n          }\n          const dist = colorDiff(allColors[k], allColors[i]);\n          if (dist < closetsColorDist) {\n            closestColorIdx = k;\n            closetsColorDist = dist;\n          }\n        }\n        colorMap[closestColorIdx].numClosestColors += 1;\n      }\n\n      const colorPalette = sortBy(colorMap, [(c) => c.numClosestColors, 'desc'])\n        .slice(0, numColors)\n        .map(({ color }) => color);\n\n      return { colorPalette };\n    },\n    ({ coord, getSrcPixel, computed: { colorPalette } }) => {\n      const px = getSrcPixel(coord);\n      if (isTransparent(px)) {\n        return px;\n      }\n      // Find the color in the palette this one is closest to\n      const closestColor = minBy(colorPalette, (top) => colorDiff(top, px))!;\n      return closestColor;\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const repeatAnimation = buildEffect({\n  name: 'Repeat Animation',\n  description: 'Repeats the current animation some number of times',\n  params: [\n    sliderParam({\n      name: 'Number of Repeats',\n      defaultValue: 1,\n      min: 1,\n      max: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [numRepeats] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\n      (i) => image.frames[i % image.frames.length]\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildEffect({\n  name: 'Resize Image',\n  description:\n    'Change the dimensions of the image. ' +\n    'If bigger than original, the extra space will be transparent. ' +\n    'If smaller, the image will be cropped. ',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight] }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n    const newWidth =\n      resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n    return resizeImageUtil({\n      image,\n      newWidth,\n      newHeight,\n    });\n  },\n});\n","import { reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const reverseAnimation = buildEffect({\n  name: 'Reverse Animation',\n  description: 'Reverses the animation',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: reverse(image.frames),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const ripple = buildEffect({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the ripple effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many ripples you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord: [x, y],\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const offset = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return getSrcPixel([x + offset, y]);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const rotate = buildEffect({\n  name: 'Rotate',\n  description: 'Make the image rotate about the center point',\n  params: [\n    radioParam<'clockwise' | 'counter'>({\n      name: 'Direction',\n      defaultValue: 'clockwise',\n      options: [\n        { name: 'Clockwise', value: 'clockwise' },\n        { name: 'Counter-Clockwise', value: 'counter' },\n      ],\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [direction] }) => {\n      const amount = animationProgress * (direction === 'counter' ? 1 : -1);\n      return {\n        cos: Math.cos(2 * Math.PI * amount),\n        sin: Math.sin(2 * Math.PI * amount),\n      };\n    },\n    ({\n      dimensions: [width, height],\n      coord: [x, y],\n      computed: { cos, sin },\n      getSrcPixel,\n    }) => {\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\n\nexport const roxbury = buildEffect({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], animationProgress }) => {\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(animationProgress * 4);\n      const phaseIdx = (animationProgress - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      return {\n        angle,\n        cos: Math.cos(-angle * 1.35),\n        sin: Math.sin(-angle * 1.35),\n        rotatePointX: width * 0.25,\n        rotatePointY: height * 0.7,\n      };\n    },\n    ({\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n      const newCoord: Coord = [\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildEffect({\n  name: 'Shake',\n  description: 'Make the image shake back and forth',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: Math.round(\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\n      ),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y])\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { getPixelFromSource, mapCoords } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const slowAnimation = buildEffect({\n  name: 'Slow Animation',\n  description: 'Attempts to slow the animation by adding intermediate frames',\n  params: [\n    radioParam<'basic' | 'smooth'>({\n      name: 'Interpolation Type',\n      options: [\n        { name: 'Basic', value: 'basic' },\n        { name: 'Smooth', value: 'smooth' },\n      ],\n      defaultValue: 'basic',\n      description:\n        'With basic interpolation, frames are simply duplicated. ' +\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\n    }),\n  ],\n  fn: ({ image, parameters: [type] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\n\n      // Even numbered frames are just the original frames\n      if (i % 2 === 0) {\n        return image.frames[i / 2];\n      }\n\n      const ogFrameIdx = (i - 1) / 2;\n\n      if (type === 'basic') {\n        // Intermediate frame is simply the previous OG frame\n        return image.frames[ogFrameIdx];\n      }\n\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\n      return mapCoords(image.dimensions, (coord) => {\n        const [r1, g1, b1, a1] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx],\n          coord\n        );\n        const [r2, g2, b2, a2] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx + 1],\n          coord\n        );\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\n      });\n    }),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const spin = buildEffect({\n  disabled: true,\n  name: 'Spin',\n  description: 'Make the image spin in a 3D-like way',\n  params: [],\n  fn: mapImage(\n    ({ image, coord: [x, y], frameCount, frameIndex, getSrcPixel }) => {\n      const centerX = image.dimensions[0] / 2;\n      const idx = frameIndex / frameCount;\n      // 0% -> 0\n      // 25% -> Pi / 2\n      // 50% -> Pi\n      // 75% -> 3/2 * Pi\n      // 100% -> 2 * Pi\n      const angle = 2 * Math.PI * idx;\n      const newX = Math.round(centerX + x * Math.cos(angle));\n      return getSrcPixel([newX, y]);\n    }\n  ),\n});\n\n/*\nx = centerX\nnewX = centerX\n\nx = 0, idx = 0, angle = cos(0) = 1, relX = centerX - 0\n  newX = 0\nx = 0, idx = 25%, angle = cos(45deg) ~ 0.5, relX = centerX - 0\n  newX = centerX - cos(45) * x\nx = 0, idx = 50%, angle = cos(90deg) = 0, relX = centerX - 0\n  newX = (centerX - 0)\n\nx = 25%, idx = 25%, angle ~ 0.5, relX = centerX - 0\n  newX = centerX - angle * x\n*/\n","import { buildEffect } from '../domain/types';\nimport { isTransparent, mapImage } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildEffect({\n  name: 'Static',\n  description: 'Adds random static to the image',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      if (isBackground && type === 'background') {\n        const inverse = Math.ceil(random() * 100) < strength;\n        const grey = Math.ceil(random() * 255);\n\n        return inverse ? [grey, grey, grey, 255] : src;\n      }\n\n      const isStatic = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return isStatic ? [grey, grey, grey, src[3]] : src;\n    }\n  ),\n});\n","import { Checkbox, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction } from '../domain/types';\n\nconst CheckboxParam: React.FC<{\n  name: string;\n  value?: boolean;\n  description?: string;\n  onChange: (v: boolean) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Checkbox\n          aria-label={name}\n          checked={value}\n          onChange={(e, value) => onChange(value)}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function checkboxParam(args: {\n  name: string;\n  defaultValue: boolean;\n  description?: string;\n}): ParamFunction<boolean> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <CheckboxParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, mapImage, colorDiff } from '../domain/utils';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparency = buildEffect({\n  name: 'Transparency',\n  description: 'Set certain pixels to be transparent',\n  params: [\n    checkboxParam({\n      name: 'Matches are Transparent',\n      description:\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\n      defaultValue: true,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n      step: 2,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      parameters: [matchesTransparent, selectedColor, tolerance],\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const withinTolerance = colorDiff(src, selectedColor) * 100 <= tolerance;\n\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\n        return [src[0], src[1], src[2], 0];\n      }\n      return src;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildEffect({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ] as const,\n  fn: mapImage(({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\n    getSrcPixel([x + transX, y + transY])\n  ),\n});\n","import { pipe, reject, sortBy } from 'remeda';\nimport { ParamFunction, Effect } from '../domain/types';\nimport { assert } from '../domain/utils';\nimport { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { bounceAnimation } from './bounce-animation';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { expand } from './expand';\nimport { fill } from './fill';\nimport { fisheye } from './fisheye';\nimport { grid } from './grid';\nimport { hueChange } from './hue-change';\nimport { hueShift } from './hue-shift';\nimport { hueShiftPulse } from './hue-shift-pulse';\nimport { hueWave } from './hue-wave';\nimport { lightning } from './lightning';\nimport { nuke } from './nuke';\nimport { party } from './party';\nimport { partyTwo } from './party-two';\nimport { pinwheel } from './pinwheel';\nimport { pinwheelParty } from './pinwheel-party';\nimport { radiance } from './radiance';\nimport { radianceParty } from './radiance-party';\nimport { reduceColorPalette } from './reduce-color-palette';\nimport { repeatAnimation } from './repeat-animation';\nimport { resizeImage } from './resize-image';\nimport { reverseAnimation } from './reverse-animation';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { slowAnimation } from './slow-animation';\nimport { spin } from './spin';\nimport { staticc } from './static';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nexport const POSSIBLE_EFFECTS = pipe(\n  [\n    adjustImage,\n    backgroundColor,\n    backgroundImage,\n    bounce,\n    bounceAnimation,\n    circle,\n    colors,\n    colorsBackground,\n    doubleVision,\n    expand,\n    fill,\n    fisheye,\n    grid,\n    hueChange,\n    hueShift,\n    hueShiftPulse,\n    hueWave,\n    lightning,\n    nuke,\n    party,\n    partyTwo,\n    pinwheel,\n    pinwheelParty,\n    radiance,\n    radianceParty,\n    reduceColorPalette,\n    repeatAnimation,\n    resizeImage,\n    reverseAnimation,\n    ripple,\n    rotate,\n    roxbury,\n    shake,\n    slowAnimation,\n    spin,\n    staticc,\n    transparency,\n    transpose,\n  ],\n  sortBy((x) => x.name),\n  reject((x) => x.disabled)\n);\n\nexport const effectByName = (\n  name: string\n): Effect<readonly ParamFunction<any>[]> => {\n  const t = POSSIBLE_EFFECTS.find((t) => t.name === name);\n  assert(t, `Could not find matching effect: ${name}`);\n  return t as any as Effect<readonly ParamFunction<any>[]>;\n};\n","import {\n  Autocomplete,\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  Divider,\n  FormControl,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Effect } from '../domain/types';\n\ninterface SelectedEffect {\n  effect: Effect<any>;\n  paramValues: any[];\n}\n\ninterface ImageEffectProps {\n  selectedEffect: SelectedEffect;\n  possibleEffect: Effect<any>[];\n  index: number;\n  onSelect: (selected: SelectedEffect) => void;\n  onRemove: () => void;\n  onMoveBefore?: () => void;\n  onMoveAfter?: () => void;\n}\n\nexport const ImageEffect: React.FC<ImageEffectProps> = ({\n  selectedEffect,\n  possibleEffect,\n  index,\n  onSelect,\n  onRemove,\n  onMoveBefore,\n  onMoveAfter,\n}) => {\n  const [paramsOpen, setParamsOpen] = React.useState(false);\n  const [currParams, setCurrParams] = React.useState([\n    ...selectedEffect.paramValues,\n  ]);\n  const [dirty, setDirty] = React.useState(false);\n  const closeDialog = ({ save }: { save: boolean }) => {\n    setParamsOpen(false);\n    if (save && dirty) {\n      onSelect({\n        ...selectedEffect,\n        paramValues: currParams,\n      });\n    } else {\n      setCurrParams([...selectedEffect.paramValues]);\n    }\n    setDirty(false);\n  };\n\n  return (\n    <Paper style={{ padding: 8 }} elevation={3} sx={{ width: 300 }}>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={2}>\n          <Typography variant=\"subtitle1\">{index + 1}</Typography>\n          <Tooltip title=\"Delete effect\">\n            <IconButton aria-label=\"delete\" onClick={onRemove}>\n              <Icon>delete</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move effect earlier\">\n            <IconButton\n              aria-label=\"move-before\"\n              onClick={onMoveBefore}\n              disabled={!onMoveBefore}\n            >\n              <Icon>arrow_upward</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move effect later\">\n            <IconButton\n              aria-label=\"move-after\"\n              onClick={onMoveAfter}\n              disabled={!onMoveAfter}\n            >\n              <Icon>arrow_downward</Icon>\n            </IconButton>\n          </Tooltip>\n        </Stack>\n        <Stack direction=\"row\" spacing={4}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={selectedEffect.effect.name}\n              options={possibleEffect.map((t) => t.name)}\n              onChange={(event, newEffectName) => {\n                const t = possibleEffect.find((t) => t.name === newEffectName)!;\n                // Reset all the params when you select a new effect\n                onSelect({\n                  effect: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n              renderInput={(params) => <TextField {...params} label=\"Effect\" />}\n            />\n          </FormControl>\n        </Stack>\n        {selectedEffect.effect.params.length > 0 ? (\n          <Button\n            variant=\"contained\"\n            startIcon={<Icon>edit</Icon>}\n            onClick={() => setParamsOpen(!paramsOpen)}\n          >\n            Edit Parameters\n          </Button>\n        ) : (\n          <Button variant=\"contained\" disabled>\n            (No Parameters Available)\n          </Button>\n        )}\n        <Dialog fullWidth maxWidth=\"sm\" open={paramsOpen}>\n          <DialogTitle>{selectedEffect.effect.name} Parameters</DialogTitle>\n          <DialogContent>\n            <Stack divider={<Divider />} spacing={2}>\n              {selectedEffect.effect.description && (\n                <Typography variant=\"caption\">\n                  {selectedEffect.effect.description}\n                </Typography>\n              )}\n              {selectedEffect.effect.params.map(\n                // Create elements for each of the parameters for the selectect effect.\n                // Each of these would get an onChange event so we know when the user has\n                //  selected a value.\n                (param: ParamFunction<any>, idx: number) => {\n                  const ele = param.fn({\n                    value: currParams[idx],\n                    onChange: (v) => {\n                      setDirty(true);\n                      setCurrParams(\n                        currParams.map((x, i) => {\n                          if (i === idx) {\n                            return v;\n                          }\n                          return x;\n                        })\n                      );\n                    },\n                  });\n                  return (\n                    <React.Fragment\n                      key={`${selectedEffect.effect.name}-${param.name}`}\n                    >\n                      {ele}\n                    </React.Fragment>\n                  );\n                }\n              )}\n            </Stack>\n          </DialogContent>\n          <DialogActions>\n            <Button\n              variant=\"outlined\"\n              autoFocus\n              onClick={() => {\n                closeDialog({ save: false });\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"contained\"\n              autoFocus\n              disabled={!dirty}\n              onClick={() => {\n                closeDialog({ save: true });\n              }}\n            >\n              Save and Close\n            </Button>\n          </DialogActions>\n        </Dialog>\n      </Stack>\n    </Paper>\n  );\n};\n","import {\n  Button,\n  CircularProgress,\n  Icon,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Effect, AppStateEffect } from '../domain/types';\nimport { replaceIndex } from '../domain/utils';\nimport { effectByName } from '../effects';\nimport { ImageEffect } from './ImageEffect';\n\ninterface EffectListProps {\n  currentEffect: AppStateEffect[];\n  possibleEffects: Effect<any>[];\n  onEffectsChange: (t: AppStateEffect[]) => void;\n}\n\nconst effectKey = (t: AppStateEffect, idx: number): string =>\n  `${t.effectName}-${idx}-${\n    t.state.status === 'done' ? t.state.image.gif.substring(0, 10) : 'pending'\n  }`;\n\nexport const ImageEffectList: React.FC<EffectListProps> = ({\n  currentEffect,\n  possibleEffects,\n  onEffectsChange,\n}) => (\n  <Stack spacing={4}>\n    <Typography variant=\"h5\">Image Effects</Typography>\n    {currentEffect.map((t, tIdx) => (\n      <Stack direction={'row'} key={effectKey(t, tIdx)} spacing={4}>\n        <ImageEffect\n          index={tIdx}\n          possibleEffect={possibleEffects}\n          selectedEffect={{\n            effect: effectByName(t.effectName),\n            paramValues: t.paramsValues,\n          }}\n          onRemove={() =>\n            onEffectsChange(\n              currentEffect.filter((nextT, newIdx) => newIdx !== tIdx)\n            )\n          }\n          onMoveBefore={\n            tIdx > 0\n              ? () =>\n                  onEffectsChange(\n                    currentEffect.map((nextT, newIdx) => {\n                      if (newIdx === tIdx - 1) {\n                        // This is the next item in the list\n                        return currentEffect[newIdx + 1];\n                      } else if (tIdx === newIdx) {\n                        // This is the previous item\n                        return currentEffect[tIdx - 1];\n                      } else {\n                        return nextT;\n                      }\n                    })\n                  )\n              : undefined\n          }\n          onMoveAfter={\n            tIdx < currentEffect.length - 1\n              ? () =>\n                  onEffectsChange(\n                    currentEffect.map((nextT, newIdx) => {\n                      if (newIdx === tIdx + 1) {\n                        // This is the previous item in the list\n                        return currentEffect[newIdx - 1];\n                      } else if (tIdx === newIdx) {\n                        // This is the next item\n                        return currentEffect[tIdx + 1];\n                      } else {\n                        return nextT;\n                      }\n                    })\n                  )\n              : undefined\n          }\n          onSelect={(selected) =>\n            onEffectsChange(\n              replaceIndex(\n                currentEffect,\n                tIdx,\n                (t): AppStateEffect => ({\n                  ...t,\n                  effectName: selected.effect.name,\n                  paramsValues: selected.paramValues,\n                })\n              )\n            )\n          }\n        />\n        {t.state.status === 'done' && (\n          <Stack sx={{ width: 200 }}>\n            <img\n              src={t.state.image.gif}\n              alt={`gif-${t.effectName}-${tIdx}`}\n              style={{ maxWidth: '300px', maxHeight: 'auto' }}\n            ></img>\n          </Stack>\n        )}\n        {t.state.status === 'computing' && <CircularProgress size={100} />}\n      </Stack>\n    ))}\n    <Button\n      variant=\"contained\"\n      startIcon={<Icon>add</Icon>}\n      size=\"large\"\n      onClick={() =>\n        onEffectsChange([\n          ...currentEffect,\n          {\n            effectName: possibleEffects[0].name,\n            paramsValues: possibleEffects[0].params.map(\n              (p: ParamFunction<any>) => p.defaultValue\n            ),\n            state: { status: 'init' },\n          },\n        ])\n      }\n    >\n      New Effect\n    </Button>\n  </Stack>\n);\n","import { Alert, Button, Icon, Stack, Typography } from '@material-ui/core';\nimport * as lz from 'lz-string';\nimport React from 'react';\nimport { AppState } from '../domain/types';\n\ninterface ImportExportProps {\n  state: AppState;\n  onImport: (o: AppState) => void;\n}\n\nexport const ImportExport: React.FC<ImportExportProps> = ({\n  state,\n  onImport,\n}) => {\n  const [info, setInfo] = React.useState<string | undefined>();\n  const [isInvalid, setInvalid] = React.useState(false);\n\n  const showInfo = (text: string) => {\n    setInfo(text);\n    setTimeout(() => setInfo(undefined), 3000);\n  };\n\n  const showError = () => {\n    setInvalid(true);\n    setTimeout(() => setInvalid(false), 3000);\n  };\n\n  return (\n    <Stack spacing={3}>\n      <Typography variant=\"h5\">Import/Export</Typography>\n      <Button\n        startIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(JSON.stringify(state));\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard\n      </Button>\n\n      <Button\n        startIcon={<Icon>file_download</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={async () => {\n          try {\n            const clipboardContents = await navigator.clipboard.readText();\n            if (!clipboardContents) {\n              showError();\n              return;\n            }\n            const data = JSON.parse(\n              lz.decompressFromBase64(clipboardContents)!\n            );\n            if (!Array.isArray(data.effects)) {\n              showError();\n              return;\n            }\n            onImport(data);\n            setInvalid(false);\n          } catch (e) {\n            console.error(e);\n            showError();\n          }\n        }}\n      >\n        Import from clipboard\n      </Button>\n      {info && (\n        <Alert severity=\"info\" sx={{ maxWidth: '300px' }}>\n          {info}\n        </Alert>\n      )}\n      {isInvalid && (\n        <Alert severity=\"error\" sx={{ maxWidth: '300px' }}>\n          Error importing from clipboard\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/effect.worker.c44cd98f.worker.js\");\n}\n","import { RunArgs } from './run';\n// @ts-ignore\nimport RunEffectWorker from './effect.worker';\nimport { AsyncRunMessage, ImageEffectResult } from './types';\n\nexport const runEffectsAsync = (args: RunArgs) =>\n  new Promise<ImageEffectResult>((resolve, reject) => {\n    const worker = new RunEffectWorker();\n\n    worker.addEventListener('error', reject);\n    worker.addEventListener('messageerror', reject);\n\n    worker.onmessage = (message: { data: AsyncRunMessage }) => {\n      // See effect.worker.ts for what messages look like\n      const data = message.data;\n      if (data.status === 'complete') {\n        resolve(data.result);\n      }\n    };\n\n    worker.postMessage(args);\n  });\n","import { readImage, runEffects } from './run';\nimport { runEffectsAsync } from './runAsync';\nimport { AppState, ImageEffectResult, EffectInput } from './types';\nimport { assert } from './utils';\n\nconst ENV = (window as any).ENV as 'DEV' | 'PROD';\n\nexport const computeGifs = async (\n  appState: AppState,\n  onCompute: (image: ImageEffectResult, idx: number) => void\n): Promise<void> => {\n  const effectInputs = appState.effects.map(\n    (t): EffectInput => ({\n      effectName: t.effectName,\n      params: t.paramsValues,\n    })\n  );\n\n  assert(\n    appState.baseImage,\n    'No source image, this button should be disabled!'\n  );\n\n  let image = await readImage(appState.baseImage);\n\n  // Can't get web workers working with the dev build, so just use the synchrounous version\n  //  if not a prod build.\n  const run = ENV === 'DEV' ? runEffects : runEffectsAsync;\n  for (let i = 0; i < effectInputs.length; i += 1) {\n    const start = Date.now();\n\n    const result = await run({\n      randomSeed: appState.baseImage,\n      image,\n      effectInput: effectInputs[i],\n      fps: appState.fps,\n    });\n\n    // Google analytics\n    ga('send', {\n      hitType: 'timing',\n      timingCategory: 'computeStep',\n      timingVar: effectInputs[i].effectName,\n      timingValue: Math.ceil((Date.now() - start) / 1000),\n    });\n\n    image = result.image;\n\n    onCompute(result, i);\n  }\n};\n","import { AppState, AppStateEffect } from './domain/types';\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nexport const getStoredAppState = (): AppState | undefined => {\n  try {\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (stored) {\n      const savedState = JSON.parse(stored);\n      if (Array.isArray(savedState.effects)) {\n        return savedState;\n      }\n    }\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error loading state from local storage', err.stack || err);\n  }\n\n  return undefined;\n};\n\nexport const saveAppState = (state: AppState) => {\n  try {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, serializeAppState(state));\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error saving state to local storage', err.stack || err);\n  }\n};\n\nexport const clearAppState = () => {\n  try {\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error clearing state from local storage', err.stack || err);\n  }\n};\n\nconst serializeAppState = (state: AppState): string => {\n  const toStore: AppState = {\n    ...state,\n    effects: state.effects.map(\n      (t): AppStateEffect => ({\n        ...t,\n        // Remove the computed image for the state before storing.\n        // This just bloats the storage and doesn't keep anything that isn't reproduceable.\n        state: { status: 'init' },\n      })\n    ),\n  };\n  return JSON.stringify(toStore);\n};\n","import {\n  Button,\n  Container,\n  Divider,\n  Icon,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\nimport React from 'react';\n\nimport { Help } from './components/Help';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageEffectList } from './components/ImageEffectList';\nimport { ImportExport } from './components/ImportExport';\nimport { computeGifs } from './domain/computeGifs';\nimport { AppState, AppStateEffect } from './domain/types';\nimport { replaceIndex } from './domain/utils';\nimport * as localStorage from './localStorage';\nimport { sliderParam } from './params/sliderParam';\nimport { POSSIBLE_EFFECTS } from './effects';\n\n// Set to true to expose the current state as window.STATE.\nconst DEBUG = false;\n\n// Number of millis to wait after a change before recomputing the gif\nconst COMPUTE_DEBOUNCE_MILLIS = 1000;\n\n// Increase this by 1 when there's a breaking change to the app state.\n// Don't change this unless we have to!\nconst CURRENT_APP_STATE_VERSION = 2;\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Final Gif Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nconst DEFAULT_STATE: AppState = {\n  version: CURRENT_APP_STATE_VERSION,\n  effects: [],\n  baseImage: undefined,\n  fps: DEFAULT_FPS,\n};\n\nexport const App: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n  const [doCompute, setDoCompute] = React.useState(false);\n  const [computeTimer, setComputeTimer] = React.useState<null | NodeJS.Timeout>(\n    null\n  );\n\n  React.useEffect(() => {\n    // If we have local storage state on startup, then reload that\n    const stored = localStorage.getStoredAppState();\n    if (stored) {\n      if (stored.version === CURRENT_APP_STATE_VERSION) {\n        setStateRaw(stored);\n        setDoCompute(true);\n      } else {\n        // TODO Might be nice to tell the user we erased their previous stuff\n        localStorage.clearAppState();\n      }\n    }\n  }, []);\n\n  const setState = React.useCallback(\n    (\n      fn: (oldState: AppState) => AppState,\n      { compute }: { compute: 'no' | 'now' | 'later' }\n    ) => {\n      setStateRaw((oldState) => {\n        const newState = fn(oldState);\n        localStorage.saveAppState(newState);\n\n        if (DEBUG) {\n          (window as any).STATE = newState;\n        }\n\n        if (compute !== 'no') {\n          // Compute the gif some time from now.\n          // Other changes within this time should push the compute time back\n          if (computeTimer) {\n            clearTimeout(computeTimer);\n            setComputeTimer(null);\n          }\n\n          if (compute === 'now') {\n            setDoCompute(true);\n          } else {\n            setDoCompute(false);\n            setComputeTimer(\n              setTimeout(() => {\n                setComputeTimer(null);\n                setDoCompute(true);\n              }, COMPUTE_DEBOUNCE_MILLIS)\n            );\n          }\n        }\n\n        return newState;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  React.useEffect(() => {\n    if (!doCompute) {\n      return;\n    }\n\n    // TODO What happens if new changes come in while we're already computing?\n    // Need to throw away previous results and calculate new ones.\n    setDoCompute(false);\n    (async () => {\n      setState(\n        (prevState) => ({\n          ...prevState,\n          effects: prevState.effects.map(\n            (t): AppStateEffect => ({\n              ...t,\n              state: { status: 'computing' },\n            })\n          ),\n        }),\n        { compute: 'no' }\n      );\n      // TODO error handling\n      await computeGifs(state, (image, computeIdx) => {\n        setState(\n          (prevState) => ({\n            ...prevState,\n            effects: replaceIndex(\n              prevState.effects,\n              computeIdx,\n              (t): AppStateEffect => ({\n                ...t,\n                state: { status: 'done', image },\n              })\n            ),\n          }),\n          { compute: 'no' }\n        );\n      });\n    })();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [doCompute]);\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container maxWidth=\"md\">\n        <Stack spacing={4} justifyContent=\"space-evenly\" divider={<Divider />}>\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />}>\n            <Paper style={{ padding: 16 }}>\n              <Help />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={1}>\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Choose a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState(\n                      (prevState) => ({\n                        ...prevState,\n                        baseImage,\n                      }),\n                      { compute: 'now' }\n                    );\n                  }}\n                />\n                <div style={{ maxWidth: '300px' }}>\n                  {fpsParam.fn({\n                    value: state.fps,\n                    onChange: (fps) =>\n                      setState(\n                        (prevState) => ({\n                          ...prevState,\n                          fps,\n                        }),\n                        { compute: 'later' }\n                      ),\n                  })}\n                </div>\n              </Stack>\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImageEffectList\n                currentEffect={state.effects}\n                possibleEffects={POSSIBLE_EFFECTS}\n                onEffectsChange={(effects) =>\n                  setState(\n                    (prevState) => ({\n                      ...prevState,\n                      effects,\n                    }),\n                    { compute: 'now' }\n                  )\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImportExport\n                state={state}\n                onImport={(o) => setState(() => o, { compute: 'now' })}\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear State</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear the source image and all\n                  effects\n                </Typography>\n                <Button\n                  startIcon={<Icon>clear</Icon>}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  color=\"warning\"\n                  onClick={() => {\n                    localStorage.clearAppState();\n                    setStateRaw(DEFAULT_STATE);\n                  }}\n                >\n                  Clear State\n                </Button>\n              </Stack>\n            </Paper>\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n    </>\n  );\n};\n\n// Icons at https://fonts.google.com/icons?selected=Material+Icons\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\nimport * as localStorage from './localStorage';\n\nReactDOM.render(\n  <React.StrictMode>\n    <TopLevelErrorBoundary\n      onClearLocalStorage={() => {\n        localStorage.clearAppState();\n        window.location.reload();\n      }}\n    >\n      <App />\n    </TopLevelErrorBoundary>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}