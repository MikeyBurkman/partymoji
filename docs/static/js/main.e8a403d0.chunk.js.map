{"version":3,"sources":["ImagePicker.tsx","components.tsx","Transform.tsx","TransformList.tsx","domain/types.ts","domain/utils.ts","domain/transforms/params/textParam.tsx","domain/transforms/background-party.ts","domain/transforms/params/floatParam.tsx","domain/transforms/bounce.ts","domain/transforms/circle.ts","domain/transforms/expand.ts","domain/transforms/fisheye.ts","domain/transforms/params/intParam.tsx","domain/transforms/frame-count.ts","domain/transforms/grayscale.ts","domain/transforms/lightning.ts","domain/transforms/party.ts","domain/transforms/resize.ts","domain/transforms/resize-background.ts","domain/transforms/ripple.ts","domain/transforms/params/dropdownParam.tsx","domain/transforms/rotate.ts","domain/transforms/roxbury.ts","domain/transforms/shake.ts","domain/transforms/params/colorPickerParam.tsx","domain/transforms/solid-background.ts","domain/transforms/index.ts","domain/transforms/static.ts","domain/transforms/transparency.ts","domain/transforms/transpose.ts","domain/run.ts","ComputeBox.tsx","App.tsx","index.tsx"],"names":["ImagePicker","currentImageUrl","onChange","className","type","accept","name","event","a","files","Array","from","target","file","readFile","baseImage","src","Promise","resolve","reader","FileReader","onload","result","readAsDataURL","Dropdown","selected","options","React","useState","hidden","setHidden","close","useCallback","document","removeEventListener","title","find","x","value","aria-haspopup","onClick","e","preventDefault","setTimeout","addEventListener","aria-hidden","role","style","visibility","map","href","cn","Expandable","mainEle","children","collapsed","setCollapsed","ImageTransform","image","selectedTransform","possibleTransforms","onSelect","onRemove","transform","t","newTransformName","paramValues","params","p","valid","defaultValue","param","idx","ele","fn","v","i","TransformList","currentTransforms","onTransformsChange","tIdx","undefined","paramsValues","filter","nextT","nextTIdx","computedImage","buildTransform","args","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","getAveragePixelValue","round","clampColor","clamp","n","max","min","getPixelFromSource","dimensions","coord","width","height","y","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","frame","data","mapCoords","transformedImageData","push","mapImage","parameters","imageData","frameIndex","frameCount","getSrcPixel","PARTY_COLORS","backgroundParty","srcPixel","partyColorIdx","FloatParam","parse","val","setVal","invalidText","setInvalidText","onBlur","reason","floatParam","parseFloat","isNaN","bounce","sin","PI","circle","radius","cos","expand","dist","centerX","centerY","xRatio","yRatio","fisheye","expanding","angle","atan2","IntParam","intParam","times","_","grayscale","gray","TextParam","lightningIntensities","lightning","seedrandom","flashIntensity","icf","party","partyColor","resize","newWidth","newHeight","srcX","srcY","resizeBackground","xPadding","yPadding","ripple","amplitude","period","shift","offset","DropdownParam","rotate","dropdownParam","sign","xRelCenter","yRelCenter","amount","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","newCoord","shake","shakeSpeed","ColorPickerParam","backgroundColor","disableAlpha","presetColors","color","onChangeComplete","colorPickerParam","POSSIBLE_TRANSFORMS","strength","ceil","tolerance","diff0","diff1","diff2","sqrt","transX","transY","runTransforms","inputDataUrl","transformList","fps","readImage","originalImage","images","reduce","transformInput","all","newImage","transparentColor","getTransparentColor","encodeTransparency","f","createGif","img","gif","gifEncoder","on","chunk","dataUrl","URL","createObjectURL","Blob","setFrameRate","setRepeat","setTransparent","writeHeader","forEach","addFrame","finish","res","rej","getPixels","err","getPixelResults","shape","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","fpsParam","ComputeBox","isDirty","computeDisabled","baseImageUrl","transforms","onComputed","loading","results","state","setState","fpsChanged","setFpsChanged","setFps","buttonDisabled","disabled","transformInputs","gifs","App","dirty","computeBtnDisbled","some","every","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e8a403d0.chunk.js","sourcesContent":["import React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  onChange,\n}) => (\n  <div className=\"box\">\n    <h3 className=\"title\">Source Image</h3>\n    <div className=\"file block\">\n      <label className=\"file-label\">\n        <input\n          className=\"file-input\"\n          type=\"file\"\n          accept=\"image/png,image/jpg\"\n          name=\"source-png\"\n          onChange={async (event) => {\n            const files = Array.from(event.target.files ?? []);\n            const file = files[0];\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }}\n        />\n        <span className=\"file-cta\">\n          <span className=\"file-icon\">\n            <i className=\"fas fa-upload\"></i>\n          </span>\n          <span className=\"file-label\">Choose a source image</span>\n        </span>\n      </label>\n    </div>\n    {currentImageUrl && <img src={currentImageUrl}></img>}\n  </div>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import React from 'react';\nimport cn from 'classnames';\n\ninterface DropdownProps {\n  selected: any;\n  options: { name: string; value: any }[];\n  onChange: (value: any) => void;\n}\n\nexport const Dropdown: React.FC<DropdownProps> = ({\n  selected,\n  options,\n  onChange,\n}) => {\n  const [hidden, setHidden] = React.useState(true);\n  const close = React.useCallback(() => {\n    document.removeEventListener('click', close);\n    setHidden(true);\n  }, []);\n  const title = options.find((x) => x.value === selected)?.name ?? '';\n  return (\n    <div className=\"dropdown is-active\">\n      <div className=\"dropdown-trigger\">\n        <button\n          className=\"button\"\n          aria-haspopup=\"true\"\n          onClick={(e) => {\n            e.preventDefault();\n            if (hidden) {\n              setHidden(false);\n              setTimeout(() => document.addEventListener('click', close), 0);\n            } else {\n              close();\n            }\n          }}\n        >\n          <span>{title}</span>\n          <span className=\"icon is-small\">\n            <i className=\"fas fa-angle-down\" aria-hidden=\"true\"></i>\n          </span>\n        </button>\n      </div>\n      <div\n        className=\"dropdown-menu\"\n        role=\"menu\"\n        style={{ visibility: hidden ? 'hidden' : 'visible' }}\n      >\n        <div className=\"dropdown-content\">\n          {options.map(({ name, value }) => (\n            <a\n              href=\"#\"\n              className={cn('dropdown-item', {\n                'is-active': selected === value,\n              })}\n              onClick={(e) => {\n                e.preventDefault();\n                close();\n                onChange(value);\n              }}\n            >\n              {name}\n            </a>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <div>\n      <div className=\"is-clickable\" onClick={() => setCollapsed(!collapsed)}>\n        {mainEle}\n        <span className=\"icon\">\n          <i\n            className={cn(\n              'fas',\n              collapsed ? 'fa-chevron-up' : 'fa-chevron-down'\n            )}\n          ></i>\n        </span>\n      </div>\n      {!collapsed && <div>{children}</div>}\n    </div>\n  );\n};\n","import React from 'react';\nimport { Dropdown } from './components';\n\nimport { ParamFunction, ParamValue, Transform } from './domain/types';\n\ninterface SelectedTransform {\n  transform: Transform<any>;\n  paramValues: ParamValue<any>[];\n}\n\ninterface ImageTransformProps {\n  image?: string;\n  selectedTransform: SelectedTransform;\n  possibleTransforms: Transform<any>[];\n  onSelect: (selected: SelectedTransform) => void;\n  onRemove: () => void;\n}\n\nexport const ImageTransform: React.FC<ImageTransformProps> = ({\n  image,\n  selectedTransform,\n  possibleTransforms,\n  onSelect,\n  onRemove,\n}) => {\n  return (\n    <div>\n      <div className=\"columns\">\n        <div className=\"column\">\n          <Dropdown\n            selected={selectedTransform.transform.name}\n            options={possibleTransforms.map((t) => ({\n              name: t.name,\n              value: t.name,\n            }))}\n            onChange={(newTransformName) => {\n              const t = possibleTransforms.find(\n                (t) => t.name === newTransformName\n              )!;\n              // Reset all the params when you select a new transform\n              onSelect({\n                transform: t,\n                paramValues: t.params.map(\n                  (p: ParamFunction<any>): ParamValue<any> => ({\n                    valid: true,\n                    value: p.defaultValue,\n                  })\n                ),\n              });\n            }}\n          />\n        </div>\n        <button className=\"delete column\" onClick={() => onRemove()} />\n      </div>\n      <div>\n        {selectedTransform.transform.params.map(\n          // Create elements for each of the parameters for the selectect transform.\n          // Each of these would get an onChange event so we know when the user has\n          //  selected a value.\n          (param: ParamFunction<any>, idx: number) => {\n            const value = selectedTransform.paramValues[idx];\n            const ele = param.fn({\n              value: value.valid ? value.value : param.defaultValue,\n              onChange: (v) => {\n                onSelect({\n                  transform: selectedTransform.transform,\n                  paramValues: selectedTransform.paramValues.map((x, i) => {\n                    if (i === idx) {\n                      return v;\n                    }\n                    return x;\n                  }),\n                });\n              },\n            });\n            return <div key={param.name}>{ele}</div>;\n          }\n        )}\n        {image && (\n          <>\n            <br />\n            <img src={image}></img>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport {\n  ParamFunction,\n  ParamValue,\n  Transform,\n  TransformWithParams,\n} from './domain/types';\nimport { ImageTransform } from './Transform';\n\ninterface TransformListProps {\n  currentTransforms: TransformWithParams<any>[];\n  possibleTransforms: Transform<any>[];\n  onTransformsChange: (t: TransformWithParams<any>[]) => void;\n}\n\nexport const TransformList: React.FC<TransformListProps> = ({\n  currentTransforms,\n  possibleTransforms,\n  onTransformsChange,\n}) => (\n  <div className=\"box\">\n    <h3 className=\"title\">Image Transforms</h3>\n    {currentTransforms.map((t, tIdx) => (\n      <div className=\"box\">\n        <ImageTransform\n          image={undefined}\n          possibleTransforms={possibleTransforms}\n          selectedTransform={{\n            transform: t.transform,\n            paramValues: t.paramsValues,\n          }}\n          onRemove={() => {\n            onTransformsChange(\n              currentTransforms.filter((nextT, nextTIdx) => nextTIdx !== tIdx)\n            );\n            // setState({\n            //   ...state,\n            //   dirty: true,\n            //   transforms: state.transforms.filter(\n            //     (nextT, nextTIdx) => nextTIdx !== tIdx\n            //   ),\n            // });\n          }}\n          onSelect={(selected) => {\n            onTransformsChange(\n              currentTransforms.map((nextT, nextTIdx) => {\n                if (tIdx === nextTIdx) {\n                  // This is the one we just changed\n                  return {\n                    transform: selected.transform,\n                    paramsValues: selected.paramValues,\n                    computedImage: undefined,\n                  };\n                }\n                // Reset all the images if we changed anything\n                return {\n                  transform: nextT.transform,\n                  paramsValues: nextT.paramsValues,\n                  computedImage: undefined,\n                };\n              })\n            );\n          }}\n          // setState({\n          //   ...state,\n          //   dirty: true,\n          //   transforms: state.transforms.map((nextT, nextTIdx) => {\n          //     if (tIdx === nextTIdx) {\n          //       // This is the one we just changed\n          //       return {\n          //         transform: selected.transform,\n          //         paramsValues: selected.paramValues,\n          //         computedImage: undefined,\n          //       };\n          //     }\n          //     // Reset all the images if we changed anything\n          //     return {\n          //       transform: nextT.transform,\n          //       paramsValues: nextT.paramsValues,\n          //       computedImage: undefined,\n          //     };\n          //   }),\n          // });\n          // }}\n        />\n      </div>\n    ))}\n    <button\n      className=\"button block\"\n      onClick={() => {\n        onTransformsChange([\n          ...currentTransforms,\n          {\n            transform: possibleTransforms[0],\n            paramsValues: possibleTransforms[0].params.map(\n              (p: ParamFunction<any>): ParamValue<any> =>\n                p.defaultValue !== undefined\n                  ? { valid: true, value: p.defaultValue }\n                  : { valid: false }\n            ),\n          },\n        ]);\n        // setState({\n        //   ...state,\n        //   dirty: true,\n        //   transforms: state.transforms.concat([\n        //     {\n        //       transform: POSSIBLE_TRANSFORMS[0],\n        //       paramsValues: POSSIBLE_TRANSFORMS[0].params.map(\n        //         (p: ParamFunction<any>): ParamValue<any> =>\n        //           p.defaultValue !== undefined\n        //             ? { valid: true, value: p.defaultValue }\n        //             : { valid: false }\n        //       ),\n        //     },\n        //   ]),\n        // });\n      }}\n    >\n      New Transform\n    </button>\n  </div>\n);\n","import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * a one-dimensional array of pixels; looks like [r1,g1,b1,a1, r2,g2,b2,a2,...]\n */\nexport type ImageData = number[];\n\nexport type Frame = {\n  data: ImageData;\n};\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: Frame[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface TransformFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport type ParamValue<T> = { valid: true; value: T } | { valid: false };\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: T;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nexport type ParamFunction<T> = {\n  name: string;\n  defaultValue: T;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type TransformFn<Params> = (opts: TransformFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Transform<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}\n\nexport interface TransformWithParams<T extends readonly ParamFunction<any>[]> {\n  transform: Transform<T>;\n  paramsValues: ParamValue<T>[];\n}\n\nexport interface TransformInput<T extends ParamFunction<any>[]> {\n  transform: Transform<T>;\n  params: T;\n}\n\nexport const buildTransform = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}): Transform<T> => ({\n  name: args.name,\n  params: args.params,\n  fn: args.fn,\n});\n","import seedrandom from 'seedrandom';\nimport { AssertionError } from 'assert';\n\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  ImageData,\n  Image,\n  Random,\n  TransformFn,\n  TransformFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => {\n  const clamp = (n: number) => Math.max(Math.min(n, 255), 0);\n\n  return [clamp(r), clamp(g), clamp(b), clamp(a)];\n};\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return [0, 0, 0, 0]; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = x * 4 + y * 4 * width;\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => {\n  const frames = image.frames.map((frame, idx) => ({\n    data: cb(frame.data, idx, image.frames.length),\n  }));\n  return {\n    dimensions: image.dimensions,\n    frames,\n  };\n};\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData: ImageData = [];\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      transformedImageData.push(...clampColor(cb([x, y])));\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/** Create a new array [0, 1, 2, ...N-1] */\nexport const repeat = (times: number): number[] =>\n  [...new Array(times)].map((_, i) => i);\n","import React from 'react';\nimport { ParamFunction, ParamValue } from '../../types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value: string;\n  onChange: (v: ParamValue<string>) => void;\n}> = ({ name, value, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <div>\n      <label>{name}</label>\n      <br />\n      <input\n        type=\"text\"\n        value={val}\n        name={name}\n        onChange={(e) => setVal(e.target.value)}\n        onBlur={() => onChange({ valid: true, value })}\n      />\n    </div>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  defaultValue: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      onChange={params.onChange}\n      value={params.value}\n    />\n  ),\n});\n","import { buildTransform } from '../types';\nimport { Color } from '../types';\nimport { mapImage, isTransparent } from '../utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const backgroundParty = buildTransform({\n  name: 'Background Party',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    // Make the transparent parts colorful\n    if (isTransparent(srcPixel)) {\n      const partyColorIdx = Math.floor(\n        (frameIndex / frameCount) * PARTY_COLORS.length\n      );\n      return PARTY_COLORS[partyColorIdx];\n    }\n\n    return srcPixel;\n  }),\n});\n","import React from 'react';\nimport { ParamValue, ParamFunction } from '../../types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value: number;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <div className=\"field\">\n      <label className=\"label\">{name}</label>\n      <div className=\"control has-icons-left has-icons-right\">\n        <input\n          className=\"input\"\n          type=\"text\"\n          defaultValue={value}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n          onBlur={onBlur}\n        />\n      </div>\n      {invalidText && <p className=\"help is-danger\">{invalidText}</p>}\n    </div>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const bounce = buildTransform({\n  name: 'Bounce',\n  params: [\n    floatParam({\n      name: 'Bounce Speed',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [x, y] = coord;\n    const yOffset =\n      y +\n      Math.round(\n        parameters[0] * Math.sin((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([x, yOffset]);\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const circle = buildTransform({\n  name: 'Circle',\n  params: [\n    floatParam({\n      name: 'Radius',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [radius] = parameters;\n    const [x, y] = coord;\n    const xOffset = Math.round(\n      radius * Math.sin(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    const yOffset = Math.round(\n      radius * Math.cos(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    return getSrcPixel([x + xOffset, y + yOffset]);\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const expand = buildTransform({\n  name: 'Expand',\n  params: [\n    floatParam({\n      name: 'Radius',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const dist = Math.cos(idx * 2 * Math.PI) * parameters[0];\n\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const [width, height] = dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from './params/floatParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildTransform({\n  name: 'Fisheye',\n  params: [floatParam({ name: 'radius', defaultValue: 10, min: 0 })],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const expanding = idx < 0.5;\n      const [width, height] = dimensions;\n      const dist = (expanding ? idx : 1 - idx) * parameters[0];\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import React from 'react';\nimport { ParamValue, ParamFunction } from '../../types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value: number;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <div className=\"field\">\n      <label className=\"label\">{name}</label>\n      <div className=\"control has-icons-left has-icons-right\">\n        <input\n          className=\"input\"\n          type=\"text\"\n          defaultValue={value}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n          onBlur={onBlur}\n        />\n      </div>\n      {invalidText && <p className=\"help is-danger\">{invalidText}</p>}\n    </div>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue: number;\n  min?: number;\n  max?: number;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: args.defaultValue,\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { Frame, buildTransform } from '../types';\nimport { assert, repeat } from '../utils';\nimport { intParam } from './params/intParam';\n\nexport const frameCount = buildTransform({\n  name: 'Frame Count',\n  params: [\n    intParam({\n      name: 'Number of Frames',\n      defaultValue: 10,\n      min: 1,\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    assert(\n      image.frames.length === 1,\n      'The frame-count transform requires a static image with just one frame'\n    );\n\n    const [frameCount] = parameters;\n\n    const frames = repeat(frameCount).map(\n      (): Frame => ({\n        data: image.frames[0].data,\n      })\n    );\n\n    return {\n      dimensions: image.dimensions,\n      frames,\n    };\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent, getAveragePixelValue } from '../utils';\n\nexport const grayscale = buildTransform({\n  name: 'Grayscale',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [gray, gray, gray, 255];\n  }),\n});\n","import { buildTransform } from '../types';\nimport seedrandom from 'seedrandom';\n\nimport { Color } from '../types';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n  isTransparent,\n} from '../utils';\nimport { textParam } from './params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildTransform({\n  name: 'Lightning',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      defaultValue: 'lightning',\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const random = seedrandom(parameters[0]);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildTransform } from '../types';\nimport { Color } from '../types';\nimport { isTransparent, getAveragePixelValue, mapImage } from '../utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const party = buildTransform({\n  name: 'Party',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const partyColorIdx = Math.floor(\n      (frameIndex / frameCount) * PARTY_COLORS.length\n    );\n    const partyColor = PARTY_COLORS[partyColorIdx];\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [\n      (gray * partyColor[0]) / 255,\n      (gray * partyColor[1]) / 255,\n      (gray * partyColor[2]) / 255,\n      255,\n    ];\n  }),\n});\n","import { ImageData, buildTransform } from '../types';\nimport { getPixelFromSource } from '../utils';\nimport { intParam } from './params/intParam';\n\nexport const resize = buildTransform({\n  name: 'Resize',\n  params: [\n    intParam({\n      name: 'Width',\n      defaultValue: 128,\n      min: 1,\n    }),\n    intParam({\n      name: 'Height',\n      defaultValue: 128,\n      min: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const [width, height] = image.dimensions;\n    const [newWidth, newHeight] = parameters;\n    const xRatio = width / newWidth;\n    const yRatio = height / newHeight;\n\n    const newFrames = image.frames.map((frame) => {\n      const transformedImageData: ImageData = [];\n      for (let y = 0; y < newHeight; y += 1) {\n        for (let x = 0; x < newWidth; x += 1) {\n          // Simple nearest-neighbor image scaling.\n          // Arguably the worst of the scaling algorithms, but it's quick,\n          //  and we're generally dealing with small images anyhow.\n          const srcX = Math.floor(x * xRatio);\n          const srcY = Math.floor(y * yRatio);\n          transformedImageData.push(\n            ...getPixelFromSource(image.dimensions, frame.data, [srcX, srcY])\n          );\n        }\n      }\n      return {\n        data: transformedImageData,\n      };\n    });\n\n    return {\n      frames: newFrames,\n      dimensions: [newWidth, newHeight],\n    };\n  },\n});\n","import { buildTransform } from '../types';\nimport { ImageData } from '../types';\nimport { assert, getPixelFromSource } from '../utils';\nimport { intParam } from './params/intParam';\n\nexport const resizeBackground = buildTransform({\n  name: 'Resize Background',\n  params: [\n    intParam({ name: 'Width', defaultValue: 128, min: 0 }),\n    intParam({ name: 'Height', defaultValue: 128, min: 0 }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [width, height] = image.dimensions;\n    const [newWidth, newHeight] = parameters;\n    assert(\n      newWidth >= width,\n      'New width for resize-background needs to be greater than or equal to the original'\n    );\n    assert(\n      newHeight >= height,\n      'New height for resize-background needs to be greater than or equal to the original'\n    );\n\n    const xPadding = (newWidth - width) / 2;\n    const yPadding = (newHeight - height) / 2;\n\n    const newFrames = image.frames.map((frame) => {\n      const transformedImageData: ImageData = [];\n      for (let y = 0; y < newHeight; y += 1) {\n        for (let x = 0; x < newWidth; x += 1) {\n          const pixel =\n            x > xPadding &&\n            x < newWidth - xPadding &&\n            y > yPadding &&\n            y < newHeight - yPadding\n              ? getPixelFromSource(image.dimensions, frame.data, [\n                  x - xPadding,\n                  y - yPadding,\n                ])\n              : [0, 0, 0, 0];\n          transformedImageData.push(...pixel);\n        }\n      }\n      return {\n        data: transformedImageData,\n      };\n    });\n\n    return {\n      frames: newFrames,\n      dimensions: [newWidth, newHeight],\n    };\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapFrames, mapCoords, getPixelFromSource } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const ripple = buildTransform({\n  name: 'Ripple',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: 10,\n    }),\n    floatParam({\n      name: 'Period',\n      defaultValue: 2,\n      min: 0,\n    }),\n  ],\n  fn: ({ image, parameters }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const [amplitude, period] = parameters;\n\n      const height = image.dimensions[1];\n      const shift = (frameIndex / frameCount) * 2 * Math.PI;\n      return mapCoords(image.dimensions, ([x, y]) => {\n        const offset = Math.round(\n          amplitude * Math.sin((y / height) * period * Math.PI + shift)\n        );\n\n        return getPixelFromSource(image.dimensions, data, [x + offset, y]);\n      });\n    }),\n});\n","import React from 'react';\nimport { Dropdown } from '../../../components';\nimport { ParamValue, ParamFunction } from '../../types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: { name: string; value: any }[];\n  value: any;\n  onChange: (v: ParamValue<any>) => void;\n}> = ({ name, options, value, onChange }) => {\n  return (\n    <div>\n      <label>{name}</label>\n      <br />\n      <Dropdown\n        onChange={(value) => onChange({ valid: true, value })}\n        selected={value}\n        options={options}\n      />\n    </div>\n  );\n};\n\nexport function dropdownParam<T>(args: {\n  name: string;\n  options: { name: string; value: T }[];\n  defaultValue: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { mapImage } from '../utils';\nimport { buildTransform, Coord } from '../types';\nimport { dropdownParam } from './params/dropdownParam';\n\nexport const rotate = buildTransform({\n  name: 'Rotate',\n  params: [\n    dropdownParam({\n      name: 'Direction',\n      defaultValue: -1,\n      options: [\n        { name: 'Clockwise', value: -1 },\n        { name: 'Counter-Clockwise', value: 1 },\n      ],\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const [sign] = parameters;\n      const centerX = dimensions[0] / 2;\n      const centerY = dimensions[1] / 2;\n      const [x, y] = coord;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const amount = (frameIndex / frameCount) * (sign || 1);\n      const cos = Math.cos(2 * Math.PI * amount);\n      const sin = Math.sin(2 * Math.PI * amount);\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { mapFrames, mapCoords, getPixelFromSource } from '../utils';\nimport { buildTransform, Coord } from '../types';\n\nexport const roxbury = buildTransform({\n  name: 'Roxbury',\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const idx = frameIndex / frameCount;\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(idx * 4);\n      const phaseIdx = (idx - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      const cos = Math.cos(-angle * 1.35);\n      const sin = Math.sin(-angle * 1.35);\n\n      const rotatePointX = image.dimensions[0] * 0.25;\n      const rotatePointY = image.dimensions[1] * 0.7;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const [x, y] = coord;\n        const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n        const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n        const newCoord: Coord = [\n          Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n          Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n        ];\n\n        return getPixelFromSource(image.dimensions, data, newCoord);\n      });\n    }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const shake = buildTransform({\n  name: 'Shake',\n  params: [floatParam({ name: 'Shake Speed', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [shakeSpeed] = parameters;\n    const [x, y] = coord;\n    const xOffset =\n      x +\n      Math.round(\n        shakeSpeed * Math.cos((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([xOffset, y]);\n  }),\n});\n","import React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../../../components';\n\nimport { ParamValue, ParamFunction, Color } from '../../types';\nimport { fromHexColor, toHexColor } from '../../utils';\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value: Color;\n  onChange: (v: ParamValue<Color>) => void;\n}> = ({ name, value, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <div className=\"is-flex-direction-column\">\n          {name}\n          <div\n            style={{\n              width: '1.0em',\n              height: '1.0em',\n              backgroundColor: toHexColor(value),\n            }}\n          />\n        </div>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={toHexColor(value)}\n        onChangeComplete={(c) =>\n          onChange({ valid: true, value: fromHexColor(c.hex) })\n        }\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue: Color;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue,\n    fn: (params) => (\n      <ColorPickerParam\n        name={args.name}\n        value={params.value}\n        onChange={params.onChange}\n      />\n    ),\n  };\n}\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent, fromHexColor } from '../utils';\nimport { colorPickerParam } from './params/colorPickerParam';\n\nexport const solidBackground = buildTransform({\n  name: 'Solid Background',\n  params: [\n    colorPickerParam({\n      name: 'Background Color',\n      defaultValue: fromHexColor('#FFFFFF'),\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color] = parameters;\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","import { backgroundParty } from './background-party';\nimport { bounce } from './bounce';\nimport { circle } from './circle';\nimport { expand } from './expand';\nimport { fisheye } from './fisheye';\nimport { frameCount } from './frame-count';\nimport { grayscale } from './grayscale';\nimport { lightning } from './lightning';\nimport { party } from './party';\nimport { resize } from './resize';\nimport { resizeBackground } from './resize-background';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { solidBackground } from './solid-background';\nimport { staticc } from './static';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nexport const POSSIBLE_TRANSFORMS = [\n  frameCount,\n  backgroundParty,\n  bounce,\n  circle,\n  expand,\n  fisheye,\n  grayscale,\n  lightning,\n  party,\n  resize,\n  resizeBackground,\n  ripple,\n  rotate,\n  roxbury,\n  shake,\n  solidBackground,\n  staticc,\n  transparency,\n  transpose,\n];\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent } from '../utils';\nimport { floatParam } from './params/floatParam';\n\nexport const staticc = buildTransform({\n  name: 'Static',\n  params: [floatParam({ name: 'Strength', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      return [0, 0, 0, 0];\n    }\n\n    const inverse = Math.ceil(random() * strength) > 1;\n\n    return inverse ? [255 - src[0], 255 - src[1], 255 - src[2], src[3]] : src;\n  }),\n});\n","import { buildTransform } from '../types';\nimport { fromHexColor, mapImage } from '../utils';\nimport { colorPickerParam } from './params/colorPickerParam';\nimport { intParam } from './params/intParam';\n\nexport const transparency = buildTransform({\n  name: 'Transparent Color',\n  params: [\n    colorPickerParam({\n      name: 'Transparent Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    intParam({\n      name: 'Tolerance',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color, tolerance] = parameters;\n    const p = getSrcPixel(coord);\n    const diff0 = p[0] - color[0];\n    const diff1 = p[1] - color[1];\n    const diff2 = p[2] - color[2];\n    const diff = Math.sqrt(diff0 * diff0 + diff1 * diff1 + diff2 * diff2);\n    if ((diff / 255) * 100 <= tolerance) {\n      return [p[0], p[1], p[2], 0];\n    }\n    return p;\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { intParam } from './params/intParam';\n\nexport const transpose = buildTransform({\n  name: 'Transpose',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [transX, transY] = parameters;\n    const [x, y] = coord;\n\n    return getSrcPixel([x + transX, y + transY]);\n  }),\n});\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\n\nimport { Color, TransformInput, Image, Dimensions, ImageData } from './types';\nimport {\n  toHexColor,\n  getPixelFromSource,\n  randomColor,\n  fromHexColor,\n  isTransparent,\n} from './utils';\n\n// Returns a list of gif data URLs, for each transform\nexport const runTransforms = async (\n  inputDataUrl: string,\n  transformList: TransformInput<any>[],\n  fps: number\n): Promise<string[]> => {\n  const random = seedrandom(inputDataUrl);\n\n  const originalImage = await readImage(inputDataUrl);\n\n  const images: Image[] = [];\n  transformList.reduce((image, transformInput) => {\n    const result = transformInput.transform.fn({\n      image,\n      parameters: transformInput.params,\n      random,\n    });\n    images.push(result);\n    return result;\n  }, originalImage);\n\n  return await Promise.all(\n    images.map(async (newImage) => {\n      const transparentColor = getTransparentColor(newImage, random);\n\n      // Transform any of our transparent pixels to what our gif understands to be transparent\n      const image = encodeTransparency(\n        newImage.frames.map((f) => f.data),\n        transparentColor\n      );\n\n      return await createGif(newImage.dimensions, image, transparentColor, fps);\n    })\n  );\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  frames: ImageData[],\n  transparentColor: Color | undefined\n): ImageData[] => {\n  const image = frames.map((frame) => {\n    const img: ImageData = [];\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img.push(...transparentColor);\n      } else {\n        img.push(frame[i]);\n        img.push(frame[i + 1]);\n        img.push(frame[i + 2]);\n        img.push(255); // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return image;\n};\n\nconst createGif = async (\n  dimensions: Dimensions,\n  frames: ImageData[],\n  transparentColor: Color | undefined,\n  fps: number\n): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = dimensions;\n    const gif = new gifEncoder(width, height);\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n    if (transparentColor) {\n      gif.setTransparent(toHexColor(transparentColor));\n    }\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nconst readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, getPixelResults: { shape: Dimensions; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        } else {\n          return res({\n            frames: [\n              {\n                data: getPixelResults.data,\n              },\n            ],\n            dimensions: getPixelResults.shape,\n          });\n        }\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame.data, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import React from 'react';\nimport cn from 'classnames';\nimport { assert } from './domain/utils';\nimport { runTransforms } from './domain/run';\nimport { TransformInput, TransformWithParams } from './domain/types';\nimport { intParam } from './domain/transforms/params/intParam';\n\ninterface ComputeBoxProps {\n  isDirty: boolean;\n  computeDisabled: boolean;\n  baseImageUrl?: string;\n  transforms: TransformWithParams<any>[];\n  onComputed: () => void;\n}\n\ntype ComputeState = { loading: false; results: string[] } | { loading: true };\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = intParam({\n  name: 'Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 0,\n});\n\nexport const ComputeBox: React.FC<ComputeBoxProps> = ({\n  isDirty,\n  computeDisabled,\n  baseImageUrl,\n  transforms,\n  onComputed,\n}) => {\n  const [state, setState] = React.useState<ComputeState>({\n    loading: false,\n    results: [],\n  });\n  const [fpsChanged, setFpsChanged] = React.useState(false);\n  const [fps, setFps] = React.useState(DEFAULT_FPS);\n\n  const buttonDisabled = computeDisabled && !fpsChanged;\n\n  return (\n    <div className=\"box\">\n      <h3 className=\"title\">Create Gif</h3>\n      <div className=\"block\">\n        {fpsParam.fn({\n          value: fps,\n          onChange: (x) => {\n            if (x.valid) {\n              setFps(x.value);\n              setFpsChanged(true);\n            }\n          },\n        })}\n      </div>\n      <div className=\"block\">\n        <button\n          className={cn('button', 'block', { 'is-loading': state.loading })}\n          disabled={buttonDisabled}\n          onClick={async () => {\n            const transformInputs = transforms.map(\n              (t): TransformInput<any> => ({\n                transform: t.transform,\n                params: t.paramsValues.map((p) => {\n                  assert(p.valid);\n                  return p.value;\n                }),\n              })\n            );\n            setState({ loading: true });\n            setTimeout(async () => {\n              assert(\n                baseImageUrl,\n                'No source image, this button should be disabled!'\n              );\n              const gifs = await runTransforms(\n                baseImageUrl,\n                transformInputs,\n                fps\n              );\n              setState({\n                loading: false,\n                results: gifs,\n              });\n              setFpsChanged(false);\n              onComputed();\n            });\n          }}\n        >\n          <span>Compute</span>{' '}\n          {(isDirty || fpsChanged) && (\n            <span className=\"icon is-small\">\n              <i className=\"fas fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            </span>\n          )}\n        </button>\n      </div>\n      <div className=\"block\">\n        <div className=\"columns\">\n          {!state.loading &&\n            state.results.map((gif, idx) => (\n              <div className=\"column\">\n                <div>{transforms[idx].transform.name}</div>\n                <img src={gif}></img>\n              </div>\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n\nimport { ParamFunction, ParamValue, Transform } from './domain/types';\nimport { ImagePicker } from './ImagePicker';\nimport { TransformList } from './TransformList';\nimport { POSSIBLE_TRANSFORMS } from './domain/transforms';\nimport { ComputeBox } from './ComputeBox';\n\nconst DEBUG = false;\n\ntype AppState = {\n  baseImage?: string;\n  transforms: {\n    transform: Transform<any>;\n    paramsValues: ParamValue<any>[];\n    computedImage?: string;\n  }[];\n  dirty: boolean;\n};\n\nexport const App: React.FC = () => {\n  const [state, setState] = React.useState<AppState>({\n    dirty: false,\n    transforms: [],\n    baseImage: undefined,\n  });\n\n  const computeBtnDisbled =\n    !state.baseImage ||\n    state.transforms.length === 0 ||\n    !state.dirty ||\n    state.transforms.some((t) => {\n      const params = t.transform.params as ParamFunction<any>[];\n      return (\n        params.length > 0 && t.paramsValues.every((p, i) => p.valid === false)\n      );\n    });\n\n  return (\n    <section>\n      <div className=\"container\">\n        <div>\n          <ImagePicker\n            currentImageUrl={state.baseImage}\n            onChange={(baseImage) => {\n              setState({\n                ...state,\n                baseImage,\n                dirty: true,\n              });\n            }}\n          />\n          <TransformList\n            currentTransforms={state.transforms}\n            possibleTransforms={POSSIBLE_TRANSFORMS}\n            onTransformsChange={(transforms) =>\n              setState({\n                ...state,\n                dirty: true,\n                transforms,\n              })\n            }\n          />\n          <ComputeBox\n            isDirty={state.dirty}\n            baseImageUrl={state.baseImage}\n            computeDisabled={computeBtnDisbled}\n            transforms={state.transforms}\n            onComputed={() =>\n              setState({\n                ...state,\n                dirty: false,\n              })\n            }\n          />\n          {DEBUG && (\n            <div>\n              <code>{JSON.stringify(state, null, 2)}</code>\n            </div>\n          )}\n        </div>\n      </div>\n    </section>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}