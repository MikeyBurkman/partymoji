{"version":3,"sources":["components/Icon.tsx","components/Expandable.tsx","components/Help.tsx","domain/utils/misc.ts","domain/utils/color.ts","domain/utils/isWorker.ts","domain/utils/canvas.ts","domain/utils/CanvasElement.tsx","domain/utils/image.ts","domain/utils/imageImport.ts","domain/utils/useDebounce.tsx","components/Gif.tsx","components/ImagePicker.tsx","domain/env.ts","components/HelpTooltip.tsx","params/utils.ts","params/bezierParam.tsx","params/checkboxParam.tsx","params/colorPickerParam.tsx","params/dropdownParam.tsx","params/floatParam.tsx","params/huePickerParam.tsx","params/imagePickerParam.tsx","params/intParam.tsx","params/radioParam.tsx","params/sliderParam.tsx","params/textParam.tsx","params/variableLengthParam.tsx","effects/utils.ts","effects/adjust-image.ts","effects/background-color.ts","effects/background-image.ts","effects/blur.ts","effects/bounce.ts","effects/bounce-animation.ts","effects/circle.ts","effects/changing-focus.ts","effects/color-palette.ts","effects/colors.ts","effects/colors-background.ts","effects/double-vision.ts","effects/drop-shadow.ts","effects/dual-hue.ts","effects/expand.ts","effects/fade.ts","effects/fill.ts","effects/fisheye.ts","effects/grid.ts","effects/hue-change.ts","effects/hue-shift.ts","effects/hue-shift-pulse.ts","effects/hue-wave.ts","effects/lightning.ts","effects/mirror.ts","effects/nuke.ts","effects/opacity.ts","effects/party.ts","effects/party-background.ts","effects/party-harder.ts","effects/party-shadow.ts","effects/pinwheel-colors.ts","effects/pinwheel-rainbow.ts","effects/pinwheel-rainbow-background.ts","effects/radiance-colors.ts","effects/radiance-rainbow.ts","effects/radiance-rainbow-background.ts","effects/reduce-color-palette.ts","effects/repeat-animation.ts","effects/resize-image.ts","effects/reverse-animation.ts","effects/ripple.ts","effects/rotate.ts","effects/roxbury.ts","effects/scale-image.ts","effects/set-animation-length.ts","effects/shake.ts","effects/slow-animation.ts","effects/spin.ts","effects/static.ts","effects/text.ts","effects/trails.ts","effects/transparency.ts","effects/transpose.ts","effects/index.ts","components/BackgroundPreviewTooltip.tsx","effects/fake-transparency.ts","domain/run.ts","domain/effect.worker.ts","domain/runAsync.ts","domain/computeGifs.ts","domain/useProcessingQueue.tsx","components/RequiresAnimationTooltip.tsx","components/ImageEffectDialog.tsx","components/ImageRow.tsx","components/ImageEffectList.tsx","localStorage.ts","AlertContext.tsx","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["HtmlTooltip","styled","_ref","className","props","_jsx","Tooltip","classes","popper","_ref2","theme","tooltipClasses","tooltip","backgroundColor","color","maxWidth","fontSize","typography","pxToRem","border","ClickableIcon","_ref3","name","onClick","isDisabled","label","hover","setHover","React","useState","onMouseEnter","useCallback","onMouseLeave","_jsxs","Fab","variant","size","disabled","children","MuiIcon","sx","mr","Icon","_ref4","htmlTooltip","inner","title","Expandable","mainEle","collapsed","setCollapsed","ClickAwayListener","onClickAway","Stack","Button","style","direction","alignItems","spacing","Collapse","in","Help","Typography","Group","Section","SectionHeader","SectionText","Divider","width","paddingLeft","marginRight","assert","condition","Error","arguments","length","undefined","replaceIndex","arr","index","newValueFn","map","x","i","removeIndex","filter","_t","idx","console","log","insertInto","newValue","slice","isUrl","s","test","copyToClipboard","navigator","clipboard","writeText","readFromClipboard","readText","clamp","n","min","max","Math","weightedValue","percent","v1","v2","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","pointDistance","x1","y1","x2","y2","xDiff","pow","yDiff","sqrt","bezierCurve","easing","mirror","fn","bezier","amount","LINEAR_BEZIER","dataURItoBlob","dataURI","split","byteString","atob","mimeString","ab","ArrayBuffer","ia","Uint8Array","charCodeAt","Blob","type","blobOrFileToDataUrl","file","Promise","resolve","reader","FileReader","onload","result","readAsDataURL","toHexColor","r","g","b","toHexValue","c","toString","toUpperCase","fromHexColor","hex","parseInt","substr","isHexColor","isTransparent","pixel","isPartiallyTransparent","randomColor","random","floor","int32","getAveragePixelValue","round","clampColor","a","TRANSPARENT_COLOR","shiftTowardsHue","hue","l","convert","hsl","newR","newG","newB","rgb","shiftHue","_ref5","h","setBrightness","_ref6","colorFromHue","adjustSaturation","newSat","abs","adjustBrightness","d","adjustContrast","colorDiff","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","linearInterpolation","_ref7","r1","g1","b1","r2","g2","b2","IS_WORKER","window","createCanvas","height","canvas","OffscreenCanvas","ctx","getContext","document","createElement","frameToCanvas","dimensions","frame","imageData","ImageData","putImageData","canvasToFrame","canvasData","getImageData","data","drawImageOnCanvas","drawImage","applyCanvasFromFrame","preEffect","postEffect","save","restore","combineImages","background","foreground","backgroundCanvas","foregroundCanvas","applyFilter","_dropShadow$blurRadiu","blur","brightness","contrast","opacity","saturation","hueRotate","sepia","dropShadow","shadow","offsetX","offsetY","blurRadius","join","filters","applyTransform","horizontalScale","verticalScale","horizontalSkew","verticalSkew","horizontalTranslation","verticalTranslation","transform","applyRotation","degrees","radians","rotate","applyScale","_ref8","y","scale","CanvasElement","cursorIsPointer","onCanvasMount","onMouseDown","onMouseDownEvt","onMouseUp","onMouseUpEvt","onMouseMove","onMouseMoveEvt","onMouseLeaveEvt","ref","useRef","isMounted","useEffect","current","onEvent","callback","evt","rect","getBoundingClientRect","clientX","left","clientY","top","setTimeout","useMemo","cursor","getPixelFromSource","image","coord","getImageIndex","mapFrames","cb","frames","mapCoords","transformedImageData","Uint8ClampedArray","mapImage","parameters","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","scaleImage","resizeImage","newWidth","newHeight","keepScale","newFrames","rootCanvas","imgCanvas","createNewImage","args","range","duplicateImage","f","getPixel","setPixel","changeFrameCount","currentFrames","frameToCopy","px","isColorPartiallyTransparent","readGifFromFile","async","buffer","readAsArrayBuffer","toArrayBuffer","gif","parseGIF","lsd","finalCanvas","frameDelays","decompressFrames","parsedFrame","delay","push","disposalType","clearRect","frameDims","dims","patch","createImageData","set","averageDelay","reduce","acc","val","fps","ceil","readImage","dataUrl","fileOrDataUrl","fileType","matched","match","getFileType","fname","blob","miscUtil","File","dataUrlToFile","endsWith","res","rej","getPixels","err","results","shape","from","numFrames","sliceSize","subarray","getImageFromUrl","fetch","url","contentType","headers","get","arrayBuffer","btoa","byte","String","fromCharCode","useDebounce","value","debounceMillis","onChange","v","setV","debounceRef","onValueChange","newV","clearTimeout","MAX_SIZE","calculateDimensions","maxHeight","aspectRatio","Gif","src","alt","parseFileName","parts","ImagePicker","currentImage","error","setError","TextField","fullWidth","helperText","onBlur","text","e","target","startsWith","imageImportUtil","gifWithBackgroundColor","partiallyTransparent","imageUtil","Box","startIcon","component","hidden","accept","_event$target$files","Array","event","files","IS_MOBILE","MobileDetect","userAgent","mobile","ENV","debugLog","HelpTooltip","description","toParamFunction","BezierParam","WIDTH","HEIGHT","curValue","setCurValue","latestMouseLocation","setLatestMouseLocation","canvasCtx","setCanvasCtx","isDragging","setIsDragging","closestPointIdx","distances","distance","closest","R","fillStyle","beginPath","ellipse","fill","moveTo","strokeStyle","bezierCurveTo","stroke","newCoord","paddingTop","bezierParam","defaultValue","params","CheckboxParam","Checkbox","checked","checkboxParam","ColorBox","colorUtil","ColorPickerParam","SketchPicker","disableAlpha","presetColors","onChangeComplete","colorPickerParam","DropdownParam","options","FormControl","Select","autoWidth","t","MenuItem","FloatParam","parse","setVal","invalidText","setInvalidText","valid","reason","FormHelperText","floatParam","parseFloat","isNaN","HuePickerParam","hexColor","HuePicker","huePickerParam","DEFAULT_IMAGE","IntParam","intParam","RadioParam","RadioGroup","FormControlLabel","control","Radio","radioParam","SliderParam","step","paddingRight","Slider","valueLabelDisplay","getAriaValueText","sliderParam","TextParam","textParam","VariableLengthParam","newParamText","createNewParam","setParams","param","pValue","Paper","ele","p","oldP","IconButton","newParams","visibility","vals","variableLengthParam","buildEffect","_args$disabled","group","secondaryDescription","groupOrder","requiresAnimation","adjustImage","resizeToWidth","resizeToHeight","oldWidth","oldHeight","hasScaleChange","isBiggerImage","currImage","canvasUtil","backgroundImage","imagePickerParam","otherImagePreResize","otherImage","thisFrameCanvas","otherImageFrameIndex","otherFrameCanvas","bounce","yOffset","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","sin","cos","changingFocus","curve","progress","DEFAULT_COLORS","colorPalette","palette","gray","colors","brightnessIncrease","chosenColor","srcPixel","brightnessAdjusted","colorsBackground","bgColor","doubleVision","amplitude","dir","dualHue","color1","color2","expand","dist","centerX","centerY","xRatio","yRatio","fade","getOpacityAmount","oldImage","colorToReplace","tolerance","floodFill","newColor","visited","Set","add","has","stack","pop","currColor","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","hueChange","newHue","hueShift","hueShiftPulse","hueWave","shift","period","lightningIntensities","lightning","seed","seedrandom","flashIntensity","icf","nuke","party","speed","partyBackground","shiftSpeed","newH","partyHarder","partyShadow","layers","startHue","hueSize","applyShadows","rest","newFrame","pinwheelColors","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","center","pointAngle","colorIdx","pinwheelRainbow","strength","pinwheelRainbowBackground","radianceColors","colorList","flatMap","maxDist","distFromCenter","radianceRainbow","radianceRainbowBackground","reduceColorPalette","percentReduction","allColorsSet","allColors","numColors","colorMap","numClosestColors","closestColorIdx","closetsColorDist","k","sortBy","minBy","repeatAnimation","numRepeats","reverseAnimation","ripple","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","setAnimationLength","shake","slowAnimation","ogFrameIdx","a1","a2","spin","staticc","isBackground","inverse","grey","isStatic","FONTS","font","fillText","trails","numTrails","trailOpacity","blurCoefficient","frameIdx","transparency","matchesTransparent","selectedColor","withinTolerance","transpose","transX","transY","GROUP_ORDERING","POSSIBLE_EFFECTS","indexOf","_x$groupOrder","reject","effectByName","find","TooltipInner","BackgroundPreviewTooltip","COLORS","fakeTransparency","createBackground","blockWidth","blockHeight","j","fillRect","encodeTransparency","transparentColor","img","createGif","gifEncoder","setFrameRate","setRepeat","writeHeader","setTransparent","on","chunk","forEach","addFrame","finish","getTransparentColor","hasTransparent","seenPixels","hasPartialTransparency","attempt","findRandomColorNotInSet","attempts","col","Worker_fn","Worker","computationMap","Map","handleError","computationId","computation","delete","computeGif","effectInput","randomSeed","effect","effectName","resultWithBG","worker","RunEffectWorker","Date","now","addEventListener","onmessage","message","status","handleSuccess","postMessage","ProcessorQueueContext","createContext","latestRunIdRef","ProcessorQueueProvider","Provider","useProcessingQueue","onComplete","onError","useContext","onFinish","runId","then","catch","RequiresAnimationTooltip","GroupHeader","position","padding","primary","contrastText","GroupItems","ImageEffectDialog","_editingEffect$effect","_image$results$gifWit","open","initialImage","currentEffect","possibleEffects","currFps","currRandomSeed","onChangeEffect","onCancel","setImage","computing","onImageChange","initialLoaded","setInitialLoaded","editingEffect","setEditingEffect","dirty","setDirty","closeDialog","Dialog","_Fragment","DialogTitle","marginTop","Autocomplete","disableClearable","groupBy","_event","newEffect","_initialImage$image","getOptionLabel","option","renderGroup","key","renderOption","marginLeft","renderInput","DialogContent","divider","Fragment","CircularProgress","DialogActions","autoFocus","Inner","showTransparency","setShowTransparency","eleWidth","eleHeight","hScale","vScale","renderedFrames","substring","pb","orientation","ImageRow","appStateEffect","state","ImageEffect","currentEffects","setEffectEditDialogState","onEffectsChange","newDefaultEffect","onEdit","isNew","onDelete","onAddAfter","newIdx","elevation","overflowX","justifyContent","py","ImageEffectList","appState","effects","effectEditDialogState","baseImage","setBaseImage","dialogInitialImage","prevEffect","paramsValues","tIdx","_appState$baseImage","previousEffect","onAddNew","finalGif","lastEffect","dialogOnChangeEffect","computedImage","dialogOnCancel","onSaveGif","saveAs","hiddenIdx","Number","MAX_SAFE_INTEGER","effectKey","LOCAL_STORAGE_KEY","saveAppState","localStorage","setItem","serializeAppState","clearAppState","removeItem","_state$baseImage","toStore","JSON","stringify","alertContext","alert","setAlert","AlertProvider","alertValue","setAlertValue","AlertSnackbar","Snackbar","Alert","severity","onClose","fpsParam","DEFAULT_STATE","version","setStateRaw","doCompute","setDoCompute","computeTimer","setComputeTimer","useSetAlert","stored","getItem","savedState","isArray","hydratedBaseImage","imageFps","startIndex","setState","oldState","newState","STATE","effectsDiff","currState","prevState","diff","currEffects","prevEffects","currE","prevE","ei","currEParam","prevEP","getEffectsDiff","startEffectIndex","onCompute","prevEffectState","computeGifsForState","computeIdx","ScopedCssBaseline","Container","pt","href","rel","App","TopLevelErrorBoundary","Component","constructor","hasError","getDerivedStateFromError","componentDidCatch","errorInfo","render","this","endIcon","onClearLocalStorage","createTheme","fontFamily","ReactDOM","StrictMode","ThemeProvider","location","reload","getElementById"],"mappings":"ipGAmCA,MAAMA,EAAcC,aAAOC,IAAA,IAAC,UAAEC,KAAcC,GAAqBF,EAAA,OAC/DG,cAACC,IAAO,IAAKF,EAAOG,QAAS,CAAEC,OAAQL,IAAe,GADpCF,EAEjBQ,IAAA,IAAC,MAAEC,GAAOD,EAAA,MAAM,CACjB,CAAC,MAAME,IAAeC,WAAY,CAChCC,gBAAiB,UACjBC,MAAO,sBACPC,SAAU,IACVC,SAAUN,EAAMO,WAAWC,QAAQ,IACnCC,OAAQ,qBAEX,IASYC,EAA8CC,IAKpD,IALqD,KAC1DC,EAAI,QACJC,EAAO,WACPC,EAAU,MACVC,GACDJ,EACC,MAAOK,EAAOC,GAAYC,IAAMC,UAAS,GAEnCC,EAAeF,IAAMG,aAAY,KACjCR,GACFI,GAAS,EACX,GACC,CAACJ,IAEES,EAAeJ,IAAMG,aAAY,KACjCR,GACFI,GAAS,EACX,GACC,CAACJ,IAEJ,OACEU,eAACC,IAAG,CACFC,QAAQ,WACRC,KAAK,QACLC,SAAUb,EACVD,QAASA,EACTO,aAAcA,EACdE,aAAcA,EACdlB,MAAOY,EAAQ,YAAc,UAAUY,SAAA,CAEvCjC,cAACkC,IAAO,CAACC,GAAI,CAAEC,GAAI,GAAIH,SAAEhB,IACxBG,IACG,EAWGiB,EAA4BC,IAKlC,IALmC,KACxCrB,EAAI,QACJV,EAAO,YACPgC,EAAW,MACX9B,GACD6B,EACC,MAAME,EAAQxC,cAACkC,IAAO,CAACzB,MAAOA,EAAMwB,SAAEhB,IACtC,OAAIV,EACKgC,EACLvC,cAACL,EAAW,CAAC8C,MAAOlC,EAAQ0B,SAAEO,IAE9BxC,cAACC,IAAO,CAACwC,MAAOlC,EAAQ0B,SAAEO,IAGrBA,CACT,ECxGWE,EAAwC7C,IAG9C,IAH+C,QACpD8C,EAAO,SACPV,GACDpC,EACC,MAAO+C,EAAWC,GAAgBtB,IAAMC,UAAS,GAEjD,OACExB,cAAC8C,IAAiB,CAACC,YAAaA,IAAMF,GAAa,GAAMZ,SACvDL,eAACoB,IAAK,CAAAf,SAAA,CACJjC,cAACiD,IAAM,CACLnB,QAAQ,OACRZ,QAASA,IAAM2B,GAAcD,GAC7BM,MAAO,CAAEzC,MAAO,SAChBsB,KAAK,QAAOE,SAEZL,eAACoB,IAAK,CAACG,UAAU,MAAMC,WAAW,SAASC,QAAS,EAAEpB,SAAA,CACpDjC,cAAA,OAAAiC,SAAMU,IACN3C,cAACqC,EAAI,CAACpB,KAAM2B,EAAY,MAAQ,gBAGpC5C,cAACsD,IAAQ,CAACC,IAAKX,EAAUX,SAAEA,QAEX,EC1BXuB,EAAiBA,IAC5BxD,cAAC0C,EAAU,CACTC,QAAS3C,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,wBAAiCA,SAEnEL,eAAC8B,EAAK,CAAAzB,SAAA,CACJjC,cAAC0C,EAAU,CACTC,QAAS3C,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,oBAA6BA,SAE/DL,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,iCACfjC,cAAC6D,EAAW,CAAA5B,SAAC,wDAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,sIAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,wEAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,iTAUjBjC,cAAC0C,EAAU,CACTC,QAAS3C,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,mBAA4BA,SAE9DL,eAAC8B,EAAK,CAAAzB,SAAA,CACJjC,cAAC2D,EAAO,CAAA1B,SACNL,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,qDAGfjC,cAAC6D,EAAW,CAAA5B,SAAC,mGAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,oGAOjBjC,cAAC8D,IAAO,IAERlC,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,4EAIfjC,cAAC6D,EAAW,CAAA5B,SAAC,6FAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,2FAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,2PAQfjC,cAAC8D,IAAO,IAERlC,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,gHAIfjC,cAAC6D,EAAW,CAAA5B,SAAC,yEAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,oFAMfjC,cAAC8D,IAAO,IAERlC,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,iCACfjC,cAAC6D,EAAW,CAAA5B,SAAC,0DAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,kDAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,oEAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,mKASnBjC,cAAC0C,EAAU,CAACC,QAAS3C,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,kBAA2BA,SACvEjC,cAAC0D,EAAK,CAAAzB,SACJL,eAAC+B,EAAO,CAAA1B,SAAA,CACNjC,cAAC4D,EAAa,CAAA3B,SAAC,oCACfjC,cAAC6D,EAAW,CAAA5B,SAAC,0FAIbjC,cAAC6D,EAAW,CAAA5B,SAAC,gEAGbjC,cAAC6D,EAAW,CAAA5B,SAAC,8HAWnByB,EAAkB7D,IAAA,IAAC,SAAEoC,GAAUpC,EAAA,OAAKG,cAACgD,IAAK,CAACK,QAAS,EAAEpB,SAAEA,GAAiB,EAEzE0B,EAAoBvD,IAAA,IAAC,SAAE6B,GAAU7B,EAAA,OACrCJ,cAACgD,IAAK,CAACe,MAAM,KAAKV,QAAS,EAAEpB,SAC1BA,GACK,EAGJ2B,EAA0B5C,IAAA,IAAC,SAAEiB,GAAUjB,EAAA,OAC3ChB,cAACyD,IAAU,CAAC3B,QAAQ,QAAQkC,YAAY,SAAQ/B,SAC7CA,GACU,EAGT4B,EAAwBvB,IAAA,IAAC,SAAEL,GAAUK,EAAA,OACzCV,eAAC6B,IAAU,CAAC3B,QAAQ,QAAQkC,YAAY,SAAQ/B,SAAA,CAC9CjC,cAACqC,IAAI,CAACF,GAAI,CAAExB,SAAU,EAAGsD,YAAa,GAAIhC,SAAC,WAAa,IAAEA,IAC/C,E,gDC9IR,SAASiC,EACdC,GAGA,IAAKA,EACH,MAAM,IAAIC,MAAM,qBAHXC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,2BAKZ,CAGO,MAAMG,EAAeA,CAC1BC,EACAC,EACAC,IACQF,EAAIG,KAAI,CAACC,EAAGC,IAAOJ,IAAUI,EAAIH,EAAWE,GAAKA,IAG9CE,EAAcA,CAAIN,EAAUC,IACvCD,EAAIO,QAAO,CAACC,EAAIC,KACdC,QAAQC,IAAI,WAAY,CAAEV,QAAOQ,QAC1BR,IAAUQ,KAQRG,EAAaA,CAAIZ,EAAUC,EAAeY,IAC9C,IAAIb,EAAIc,MAAM,EAAGb,GAAQY,KAAab,EAAIc,MAAMb,IAG5Cc,EAASC,GACpB,sGAAsGC,KACpGD,GAGSE,EAAmBF,GAC9BG,UAAUC,UAAUC,UAAUL,GAEnBM,EAAoBA,IAC/BH,UAAUC,UAAUG,WAETC,EAAQA,CAACC,EAAWC,EAAaC,IAC5CC,KAAKD,IAAIC,KAAKF,IAAID,EAAGE,GAAMD,GAMhBG,EAAgBA,CAACC,EAAiBC,EAAYC,KACxD,EAAIF,EAAU,KAAOC,EAAMD,EAAU,IAAOE,EAKlCC,EAAiBA,CAACC,EAAWC,KACxC,MAAMC,EAAaD,EAAG,GAAKD,EAAG,GACxBG,EAAaF,EAAG,GAAKD,EAAG,GAC9B,OAAQ,IAA4C,IAArCN,KAAKU,MAAMD,EAAYD,GAAqBR,KAAKW,IAAM,GAAG,EAG9DC,EAAgBA,CAAApH,EAAAO,KAA+C,IAA7C8G,EAAIC,GAAUtH,GAAGuH,EAAIC,GAAUjH,EAC5D,MAAMkH,EAAQjB,KAAKkB,IAAIH,EAAKF,EAAI,GAC1BM,EAAQnB,KAAKkB,IAAIF,EAAKF,EAAI,GAChC,OAAOd,KAAKoB,KAAKH,EAAQE,EAAM,EAUpBE,GAAcA,CAACC,EAAqBC,KAC/C,MAAMC,EAAKC,IAAOH,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAIA,EAAO,GAAG,GAAIA,EAAO,GAAG,IACtE,OAAKC,EAGGG,GACgBF,EAAfE,EAAS,GAAkB,EAATA,EAAiB,EAAI,GAAKA,EAAS,KAHpDA,GAA2BF,EAAGE,EAIvC,EAGUC,GAA6B,CACxC,CAAC,GAAK,IACN,CAAC,GAAK,KAIKC,GAAiBC,IAG5B,MAAMC,EAAQD,EAAQC,MAAM,KACtBC,EAAaC,KAAKF,EAAM,IAGxBG,EAAaH,EAAM,GAAGA,MAAM,KAAK,GAAGA,MAAM,KAAK,GAG/CI,EAAK,IAAIC,YAAYJ,EAAW9D,QAGhCmE,EAAK,IAAIC,WAAWH,GAG1B,IAAK,IAAIzD,EAAI,EAAGA,EAAIsD,EAAW9D,OAAQQ,IACrC2D,EAAG3D,GAAKsD,EAAWO,WAAW7D,GAIhC,OAAO,IAAI8D,KAAK,CAACL,GAAK,CAAEM,KAAMP,GAAa,EAGhCQ,GAAuBC,GAClC,IAAIC,SAAiBC,IACnB,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,IAAMH,EAAQC,EAAOG,QACrCH,EAAOI,cAAcP,EAAK,IC7HjBQ,GAAa1J,IAAuB,IAArB2J,EAAGC,EAAGC,GAAS7J,EACzC,MAAM8J,EAAcC,IAClB,MAAMnE,EAAImE,EAAEC,SAAS,IAAIC,cACzB,OAAoB,IAAbrE,EAAEnB,OAAemB,EAAI,IAAMA,CAAC,EAGrC,MAAO,IAAIkE,EAAWH,KAAKG,EAAWF,KAAKE,EAAWD,IAAI,EAG/CK,GAAgBC,GAAuB,CAClDC,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzCD,SAASD,EAAIF,cAAcI,OAAO,EAAG,GAAI,IACzC,KAGWC,GAAc1E,GAAc,iBAAiBC,KAAKD,GAOlD2E,GAAiBC,GAAiBA,EAAM,GAAK,GAM7CC,GAA0BD,IACpCD,GAAcC,IAAUA,EAAM,GAAK,IAEzBE,GAAeC,GAAmC,CAC7DnE,KAAKoE,MAAuB,IAAjBD,EAAOE,SAClBrE,KAAKoE,MAAuB,IAAjBD,EAAOE,SAClBrE,KAAKoE,MAAuB,IAAjBD,EAAOE,SAClB,KAGWC,GAAuBvK,IAAA,IAAEoJ,EAAGC,EAAGC,GAAStJ,EAAA,OACnDiG,KAAKuE,OAAOpB,EAAIC,EAAIC,GAAK,EAAE,EAEhBmB,GAAa7J,IAAA,IAAEwI,EAAGC,EAAGC,EAAGoB,GAAS9J,EAAA,MAAY,CACxDiF,EAAMuD,EAAG,EAAG,KACZvD,EAAMwD,EAAG,EAAG,KACZxD,EAAMyD,EAAG,EAAG,KACZzD,EAAM6E,EAAG,EAAG,KACb,EAEYC,GAA2B,CAAC,EAAG,EAAG,EAAG,GAOrCC,GAAkBA,CAAA1I,EAE7B2I,EACAlD,KACW,IAHVyB,EAAGC,EAAGC,EAAGoB,GAASxI,EAInB,MAAO,CAAEmD,EAAGyF,GAAKC,MAAYC,IAAI,CAAC5B,EAAGC,EAAGC,KACjC2B,EAAMC,EAAMC,GAAQJ,MAAYK,IAAI,CACzCP,EACA3E,EAAcyB,EAAQtC,EAAG,KACzByF,IAEF,MAAO,CACL5E,EAAcyB,EAAQyB,EAAG6B,GACzB/E,EAAcyB,EAAQ0B,EAAG6B,GACzBhF,EAAcyB,EAAQ2B,EAAG6B,GACzBT,EACD,EAOUW,GAAWA,CAAAC,EAAsB3D,KAA2B,IAA/CyB,EAAGC,EAAGC,EAAGoB,GAASY,EAC1C,MAAOC,EAAGlG,EAAGyF,GAAKC,MAAYC,IAAI,CAAC5B,EAAGC,EAAGC,KAClC2B,EAAMC,EAAMC,GAAQJ,MAAYK,IAAI,EAAEG,EAAI5D,GAAU,IAAKtC,EAAGyF,IACnE,MAAO,CAACG,EAAMC,EAAMC,EAAMT,EAAE,EAIjBc,GAAgBA,CAAAC,EAAsB9D,KAA2B,IAA/CyB,EAAGC,EAAGC,EAAGoB,GAASe,EAC/C,MAAOF,EAAGlG,GAAK0F,MAAYC,IAAI,CAAC5B,EAAGC,EAAGC,KAC/B2B,EAAMC,EAAMC,GAAQJ,MAAYK,IAAI,CAACG,EAAGlG,EAAGsC,IAClD,MAAO,CAACsD,EAAMC,EAAMC,EAAMT,EAAE,EAMjBgB,GAAgBb,GAAuB,IAC/CE,MAAYK,IAAI,CAACP,EAAK,IAAK,KAC9B,KAGWc,GAAmBA,CAACtL,EAAcsH,KAC7C,MAAOyB,EAAGC,EAAGC,EAAGoB,GAAKrK,GACdkL,EAAGlG,EAAGyF,GAAKC,MAAYC,IAAI5B,EAAGC,EAAGC,GAClCsC,EAAS1F,EAAcD,KAAK4F,IAAIlE,GAAStC,EAAGsC,GAAU,EAAI,IAAM,IAC/DsD,EAAMC,EAAMC,GAAQJ,MAAYK,IAAI,CAACG,EAAGK,EAAQd,IACvD,MAAO,CAACG,EAAMC,EAAMC,EAAMT,EAAE,EAIjBoB,GAAmBA,CAACzL,EAAcsH,KAC7C,MAAMoE,EAAKpE,EAAS,IAAO,KACpByB,EAAGC,EAAGC,EAAGoB,GAAKrK,EACrB,OAAOoK,GAAW,CAACrB,EAAI2C,EAAG1C,EAAI0C,EAAGzC,EAAIyC,EAAGrB,GAAG,EAIhCsB,GAAiBA,CAAC3L,EAAcsH,KAC3C,MAAMoE,EAAIpE,EAAS,IAAM,GAClByB,EAAGC,EAAGC,EAAGoB,GAAKrK,EACrB,OAAOoK,GAAW,CAChBsB,GAAK3C,EAAI,KAAO,IAChB2C,GAAK1C,EAAI,KAAO,IAChB0C,GAAKzC,EAAI,KAAO,IAChBoB,GACA,EAMSuB,GAAYA,CAAC1F,EAAWC,KAGnC,MAAM0F,EAAW3F,EAAG,GAAKC,EAAG,GACtB2F,EAAY5F,EAAG,GAAKC,EAAG,GACvB4F,EAAa7F,EAAG,GAAKC,EAAG,GACxB6F,GAAc9F,EAAG,GAAKC,EAAG,IAAM,EAE/B8F,GAAc,EAAID,EAAa,KAAOH,EAAWA,EACjDK,GAAc,GAAK,IAAMF,GAAc,KAAOF,EAAYA,EAC1DK,EAAa,EAAIJ,EAAaA,EAEpC,OAAOnG,KAAKoB,KAAKiF,EAAaC,EAAaC,GAAc,GAAG,EAQjDC,GAAsBC,IAQrB,IAPZnG,IAAKoG,EAAIC,EAAIC,GACbrG,IAAKsG,EAAIC,EAAIC,GAAG,OAChBrF,GAKD+E,EACC,MAAO,CACLzG,KAAKoE,OAAO,EAAI1C,GAAUgF,EAAKhF,EAASmF,GACxC7G,KAAKoE,OAAO,EAAI1C,GAAUiF,EAAKjF,EAASoF,GACxC9G,KAAKoE,OAAO,EAAI1C,GAAUkF,EAAKlF,EAASqF,GACxC,IACD,EC1KUC,GAA8B,qBAAXC,OCInBC,GAAe1N,IAA8C,IAA5CkE,EAAOyJ,GAAmB3N,EACtD,GAAIwN,GAAW,CAGb,MAAMI,EAAS,IAAIC,gBAAgB3J,EAAOyJ,GACpCG,EAAMF,EAAOG,WAAW,MAE9B,OADA1J,EAAOyJ,EAAK,wBACL,CAAEF,SAAQE,MACnB,CAAO,CACL,MAAMF,EAASI,SAASC,cAAc,UACtCL,EAAO1J,MAAQA,EACf0J,EAAOD,OAASA,EAChB,MAAMG,EAAMF,EAAOG,WAAW,MAE9B,OADA1J,EAAOyJ,EAAK,wBACL,CAAEF,SAAQE,MACnB,GAIWI,GAAgB3N,IAMV,IANW,WAC5B4N,EAAU,MACVC,GAID7N,EACC,MAAO2D,EAAOyJ,GAAUQ,GAClB,OAAEP,EAAM,IAAEE,GAAQJ,GAAaS,GAE/BE,EAAY,IAAIC,UAAUF,EAAOlK,EAAOyJ,GAI9C,OAFAG,EAAIS,aAAaF,EAAW,EAAG,GAExB,CAAET,SAAQE,MAAK,EAIXU,GAAiBC,GACVA,EAAWX,IAAIY,aAC/B,EACA,EACAD,EAAWb,OAAO1J,MAClBuK,EAAWb,OAAOD,QAEHgB,KAONC,GAAoBzN,IAQpB,IARqB,IAChC2M,EAAG,WACHK,EAAU,MACVC,GAKDjN,EACC2M,EAAIe,UAAUX,GAAc,CAAEC,aAAYC,UAASR,OAAQ,EAAG,EAAE,EAQrDkB,GAAuBrM,IAYlB,IAZmB,WACnC0L,EAAU,MACVC,EAAK,UACLW,EAAS,WACTC,GAQDvM,EAGC,MAAMgM,EAAaf,GAAaS,GAQhC,OANAM,EAAWX,IAAImB,OACN,OAATF,QAAS,IAATA,KAAYN,GACZA,EAAWX,IAAIe,UAAUX,GAAc,CAAEC,aAAYC,UAASR,OAAQ,EAAG,GACzEa,EAAWX,IAAIoB,UACL,OAAVF,QAAU,IAAVA,KAAaP,GAENA,EAAWX,IAAIY,aAAa,EAAG,EAAGP,EAAW,GAAIA,EAAW,IAAIQ,IAAI,EAOhEQ,GAAgBtD,IAQX,IARY,WAC5BsC,EAAU,WACViB,EAAU,WACVC,GAKDxD,EACC,MAAMyD,EACJ,WAAYF,EACRA,EACAlB,GAAc,CACZC,WAAYA,EACZC,MAAOgB,IAGTG,EACJ,WAAYF,EACRA,EACAnB,GAAc,CACZC,WAAYA,EACZC,MAAOiB,IAKf,OAFAC,EAAiBxB,IAAIe,UAAUU,EAAiB3B,OAAQ,EAAG,GAEpDY,GAAcc,EAAiB,EAG3BE,GAAcA,CACzB5B,EAAkB5B,KAiCF,IAADyD,EAAA,IAhCf,KACEC,EAAI,WACJC,EAAU,SACVC,EAAQ,QACRC,EAAO,WACPC,EAAU,UACVC,EAAS,MACTC,EAAK,WACLC,GAuBDjE,EAED,MAAMkE,EAASD,EACX,CACE,GAAGA,EAAWE,YACd,GAAGF,EAAWG,YACd,GAAwB,QAAxBX,EAAGQ,EAAWI,kBAAU,IAAAZ,IAAI,MAC5B,GAAG/F,GAAWuG,EAAWrP,UACzB0P,KAAK,KACP,KAEEC,EAAU,CACN,MAARb,EAAe,GAAK,QAAQA,OACd,MAAdC,EAAqB,GAAK,cAAcA,MAC5B,MAAZC,EAAmB,GAAK,YAAYA,MACzB,MAAXC,EAAkB,GAAK,WAAWA,MACpB,MAAdC,EAAqB,GAAK,YAAYA,MACzB,MAAbC,EAAoB,GAAK,cAAcA,QAC9B,MAATC,EAAgB,GAAK,SAASA,MACpB,MAAVE,EAAiB,GAAK,eAAeA,MACrC/K,QAAQH,GAAMA,EAAEP,OAAS,IAI3B,OAFAmJ,EAAOE,IAAI3I,OAASoL,EAAQD,KAAK,KAE1B1C,CAAM,EAGF4C,GAAiBA,CAC5B5C,EAAkBX,KAgBF,IAfhB,gBACEwD,EAAe,cACfC,EAAa,eACbC,EAAc,aACdC,EAAY,sBACZC,EAAqB,oBACrBC,GAQD7D,EAUD,OARAW,EAAOE,IAAIiD,UACM,OAAfN,QAAe,IAAfA,IAAmB,EACP,OAAZG,QAAY,IAAZA,IAAgB,EACF,OAAdD,QAAc,IAAdA,IAAkB,EACL,OAAbD,QAAa,IAAbA,IAAiB,EACI,OAArBG,QAAqB,IAArBA,IAAyB,EACN,OAAnBC,QAAmB,IAAnBA,IAAuB,GAElBlD,CAAM,EAOFoD,GAAgBA,CAC3BpD,EACAqD,KAEA,MAAMd,EAAUvC,EAAOA,OAAO1J,MAAQ,EAChCkM,EAAUxC,EAAOA,OAAOD,OAAS,EACvC6C,GAAe5C,EAAQ,CACrBiD,sBAAuBV,EACvBW,oBAAqBV,IAEvB,MAAMc,GAAYD,EAAUzK,KAAKW,GAAM,IAMvC,OALAyG,EAAOE,IAAIqD,OAAOD,GAClBV,GAAe5C,EAAQ,CACrBiD,uBAAwBV,EACxBW,qBAAsBV,IAEjBxC,CAAM,EAOFwD,GAAaA,CACxBxD,EAAkByD,KAEF,IADfrM,EAAGsM,GAAoBD,EAGxB,OADAzD,EAAOE,IAAIyD,MAAMvM,EAAGsM,GACb1D,CAAM,EC9OF4D,GAA8CxR,IASpD,IATqD,MAC1DkE,EAAK,OACLyJ,EAAM,gBACN8D,EAAe,cACfC,EACAC,YAAaC,EACbC,UAAWC,EACXC,YAAaC,EACblQ,aAAcmQ,GACfjS,EACC,MAAMkS,EAAMxQ,IAAMyQ,OAA0B,MACtCC,EAAY1Q,IAAMyQ,QAAO,GAE/BzQ,IAAM2Q,WAAU,KACd,GAAIH,EAAII,UAAYF,EAAUE,QAAS,CACrC,MAAMxE,EAAMoE,EAAII,QAAQvE,WAAW,MACxB,MAAPD,IACF4D,EAAc,CAAE9D,OAAQsE,EAAII,QAASxE,QACrCsE,EAAUE,SAAU,EAExB,IACC,CAACF,EAAWV,IAEf,MAAMa,EACHC,GACAC,IACC,IAAKP,EAAII,UAAYE,EACnB,OAGF,MAAME,EAAOR,EAAII,QAAQK,wBACnB3N,EAAIyN,EAAIG,QAAUF,EAAKG,KACvBvB,EAAImB,EAAIK,QAAUJ,EAAKK,IAC7BC,YAAW,IAAMR,EAAS,CAACxN,EAAGsM,KAAK,EAAE,EAGnCjO,EAAQ3B,IAAMuR,SAAQ,IACtBxB,EACK,CAAEyB,OAAQ,gBAEjB,GAED,CAACzB,IAEEE,EAAcjQ,IAAMuR,SACxB,IAAMV,EAAQX,IACd,CAACA,IAEGC,EAAYnQ,IAAMuR,SAAQ,IAAMV,EAAQT,IAAe,CAACA,IACxDC,EAAcrQ,IAAMuR,SACxB,IAAMV,EAAQP,IACd,CAACA,IAEGlQ,EAAeJ,IAAMuR,SACzB,IAAMV,EAAQN,IACd,CAACA,IAGH,OACE9R,cAAA,UACE+R,IAAKA,EACLhO,MAAOA,EACPyJ,OAAQA,EACRgE,YAAaA,EACbE,UAAWA,EACXE,YAAaA,EACbjQ,aAAcA,EACduB,MAAOA,GACC,E,cC5DP,MAAM8P,GAAqBA,CAChChF,EACAiF,EACAC,KAEA,MAAOnP,EAAOyJ,GAAUQ,GACjBnJ,EAAGsM,GAAK+B,EACf,GAAIrO,EAAI,GAAKA,GAAKd,GAASoN,EAAI,GAAKA,GAAK3D,EACvC,OAAOzC,GAGT,MAAM7F,EAAMiO,GAAcnF,EAAYnJ,EAAGsM,GACzC,MAAO,CAAC8B,EAAM/N,GAAM+N,EAAM/N,EAAM,GAAI+N,EAAM/N,EAAM,GAAI+N,EAAM/N,EAAM,GAAG,EAMxDkO,GAAYA,CACvBH,EACAI,KAIc,CAEdrF,WAAYiF,EAAMjF,WAClBsF,OAAQL,EAAMK,OAAO1O,KAAI,CAACqJ,EAAO/I,IAAQmO,EAAGpF,EAAO/I,EAAK+N,EAAMK,OAAOhP,YAM1DiP,GAAYA,CACvBvF,EACAqF,KAEA,MAAOtP,EAAOyJ,GAAUQ,EAClBwF,EAAuB,IAAIC,kBAAkB1P,EAAQyJ,EAAS,GACpE,IAAK,IAAI2D,EAAI,EAAGA,EAAI3D,EAAQ2D,GAAK,EAC/B,IAAK,IAAItM,EAAI,EAAGA,EAAId,EAAOc,GAAK,EAAG,CACjC,MAAM+E,EAAIiB,GAAWwI,EAAG,CAACxO,EAAGsM,KACtBjM,EAAMiO,GAAcnF,EAAYnJ,EAAGsM,GACzCqC,EAAqBtO,GAAO0E,EAAE,GAC9B4J,EAAqBtO,EAAM,GAAK0E,EAAE,GAClC4J,EAAqBtO,EAAM,GAAK0E,EAAE,GAClC4J,EAAqBtO,EAAM,GAAK0E,EAAE,EACpC,CAEF,OAAO4J,CAAoB,EAOhBE,GACXL,GAaOxT,IAAA,IAAC,MAAEoT,EAAK,OAAEzI,EAAM,WAAEmJ,GAA6B9T,EAAA,OACpDuT,GAAUH,GAAO,CAAC/E,EAAW0F,EAAYC,IACvCN,GAAUN,EAAMjF,YAAakF,GAC3BG,EAAG,CACDJ,QACAjF,WAAYiF,EAAMjF,WAClBxD,SACAmJ,aACAT,QACAW,aACAD,aACAE,kBAAmBF,EAAaC,EAChCE,YAAcnK,GACZoJ,GAAmBC,EAAMjF,WAAYE,EAAWtE,QAGvD,EASQoK,GAAyBA,CACpCC,EAUAZ,IAcOjT,IAAA,IAAC,MAAE6S,EAAK,OAAEzI,EAAM,WAAEmJ,GAA6BvT,EAAA,OACpDgT,GAAUH,GAAO,CAAC/E,EAAW0F,EAAYC,KACvC,MAAMC,EAAoBF,EAAaC,EACjCK,EAAWD,EAAQ,CACvBhB,QACAjF,WAAYiF,EAAMjF,WAClBxD,SACAmJ,aACAE,aACAD,aACAE,sBAGF,OAAOP,GAAUN,EAAMjF,YAAakF,GAClCG,EAAG,CACDa,WACAjB,QACAjF,WAAYiF,EAAMjF,WAClBxD,SACAmJ,aACAT,QACAW,aACAD,aACAE,oBACAC,YAAcnK,GACZoJ,GAAmBC,EAAMjF,WAAYE,EAAWtE,MAErD,GACD,EAGOuJ,GAAgBA,CAAAnS,EAAsB6D,EAAWsM,KAAS,IAAxCpN,GAAkB/C,EAAA,OAC7B,GAAjB6D,EAAIsM,EAAIpN,EAAU,EAQRoQ,GAAa7R,IAQZ,IARa,MACzB2Q,EAAK,gBACL3C,EAAe,cACfC,GAKDjO,EACC,MAAOyB,EAAOyJ,GAAUyF,EAAMjF,WAExBgC,EAAWjM,EAAQ,GAAqB,OAAfuM,QAAe,IAAfA,IAAmB,GAAKvM,EAAQ,EACzDkM,EAAWzC,EAAS,GAAmB,OAAb+C,QAAa,IAAbA,IAAiB,GAAK/C,EAAS,EAC/D,OAAO4F,GAAUH,GAAQ/E,GACvBS,GAAqB,CACnBX,WAAYiF,EAAMjF,WAClBC,MAAOC,EACPU,UAAYN,GACV+B,GAAe/B,EAAY,CACzBgC,kBACAC,gBACAG,uBAAwBV,EACxBW,qBAAsBV,OAG7B,EAUUmE,GAAc1I,IAUb,IAVc,MAC1BuH,EAAK,SACLoB,EAAQ,UACRC,EAAS,UACTC,GAMD7I,EACC,MAAM8I,EAAYpB,GAAUH,GAAQhF,IAClC,MAAMwG,EAAalH,GAAa,CAAC8G,EAAUC,IACrCI,EAAY3G,GAAc,CAAEC,WAAYiF,EAAMjF,WAAYC,UAEhE,GAAIsG,EAEFE,EAAW9G,IAAIe,UAAUgG,EAAUjH,OAAQ,EAAG,EAAG4G,EAAUC,OACtD,CAEL,MAAMtE,EAAUqE,EAAW,EAAIpB,EAAMjF,WAAW,GAAK,EAC/CiC,EAAUqE,EAAY,EAAIrB,EAAMjF,WAAW,GAAK,EACtDyG,EAAW9G,IAAIe,UACbgG,EAAUjH,OACVuC,EACAC,EACAgD,EAAMjF,WAAW,GACjBiF,EAAMjF,WAAW,GAErB,CAEA,OAAOK,GAAcoG,EAAW,IAGlC,MAAO,CACLzG,WAAY,CAACqG,EAAUC,GACvBhB,OAAQkB,EAAUlB,OACnB,EAGUqB,GAAkBC,IAG9B,CACC5G,WAAY4G,EAAK5G,WACjBsF,OAAQuB,aAAM,EAAGD,EAAKf,YAAYjP,KAEhC,IAAM,IAAI6O,kBAAkBmB,EAAK5G,WAAW,GAAK4G,EAAK5G,WAAW,GAAK,OAI7D8G,GAAkB7B,IAAY,CACzCjF,WAAYiF,EAAMjF,WAClBsF,OAAQL,EAAMK,OAAO1O,KAAKmQ,GAAM,IAAItB,kBAAkBsB,OAG3CC,GAAYJ,GAKvB5B,GACE4B,EAAK3B,MAAMjF,WACX4G,EAAK3B,MAAMK,OAAOsB,EAAKhB,YACvBgB,EAAK1B,OAGI+B,GAAYL,IAMvB,MAAM1P,EAAMiO,GACVyB,EAAK3B,MAAMjF,WACX4G,EAAK1B,MAAM,GACX0B,EAAK1B,MAAM,IAEPjF,EAAQ2G,EAAK3B,MAAMK,OAAOsB,EAAKhB,YACrC3F,EAAM/I,GAAO0P,EAAKnU,MAAM,GACxBwN,EAAM/I,EAAM,GAAK0P,EAAKnU,MAAM,GAC5BwN,EAAM/I,EAAM,GAAK0P,EAAKnU,MAAM,GAC5BwN,EAAM/I,EAAM,GAAK0P,EAAKnU,MAAM,EAAE,EAGnByU,GAAmBA,CAACjC,EAAcY,KAC7C,MAAMsB,EAAgBlC,EAAMK,OAM5B,MAAO,CACLtF,WAAYiF,EAAMjF,WAClBsF,OAAQuB,aAAM,EAAGhB,GAAYjP,KAAKE,IAChC,MAAMsQ,EAAc/O,KAAKoE,MAAO3F,EAAI+O,EAAcsB,EAAc7Q,QAChE,OAAO6Q,EAAcC,EAAY,IAEpC,EAGU9K,GAA0B2I,IAErC,IAAK,MAAMhF,KAASgF,EAAMK,OACxB,IAAK,IAAIzO,EAAI,EAAGA,EAAIoO,EAAMjF,WAAW,GAAInJ,GAAK,EAC5C,IAAK,IAAIsM,EAAI,EAAGA,EAAI8B,EAAMjF,WAAW,GAAImD,GAAK,EAAG,CAC/C,MAAMkE,EAAKrC,GAAmBC,EAAMjF,WAAYC,EAAO,CAACpJ,EAAGsM,IAC3D,GAAImE,GAA4BD,GAC9B,OAAO,CAEX,CAGJ,OAAO,CAAK,E,mCCrUd,MAOME,GAAkBC,UAGtB,MAAMC,OAVe1M,IACrB,IAAIC,SAAsBC,IACxB,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,IAAMH,EAAQC,EAAOG,QACrCH,EAAOwM,kBAAkB3M,EAAK,IAMX4M,CAAc5M,GAC7B6M,EAAMC,oBAASJ,GAEfzH,EAAyB,CAAC4H,EAAIE,IAAI/R,MAAO6R,EAAIE,IAAItI,QACjDuI,EAAcxI,GAAaS,GAE3BgI,EAAwB,GAExB1C,EAAS2C,4BAAiBL,GAAK,GAAMhR,KACxCsR,IACC,MAAMC,EAAQD,EAAYC,MACL,kBAAVA,GAAsBA,EAAQ,GAEvCH,EAAYI,KAAKD,GAOc,IAA7BD,EAAYG,cACdN,EAAYpI,IAAI2I,UAAU,EAAG,EAAGtI,EAAW,GAAIA,EAAW,IAG5D,MAAMuI,EAAwB,CAC5BL,EAAYM,KAAKzS,MACjBmS,EAAYM,KAAKhJ,QAIbiJ,EAAQlJ,GAAagJ,GACrBrI,EAAYuI,EAAM9I,IAAI+I,gBAAgBH,EAAU,GAAIA,EAAU,IAUpE,OATArI,EAAUM,KAAKmI,IAAIT,EAAYO,OAC/BA,EAAM9I,IAAIS,aAAaF,EAAW,EAAG,GAErC6H,EAAYpI,IAAIe,UACd+H,EAAMhJ,OACNyI,EAAYM,KAAK9D,KACjBwD,EAAYM,KAAK5D,KAGZvE,GAAc0H,EAAY,IAI/Ba,EACJZ,EAAYa,QAAO,CAACC,EAAKC,IAAQD,EAAMC,GAAK,GAAKf,EAAY1R,OAEzD0S,EAAM3Q,KAAK4Q,KAAK,IAAOL,GAE7B,MAAO,CACL3D,MAAO,CAAEjF,aAAYsF,UACrB0D,MACD,EASUE,GAAY1B,UAGvB,IAAI2B,EACApO,EACJ,GAA6B,kBAAlBqO,EAA4B,CACrC,MAAMC,EA+FV,SAAqBF,GACnB,MAAMG,EAAUH,EAAQI,MAAM,uBAC9B,OAAc,OAAPD,QAAO,IAAPA,OAAO,EAAPA,EAAU,EACnB,CAlGqBE,CAAYJ,GAC7BrO,EAmFJ,SAAsBlJ,GAMZ,IANa,QACrBsX,EAAO,MACPM,GAID5X,EACC,MAAM6X,EAAOC,GAAuBR,GACpC,OAAO,IAAIS,KAAK,CAACF,GAAOD,EAC1B,CA5FWI,CAAc,CACnBV,QAASC,EACTK,MAAO,SAAiB,OAARJ,QAAQ,IAARA,IAAY,UAE9BF,EAAUC,CACZ,MACErO,EAAOqO,EACPD,QAAgBQ,GAA6B5O,GAK/C,GAFcA,EAAK9H,KAAK6W,SAAS,QAEtB,CACT,MAAM,MAAE7E,EAAK,IAAE+D,SAAczB,GAAgBxM,GAC7C,MAAO,CACLoO,UACAlE,QACA+D,MAEJ,CAuCA,MAAO,CACL/D,YAtCkB,IAAIjK,SAAe,CAAC+O,EAAKC,IAC3CC,KACEd,GACA,CAACe,EAAYC,KACX,GAAID,EACF,OAAOF,EAAIE,GAGb,GAA6B,IAAzBC,EAAQC,MAAM9T,OAAc,CAC9B,MAAOP,EAAOyJ,GAAU2K,EAAQC,MAEhC,OAAOL,EAAI,CACTzE,OAAQ,CAACG,kBAAkB4E,KAAKF,EAAQ3J,OACxCR,WAAY,CAACjK,EAAOyJ,IAExB,CAGA,MAAO8K,EAAWvU,EAAOyJ,GAAU2K,EAAQC,MACrCG,EAAYxU,EAAQyJ,EAAS,EAC7B8F,EAA8B,GACpC,IAAK,IAAIxO,EAAI,EAAGA,EAAIwT,EAAWxT,GAAK,EAAG,CACrC,MAAMmJ,EAAQkK,EAAQ3J,KAAKgK,SACzB1T,EAAIyT,GACHzT,EAAI,GAAKyT,GAGZjF,EAAO8C,KAAK3C,kBAAkB4E,KAAKpK,GACrC,CACA,OAAO8J,EAAI,CACTzE,SACAtF,WAAY,CAACjK,EAAOyJ,IACpB,MAON2J,UACAH,IAAK,GACN,EAGUyB,GAAkBjD,UAC7B,MAAMuC,QAAYW,MAAMC,GAClBC,EAAcb,EAAIc,QAAQC,IAAI,gBACpC,IAAKF,EACH,MAAM,IAAIxU,MAAM,oCAGlB,MAAM2U,QAAoBhB,EAAIgB,cAQ9B,MAAO,QAAQH,YAPMI,KACnB,IAAItQ,WAAWqQ,GAAalC,QAC1B,CAACrI,EAAMyK,IAASzK,EAAO0K,OAAOC,aAAaF,IAC3C,MAI+C,EC9J9C,SAASG,GAAWvZ,GAIW,IAJP,MAC7BwZ,EAAK,eACLC,EAAc,SACdC,GACS1Z,EACT,MAAO2Z,EAAGC,GAAQlY,IAAMC,SAAY6X,GAC9BK,EAAcnY,IAAMyQ,SACpB2H,EAAgBpY,IAAMG,aACzBkY,IACCH,EAAKG,GACsB,MAAvBF,EAAYvH,SACd0H,aAAaH,EAAYvH,SAE3BuH,EAAYvH,QAAUU,YAAW,KAC/B0G,EAASK,EAAK,GACC,OAAdN,QAAc,IAAdA,IAAkB,IAAI,GAE3B,CAACA,EAAgBC,IAQnB,OALAhY,IAAM2Q,WAAU,KAEduH,EAAKJ,EAAM,GACV,CAACA,IAEG,CAACG,EAAGG,EACb,CC/BA,MAAMG,GAAW,IAYXC,GAAuB/L,IAC3B,GAAkB,MAAdA,EAGF,MAAO,CACLtN,SAAU,QACVsZ,UAAW,QACXjW,MAAO,KAIX,MAAOA,EAAOyJ,GAAUQ,EAClBiM,EAAczM,EAASzJ,EAC7B,GAAIA,EAAQyJ,EAAQ,CAIlB,MAAO,CACL9M,SAAU,GAJKoZ,OAKfE,UAAW,GAJKC,EAAcH,OAK9B/V,MAAO,IACPyJ,OAAQ,IAAMyM,EAElB,CAIE,MAAO,CACLD,UAAW,GAHKF,OAIhBpZ,SAAU,GAHM,EAAIuZ,EAAeH,OAInC/V,MAAO,IACPyJ,OAAQ,IAAMyM,EAElB,EAGWC,GAA0Bra,IAAA,IAAC,IAAEsa,EAAG,IAAEC,EAAG,WAAEpM,GAAYnO,EAAA,OAC9DG,cAAA,OACEma,IAAKA,EACLC,IAAK,OAAOA,IACZlX,MAAO6W,GAAoB/L,IACtB,EClDHqM,GAAiB5U,IACrB,MAAM6U,EAAQ7U,EAAE0C,MAAM,KACtB,OAAOmS,EAAMA,EAAMhW,OAAS,EAAE,EAWnBiW,GAA0C1a,IAGhD,IAHiD,aACtD2a,EAAY,SACZjB,GACD1Z,EACC,MAAO4a,EAAOC,GAAYnZ,IAAMC,WAChC,OACEI,eAACoB,IAAK,CAACK,QAAS,EAAGD,WAAW,SAAQnB,SAAA,CACpCjC,cAACgD,IAAK,CAACG,UAAU,MAAKlB,SACpBjC,cAAC2a,IAAS,CACRvZ,MAAM,MACNU,QAAQ,WACR8Y,WAAS,EACTH,QAASA,EACTI,WAAYJ,EACZK,OAAQtF,UACN,MAAMuF,EAAOC,EAAEC,OAAO5B,MACtB,IAGE,GAFAqB,OAASnW,GAELwW,EAAKG,WAAW,SAAU,CAE5B,MAAM,MAAEjI,EAAK,IAAE+D,SAAcmE,EAAgBjE,UAAU6D,GAYvD,YAXAxB,EACE,CACE3D,IAAKmF,EACL9H,QACAmI,uBAAwBL,EACxBM,qBACEC,EAAUhR,uBAAuB2I,IAErC,QACA+D,EAGJ,CAEA,IAAKW,EAASnS,MAAMuV,GAElB,YADAL,EAAS,qCAGX,MAAM9E,QAAYuF,EAAgB1C,gBAAgBsC,IAC5C,MAAE9H,EAAK,IAAE+D,SAAcmE,EAAgBjE,UAAUtB,GACvD2D,EACE,CACE3D,MACA3C,QACAmI,uBAAwBxF,EACxByF,qBAAsBC,EAAUhR,uBAAuB2I,IAEzDoH,GAAcU,GACd/D,EAEJ,CAAE,MAAOkB,GACP/S,QAAQsV,MAAM,sBAAuBvC,GACrCwC,EAAS,sBACX,OAIN1a,cAACub,IAAG,CAAAtZ,SAAC,OACLL,eAACqB,IAAM,CACLuY,UAAWxb,cAACqC,IAAI,CAAAJ,SAAC,UACjBE,GAAI,CAAEzB,SAAU,SAChBoB,QAAQ,YACR2Z,UAAU,QAAOxZ,SAAA,CAClB,kBAECjC,cAAA,SACE6I,KAAK,OACL6S,QAAM,EACNC,OAAO,2CACP1a,KAAK,eACLsY,SAAU/D,UAAkB,IAADoG,EACzB,MACM7S,EADQ8S,MAAMxD,KAAuB,QAAnBuD,EAACE,EAAMb,OAAOc,aAAK,IAAAH,IAAI,IAC5B,GACnB,GAAI7S,EAAM,CACR,MAAM,QAAEoO,EAAO,MAAElE,EAAK,IAAE+D,SAAcmE,EAAgBjE,UACpDnO,GAEFwQ,EACE,CACE3D,IAAKuB,EACLlE,QACAmI,uBAAwBjE,EACxBkE,qBAAsBC,EAAUhR,uBAAuB2I,IAEzDoH,GAActR,EAAK9H,MACnB+V,EAEJ,QAILwD,GACCxa,cAACka,GAAG,CACFC,IAAKK,EAAa5E,IAClB5H,WAAYwM,EAAavH,MAAMjF,WAC/BoM,IAAI,aAGF,E,wBClHL,MAAM4B,GAC8C,MAAzD,I,QAAIC,GAAa3O,OAAO1H,UAAUsW,WAAWC,SAElCC,GAAO9O,OAAe8O,IAEtBC,GAAmB,QAARD,GAAgBjX,QAAQC,IAAM,KAAe,E,kCCH9D,MAAMkX,GAAsCzc,IAAA,IAAC,YAAE0c,GAAa1c,EAAA,OACjE0c,EACEvc,cAACC,IAAO,CAACwC,MAAO8Z,EAAYta,SAC1BjC,cAACqC,IAAI,CAAC1B,SAAS,QAAQF,MAAM,SAAQwB,SAAC,WAItC,IAAI,ECZGua,GACX3X,GAEiB,oBAANA,EACFA,EAEF,IAAMA,ECMT4X,GAKD5c,IAA6C,IAA5C,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EAC1C,MAAM6c,EAAQ,GACRC,EAAS,IAIRC,EAAUC,GAAezD,GAAY,CAC1CC,QACAE,WACAD,eALoB,OAQfwD,EAAqBC,GAA0Bxb,IAAMC,SAAgB,CAC1E,EAAG,KAGEwb,EAAWC,GAAgB1b,IAAMC,SACtC,MAEI+P,EAAgBhQ,IAAMG,aAAYtB,IAA0B,IAAzB,IAAEuN,GAAiBvN,EAC1D6c,EAAatP,EAAI,GAChB,KAEIuP,EAAYC,GAAiB5b,IAAMC,SAAwB,MAE5D4b,EAAkB7b,IAAMuR,SAAQ,KACpC,MAAMuK,EAAYT,EAAShY,KAAI,CAACgF,EAAG1E,KAAG,CACpCA,MACAgO,MAAOtJ,EACP0T,SAAU3F,EAAS1Q,cACjB,CAAC2C,EAAE,GAAK8S,EAAO9S,EAAE,GAAK+S,GACtBG,OAKES,EADSC,KAASH,GAAYlR,GAAMA,EAAEmR,WACrB,GACvB,OAAOC,EAAQD,SAlCK,EAkCsBC,EAAQrY,IAAM,IAAI,GAC3D,CAAC4X,EAAqBF,IAEzBrb,IAAM2Q,WAAU,KACd,GAAK8K,EAAL,CAIAA,EAAU1G,UAAU,EAAG,EAAGoG,EAAOC,GAGjCK,EAAUS,UAAY,MACtB,IAAK,MAAMvK,KAAS0J,EAAU,CAC5B,MAAM/X,EAAIqO,EAAM,GAAKwJ,EACfvL,EAAI+B,EAAM,GAAKyJ,EACrBK,EAAUU,YACVV,EAAUW,QAAQ9Y,EAAGsM,EAlDH,IAkDoC,EAAG,EAAG,EAAI9K,KAAKW,IACrEgW,EAAUY,MACZ,CAGAZ,EAAUU,YACVV,EAAUa,OAAO,EAAG,GACpBb,EAAUc,YAAc,QACxBd,EAAUe,cACRnB,EAAS,GAAG,GAAKF,EACjBE,EAAS,GAAG,GAAKD,EACjBC,EAAS,GAAG,GAAKF,EACjBE,EAAS,GAAG,GAAKD,EACjBD,EACAC,GAEFK,EAAUgB,QA1BV,CA0BkB,GACjB,CAACpB,EAAUI,IAEd,MAAMxL,EAAcjQ,IAAMG,aAAY,KACpCyb,EAAcC,EAAgB,GAC7B,CAACA,IAEE1L,EAAYnQ,IAAMG,aAAY,KAClCyb,EAAc,KAAK,GAClB,IAEGvL,EAAcrQ,IAAMG,aACvBkI,IACCmT,EAAuBnT,GAEvB,MAAMqU,EAAkB,CACtBtG,EAAS1R,MAAM2D,EAAE,GAAK8S,EAAO,EAAGA,GAChC/E,EAAS1R,MAAM2D,EAAE,GAAK+S,EAAQ,EAAGA,IAGhB,IAAfO,EACFL,EAAY,CAACoB,EAAUrB,EAAS,KACR,IAAfM,GACTL,EAAY,CAACD,EAAS,GAAIqB,GAC5B,GAEF,CAACf,EAAYN,EAAUC,IAGzB,OACE7c,cAACgD,IAAK,CAACK,QAAS,EAAEpB,SAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAQoc,WAAW,SAAQjc,SAC5ChB,IAEHjB,cAAA,QAAMkD,MAAO,CAAEgb,WAAY,UAAWjc,SACpCjC,cAACsc,GAAW,CAACC,YAAaA,MAE5Bvc,cAACub,IAAG,CAACza,OAAQ,EAAEmB,SACbjC,cAACqR,GAAa,CACZtN,MAAO2Y,EACPlP,OAAQmP,EACRpL,cAAeA,EACfC,YAAaA,EACbE,UAAWA,EACX/P,aAAc+P,EACdE,YAAaA,EACbN,gBAAoC,MAAnB8L,UAIjB,EAIL,SAASe,GAAYvJ,GAK1B,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAACyc,GAAW,CACVxb,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACdE,SAAU8E,EAAO9E,SACjBgD,YAAa3H,EAAK2H,cAK5B,C,cC5JA,MAAM+B,GAKDze,IAA6C,IAA5C,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EAC1C,OACEG,cAACgD,IAAK,CAACK,QAAS,EAAEpB,SAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAQoc,WAAW,SAAQjc,SAC5ChB,IAEHjB,cAAA,QAAMkD,MAAO,CAAEgb,WAAY,UAAWjc,SACpCjC,cAACsc,GAAW,CAACC,YAAaA,MAE5Bvc,cAACue,KAAQ,CACP,aAAYtd,EACZud,QAASnF,EACTE,SAAWyB,GAAMzB,EAASyB,EAAEC,OAAOuD,eAGjC,EAIL,SAASC,GAAc7J,GAK5B,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAACse,GAAa,CACZrd,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACdE,SAAU8E,EAAO9E,SACjBgD,YAAa3H,EAAK2H,cAK5B,C,cCzCA,MAAMmC,GAAuC7e,IAAA,IAAC,MAAEY,GAAOZ,EAAA,OACrDG,cAAA,OACEkD,MAAO,CACLa,MAAO,QACPyJ,OAAQ,QACRhN,gBAAiBme,EAAUpV,WAAW9I,KAExC,EAGEme,GAKDxe,IAA6C,IAA5C,KAAEa,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,SAAEhD,GAAUnZ,EAC1C,OACEJ,cAAC0C,EAAU,CACTC,QACEf,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,IACzBlD,GAASrZ,cAAC0e,GAAQ,CAACje,MAAO4Y,OAE9BpX,SAEDjC,cAAC6e,KAAY,CACXC,cAAc,EACdC,aAAc,GACdte,MAAOke,EAAUpV,WAAW8P,GAC5B2F,iBAAmBpV,IACjB2P,EAASoF,EAAU5U,aAAaH,EAAEI,KAAK,KAGhC,EAIV,SAASiV,GAAiBrK,GAK/B,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAAC4e,GAAgB,CACf3d,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACdE,SAAU8E,EAAO9E,SACjBgD,YAAa3H,EAAK2H,cAK5B,C,kCCtDA,MAAM2C,GAMDrf,IAAsD,IAArD,KAAEoB,EAAI,QAAEke,EAAO,MAAE9F,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EACnD,OACE+B,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5Bvc,cAACof,KAAW,CAAAnd,SACVjC,cAACqf,KAAM,CACLC,WAAS,EACTjG,MAAOA,EACPE,SAAWuC,GAAUvC,EAASuC,EAAMb,OAAO5B,OAAiBpX,SAE3Dkd,EAAQva,KAAK2a,GACZvf,cAACwf,KAAQ,CAAenG,MAAOkG,EAAElG,MAAMpX,SACpCsd,EAAEte,MADUse,EAAElG,eAMjB,E,cCtBZ,MAAMoG,GAMD5f,IAAoD,IAAnD,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,MAAEmD,EAAK,SAAEnG,GAAU1Z,EACjD,MAAOkX,EAAK4I,GAAUpe,IAAMC,SAAS6X,EAAMxP,aACpC+V,EAAaC,GAAkBte,IAAMC,SAAS,IAgBrD,OACEI,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5B3a,eAACwd,KAAW,CAAAnd,SAAA,CACVjC,cAAC2a,IAAS,CACRF,QAASmF,EACTvG,MAAOtC,EACP+D,OAxBOA,KACb,GAAI/D,IAAQsC,EAAMxP,WAChB,OAGF,MAAM3D,EAAIwZ,EAAM3I,GACZ7Q,EAAE4Z,OACJD,EAAe,IACftG,EAASrT,EAAEmT,QAEXwG,EAAe3Z,EAAE6Z,OACnB,EAcMxG,SAAWyB,IACT2E,EAAO3E,EAAEC,OAAO5B,MAAM,IAGzBuG,GAAe5f,cAACggB,KAAc,CAAA/d,SAAE2d,SAE7B,EAICK,GAAcrL,IAM1B,CACC3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,IACH,MAAM,IAAElY,EAAG,IAAEC,GAAQwO,EAkBrB,OACE5U,cAACyf,GAAU,CACTxe,KAAM2T,EAAK3T,KACXsb,YAAa3H,EAAK2H,YAClBmD,MArBWja,IACb,MAAMS,EAAIga,WAAWza,GACrB,OAAI0a,MAAMja,IAAMA,EAAE2D,aAAepE,EACxB,CAAEqa,OAAO,EAAOC,OAAQ,yBAErBxb,IAAR4B,GAAqBD,EAAIC,EACpB,CACL2Z,OAAO,EACPC,OAAQ,oCAAoC5Z,UAGpC5B,IAAR6B,GAAqBF,EAAIE,EACpB,CAAE0Z,OAAO,EAAOC,OAAQ,iCAAiC3Z,KAE3D,CAAE0Z,OAAO,EAAMzG,MAAOnT,EAAG,EAQ9BqT,SAAU8E,EAAO9E,SACjBF,MAAOgF,EAAOhF,OACd,ICvFF+G,GAKDvgB,IAA6C,IAA5C,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EAC1C,MAAMwgB,EAAW9e,IAAMuR,SACrB,SACYvO,IAAV8U,OACI9U,EACAoa,EAAUpV,WAAW,IAAI4B,MAAYK,IAAI,CAAC6N,EAAO,IAAK,KAAM,OAClE,CAACA,IAEH,OACEzX,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5Bvc,cAACsgB,KAAS,CACR7f,MAAO4f,EAEPrB,iBAAkB5e,IAAA,IAAC,IAAEgL,GAAKhL,EAAA,OAAKmZ,EAASnO,EAAIO,EAAE,MAE1C,EAIL,SAAS4U,GAAe3L,GAK7B,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAACogB,GAAc,CACbnf,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACdE,SAAU8E,EAAO9E,WAK3B,CCvCA,MAAMiH,GAAmC,CACvCnF,sBAAsB,EACtBzF,IAAK,shCACLwF,uBACE,shCACFnI,MAAO,CACLjF,WAAY,CAAC,EAAG,GAChBsF,OAAQ,CAAC,IAAIG,kBAAkB,CAAC,EAAG,EAAG,EAAG,SCP7C,MAAMgN,GAMD5gB,IAAoD,IAAnD,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,MAAEmD,EAAK,SAAEnG,GAAU1Z,EACjD,MAAOkX,EAAK4I,GAAUpe,IAAMC,SAAS6X,EAAMxP,aACpC+V,EAAaC,GAAkBte,IAAMC,SAAS,IAerD,OACEI,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5B3a,eAACwd,KAAW,CAAAnd,SAAA,CACVjC,cAAC2a,IAAS,CACRF,QAASmF,EACTvG,MAAOtC,EACP+D,OAvBOA,KACb,GAAI/D,IAAQsC,EAAMxP,WAChB,OAEF,MAAM3D,EAAIwZ,EAAM3I,GACZ7Q,EAAE4Z,OACJD,EAAe,IACftG,EAASrT,EAAEmT,QAEXwG,EAAe3Z,EAAE6Z,OACnB,EAcMxG,SAAWyB,IACT2E,EAAO3E,EAAEC,OAAO5B,MAAM,IAGzBuG,GAAe5f,cAACggB,KAAc,CAAA/d,SAAE2d,SAE7B,EAICc,GAAY9L,IAMxB,CACC3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,IACH,MAAM,IAAElY,EAAG,IAAEC,GAAQwO,EAkBrB,OACE5U,cAACygB,GAAQ,CACPxf,KAAM2T,EAAK3T,KACXsb,YAAa3H,EAAK2H,YAClBmD,MArBWja,IACb,MAAMS,EAAI+D,SAASxE,EAAG,IACtB,OAAI0a,MAAMja,IAAMA,EAAE2D,aAAepE,EACxB,CAAEqa,OAAO,EAAOC,OAAQ,2BAErBxb,IAAR4B,GAAqBD,EAAIC,EACpB,CACL2Z,OAAO,EACPC,OAAQ,oCAAoC5Z,UAGpC5B,IAAR6B,GAAqBF,EAAIE,EACpB,CAAE0Z,OAAO,EAAOC,OAAQ,iCAAiC3Z,KAE3D,CAAE0Z,OAAO,EAAMzG,MAAOnT,EAAG,EAQ9BqT,SAAU8E,EAAO9E,SACjBF,MAAOgF,EAAOhF,OACd,I,kCClFR,MAAMsH,GAMD9gB,IAAsD,IAArD,KAAEoB,EAAI,QAAEke,EAAO,MAAE9F,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EACnD,OACE+B,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5Bvc,cAACof,KAAW,CAAC3D,UAAU,WAAUxZ,SAC/BjC,cAAC4gB,KAAU,CACT,aAAY3f,EACZmd,aAAc/E,EACdE,SAAWuC,GAAUvC,EAASuC,EAAMb,OAAO5B,OAAOpX,SAEjDkd,EAAQva,KAAK2a,GACZvf,cAAC6gB,KAAgB,CACfxH,MAAOkG,EAAElG,MACTyH,QAAS9gB,cAAC+gB,KAAK,IACf3f,MAAOme,EAAEte,MACJse,EAAElG,eAKT,EAIL,SAAS2H,GAA6BpM,GAM3C,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAAC2gB,GAAU,CACT1f,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACd8F,QAASvK,EAAKuK,QACd5C,YAAa3H,EAAK2H,YAClBhD,SAAW9T,GAAM4Y,EAAO9E,SAAS9T,KAK3C,C,cC5DA,MAAMwb,GAQDphB,IAA6D,IAA5D,KAAEoB,EAAI,MAAEoY,EAAK,IAAElT,EAAG,IAAEC,EAAG,KAAE8a,EAAI,YAAE3E,EAAW,SAAEhD,GAAU1Z,EAC1D,MAAOkX,EAAK4I,GAAUvG,GAAY,CAChCC,QACAE,WACAD,eAAgB,MAGlB,OACE1X,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5B3a,eAACoB,IAAK,CACJG,UAAU,MACVE,QAAS,EACTlB,GAAI,CAAE6B,YAAa,MAAOmd,aAAc,OAAQlf,SAAA,CAEhDjC,cAACohB,KAAM,CACL,aAAYngB,EACZoY,MAAOtC,EACPmK,KAAMA,EACNG,kBAAkB,MAClBC,iBAAmBzc,GAAMA,EAAEgF,WAC3B1D,IAAKA,EACLC,IAAKA,EACLmT,SAAUA,CAACyB,EAAG3B,KACZsG,EAAOtG,EAAgB,IAG3BrZ,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAE8U,SAEzB,EAIL,SAASwK,GAAY3M,GAQ1B,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAACihB,GAAW,CACVhgB,KAAM2T,EAAK3T,KACXoY,MAAOgF,EAAOhF,MACdE,SAAU8E,EAAO9E,SACjBpT,IAAKyO,EAAKzO,IACVC,IAAKwO,EAAKxO,IACV8a,KAAMtM,EAAKsM,KACX3E,YAAa3H,EAAK2H,cAK5B,CCtEA,MAAMiF,GAKD3hB,IAA6C,IAA5C,KAAEoB,EAAI,MAAEoY,EAAK,YAAEkD,EAAW,SAAEhD,GAAU1Z,EAC1C,MAAOkX,EAAK4I,GAAUpe,IAAMC,SAAS6X,GAErC,OACEzX,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE5Bvc,cAACof,KAAW,CAAAnd,SACVjC,cAAC2a,IAAS,CACRtB,MAAOtC,EACPwC,SAAWyB,GAAM2E,EAAO3E,EAAEC,OAAO5B,OACjCyB,OAAQA,KACF/D,EAAIzS,OAAS,GACfiV,EAASxC,EACX,QAIA,EAIC0K,GAAa7M,IAIzB,CACC3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GACHre,cAACwhB,GAAS,CACRvgB,KAAM2T,EAAK3T,KACXsb,YAAa3H,EAAK2H,YAClBhD,SAAU8E,EAAO9E,SACjBF,MAAOgF,EAAOhF,U,cCvBpB,MAAMqI,GAA0D7hB,IAOzD,IAP0D,KAC/DoB,EAAI,aACJ0gB,EAAY,eACZC,EAAc,MACdvI,EAAK,YACLkD,EAAW,SACXhD,GACD1Z,EACC,MAAOwe,EAAQwD,GAAatgB,IAAMC,SAChC6X,EAAMzU,KAAK4U,IAAC,CAAQsI,MAAOF,IAAkBG,OAAQvI,OAEvD,OACExZ,cAACgiB,IAAK,CAAA/f,SACJL,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAEhB,IAC7BjB,cAACsc,GAAW,CAACC,YAAaA,OAE3B8B,EAAOzZ,KAAI,CAAAxE,EAAoB8E,KAAS,IAA5B,MAAE4c,EAAK,OAAEC,GAAQ3hB,EAC5B,MAAM6hB,EAAMH,EAAMja,GAAG,CACnBwR,MAAO0I,EACPxI,SAAWjU,IACT,MAAM4c,EAAI7D,EAAOzZ,KAAI,CAACud,EAAMrd,IACtBI,IAAQJ,EACH,CACLgd,QACAC,OAAQzc,GAGL6c,IAETN,EAAUK,GACV3I,EAAS2I,EAAEtd,KAAKsB,GAAMA,EAAE6b,SAAQ,IAIpC,OACEngB,eAACoB,IAAK,CAACG,UAAU,MAAKlB,SAAA,CACpBjC,cAACoiB,KAAU,CACTlhB,QAASA,KACP,MAAMmhB,EAAYhE,EAAOrZ,QAAO,CAACH,EAAGC,IAAMA,IAAMI,IAChD2c,EAAUQ,GACV9I,EAAS8I,EAAUzd,KAAKsB,GAAMA,EAAE6b,SAAQ,EAE1C7e,MAAO,CACLof,WACU,IAARpd,EACI,cACAX,GACNtC,SAEFjC,cAACqC,IAAI,CAAAJ,SAAC,aAEPggB,IAhByB,GAAGhhB,KAAQiE,IAiB/B,IAGZlF,cAACiD,IAAM,CACLnB,QAAQ,YACRZ,QAASA,KACP,MAAMghB,EAAIN,IACJS,EAA0B,IAC3BhE,EACH,CACEyD,MAAOI,EACPH,OAAQG,EAAE9D,iBAGdyD,EAAUQ,GACV,MAAME,EAAOF,EAAUzd,KAAKsB,GAAMA,EAAE6b,SACpCxI,EAASgJ,EAAK,EACdtgB,SAED0f,QAGC,EAIL,SAASa,GAAwC5N,GAOtD,MAAO,CACL3T,KAAM2T,EAAK3T,KACXmd,aAAc5B,GAAgB5H,EAAKwJ,cACnCvW,GAAKwW,GAEDre,cAAC0hB,GAAmB,CAClBzgB,KAAM2T,EAAK3T,KACX0gB,aAAc/M,EAAK+M,aACnBtI,MAAOgF,EAAOhF,MACduI,eAAgBhN,EAAKgN,eACrBrF,YAAa3H,EAAK2H,YAClBhD,SAAU8E,EAAO9E,WAK3B,CCvHO,MAAMkJ,GAAwD7N,IAUpE,IAAA8N,EAAA,MAAiB,CAChBzhB,KAAM2T,EAAK3T,KACX0hB,MAAO/N,EAAK+N,MACZtE,OAAQzJ,EAAKyJ,OACb9B,YAAa3H,EAAK2H,YAClBqG,qBAAsBhO,EAAKgO,qBAC3B/a,GAAI+M,EAAK/M,GACT7F,SAAuB,QAAf0gB,EAAE9N,EAAK5S,gBAAQ,IAAA0gB,KACvBG,WAAYjO,EAAKiO,WACjBC,kBAAmBlO,EAAKkO,kBACzB,ECxBYC,GAAcN,GAAY,CACrCxhB,KAAM,eACN0hB,MAAO,QACPE,WAAY,IACZtG,YAAa,mDACb8B,OAAQ,CACNqC,GAAS,CACPzf,KAAM,QACNsb,YACE,qGACF6B,aAAenL,GAAWA,EAAQA,EAAMjF,WAAW,GAAK,EACxD7H,IAAK,IAEPua,GAAS,CACPzf,KAAM,SACNsb,YACE,qGACF6B,aAAenL,GAAWA,EAAQA,EAAMjF,WAAW,GAAK,EACxD7H,IAAK,IAEPob,GAAY,CACVtgB,KAAM,aACNkF,KAAM,IACNC,IAAK,IACL8a,KAAM,EACN9C,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,WACNkF,KAAM,IACNC,IAAK,IACL8a,KAAM,EACN9C,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,aACNkF,KAAM,IACNC,IAAK,IACL8a,KAAM,EACN9C,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,QACNkF,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN9C,aAAc,KAGlBvW,GAAIhI,IAUG,IAVF,MACHoT,EACAU,YACEqP,EACAC,EACAzT,EACAC,EACAE,EACAE,IAEHhQ,EACC,MAAOqjB,EAAUC,GAAalQ,EAAMjF,WAE9BoV,EAAiBJ,EAAgB,GAAKC,EAAiB,EAGvD5O,EACJ+O,GAAoC,IAAlBJ,EACd3c,KAAK4Q,KAAMiM,EAAWC,EAAaF,GACnCD,EACA1O,EACJ8O,GAAqC,IAAnBH,EACd5c,KAAK4Q,KAAMkM,EAAYD,EAAYF,GACnCC,EAGAI,EAAgBhP,EAAWC,EAAY4O,EAAWC,EAExD,IAAIG,EAAYrQ,EAoChB,OAjCImQ,IAAmBC,IACrBC,EAAYhI,EAAUlH,YAAY,CAChCnB,MAAOqQ,EACPjP,WACAC,YACAC,WAAW,KAIf+O,EAAYhI,EAAUlI,UAAUkQ,GAAYpV,GAC1CqV,EAAW5U,qBAAqB,CAC9BX,WAAYsV,EAAUtV,WACtBC,MAAOC,EACPU,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCkB,WAAYA,EAAa,IACzBC,SAAUA,EAAW,IACrBE,WAAYA,EAAa,IACzBE,MAAOA,QAMXuT,GAAkBC,IACpBC,EAAYhI,EAAUlH,YAAY,CAChCnB,MAAOqQ,EACPjP,WACAC,YACAC,WAAW,KAIR+O,CAAS,ICjHP9iB,GAAkBiiB,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,SACPpG,YAAa,mDACb8B,OAAQ,CACNY,GAAiB,CACfhe,KAAM,QACNmd,aAAcO,EAAU5U,aAAa,aAEvCwX,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAalT,EAAOiP,IAAU7P,EAAA,OAC1Cyb,EAAUlI,UAAUH,GAAQhF,IAC1B,MAAMiB,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,WAAYqM,EAAU/H,UAAUN,EAAMjF,YAAY,IAAMvN,IACxDyO,cACA,GACF,ICjCOsU,GAAkBf,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,QACPpG,YAAa,gEACbqG,qBACE,4GAEFvE,OAAQ,CTgBH,SAAyBxe,GAE8B,IAF7B,KAC/BoB,GACuBpB,EACvB,MAAO,CACLoB,OACAmd,aAAcA,IAAMoC,GACpB3Y,GAAKwW,GACHre,cAACua,GAAW,CACVC,aAAc6D,EAAOhF,MACrBtV,MAAO,GACPyJ,OAAQ,GACR+L,SAAU8E,EAAO9E,WAIzB,CS9BIkK,CAAiB,CACfxiB,KAAM,UAER+f,GAAwC,CACtC/f,KAAM,OACNmd,aAAc,aACde,QAAS,CACP,CACEle,KAAM,aACNoY,MAAO,cAET,CACEpY,KAAM,aACNoY,MAAO,iBAIboF,GAAc,CACZxd,KAAM,cACNmd,cAAc,EACd7B,YACE,uFAGN1U,GAAIhI,IAAoE,IAAnE,MAAEoT,EAAOU,YAAa+P,EAAqB7a,EAAM0L,IAAY1U,EAChE,MAAM8jB,EAAarI,EAAUlH,YAAY,CACvCnB,MAAOyQ,EAAoBzQ,MAC3BoB,SAAUpB,EAAMjF,WAAW,GAC3BsG,UAAWrB,EAAMjF,WAAW,GAC5BuG,cAGF,OAAO+G,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KACpD,MAAMC,EAAoBF,EAAaC,EAEjC+P,EAAkBL,EAAWxV,cAAc,CAC/CC,WAAYiF,EAAMjF,WAClBC,UAGI4V,EAAuBxd,KAAKoE,MAChCqJ,EAAoB6P,EAAWrQ,OAAOhP,QAElCwf,EAAmBP,EAAWxV,cAAc,CAChDC,WAAY2V,EAAW3V,WACvBC,MAAO0V,EAAWrQ,OAAOuQ,KAG3B,OAAON,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,WAAqB,eAATpG,EAAwBib,EAAmBF,EACvD1U,WAAqB,eAATrG,EAAwB+a,EAAkBE,GACtD,GACF,IC7DOvU,GAAOkT,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,YACPpG,YAAa,kBACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,SACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,MAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa5L,IAASlI,EAAA,OAClCyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEiB,KAAMxH,OAEhD,ICpBQgc,GAAStB,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,YACPpG,YAAa,oCACbuG,mBAAmB,EACnBzE,OAAQ,CACNqC,GAAS,CACPzf,KAAM,gBACNsb,YAAa,kBACb6B,aAAenL,GACbA,EAAQ5M,KAAKoE,MAAMwI,EAAMjF,WAAW,GAAK,IAAM,GACjD7H,IAAK,IAEPgY,GAAY,CACVld,KAAM,SACNmd,aAAczG,EAAS3P,iBAG3BH,GAAIyT,EAAUtH,wBACZnU,IAA0D,IAAzD,kBAAEiU,EAAmBH,YAAanG,EAAQ7F,IAAS9H,EAClD,MAAM6J,EAAIiO,EAASjQ,YAAYC,GAAQ,EAA7BgQ,CAAmC7D,GAC7C,MAAO,CACLkQ,QAAS3d,KAAKuE,MAAM4C,EAAS9D,GAC9B,IAEHtJ,IAAA,IAAG8T,UAAU,QAAE8P,GAAW9Q,OAAQrO,EAAGsM,GAAE,YAAE4C,GAAa3T,EAAA,OACpD2T,EAAY,CAAClP,EAAGsM,EAAI6S,GAAS,M,kCC3B5B,MAAMC,GAAkBxB,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,YACPpG,YAAa,8DACbqG,qBAAsB,+CACtBE,mBAAmB,EACnBzE,OAAQ,GACRxW,GAAIhI,IAAA,IAAC,MAAEoT,GAAOpT,EAAA,MAAM,CAClBmO,WAAYiF,EAAMjF,WAClBsF,OAAQ4Q,aACNjR,EAAMK,OACN6Q,aAAKlR,EAAMK,OAAQ8Q,aAAK,GAAIC,eAAWD,aAAK,KAE/C,ICZUE,GAAS7B,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,YACPpG,YAAa,4CACbuG,mBAAmB,EACnBzE,OAAQ,CACNqC,GAAS,CACPzf,KAAM,SACNsb,YAAa,kBACb6B,aAAenL,GACbA,EAAQ5M,KAAKoE,MAAMwI,EAAMjF,WAAW,GAAK,IAAM,GACjD7H,IAAK,KAGT0B,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,EAAmBH,YAAa4Q,IAAS1kB,EAAA,MAAM,CAChD2kB,QAASne,KAAKuE,MAAM2Z,EAASle,KAAKoe,KAAK,EAAIpe,KAAKW,GAAK8M,IACrDkQ,QAAS3d,KAAKuE,MAAM2Z,EAASle,KAAKqe,KAAK,EAAIre,KAAKW,GAAK8M,IACtD,IACD1T,IAAA,IAAG8T,UAAU,QAAEsQ,EAAO,QAAER,GAAW9Q,OAAQrO,EAAGsM,GAAE,YAAE4C,GAAa3T,EAAA,OAC7D2T,EAAY,CAAClP,EAAI2f,EAASrT,EAAI6S,GAAS,MCnBhCW,GAAgBlC,GAAY,CACvCxhB,KAAM,iBACN0hB,MAAO,QACPpG,YAAa,2CACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,WACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,MAEP+X,GAAY,CACVld,KAAM,QACNmd,aAAc,CACZ,CAAC,IAAM,KACP,CAAC,IAAM,SAIbvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa5L,EAAQ6c,IAAQ/kB,EAAA,OACzCyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,IAC7C0P,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,IACV,MAAMuW,EAAWjR,GAAcC,EAAa,GACtCtE,EAAOlJ,KAAKuE,MAChB+M,EAASjQ,YAAYkd,GAAO,EAA5BjN,CAAkCkN,IAAa9c,EAAS,KAE1D,OAAOwb,EAAWlU,YAAYf,EAAY,CAAEiB,QAAO,KAGxD,IC/BCuV,GAAiBjQ,aAAM,EADF,GACyBjQ,KAAK4U,GACvDmF,EAAU/S,cACR+S,EAAU5U,aAAa,WACQ,KAA9B,EAAIyP,EAJkB,MAQduL,GAAetC,GAAY,CACtCxhB,KAAM,gBACN0hB,MAAO,SACPpG,YAAa,mDACbqG,qBACE,gLAGFvE,OAAQ,CACNmE,GAAoB,CAClBvhB,KAAM,UACN0gB,aAAc,YACdvD,aAAc0G,GACdlD,eAAgBA,IACd3C,GAAiB,CACfhe,KAAM,QACNmd,aAAc0G,GAAe,QAIrCjd,GAAIyT,EAAU5H,UAAS7T,IAAoD,IAAnD,MAAEqT,EAAK,YAAEa,EAAaJ,YAAaqR,IAAUnlB,EACnE,MAAMsa,EAAMpG,EAAYb,GACxB,GAAIyL,EAAUvU,cAAc+P,GAC1B,OAAOA,EAGT,MAAM8K,EAAO,IAAMtG,EAAUhU,qBAAqBwP,GAElD,OAAO6K,EADc3e,KAAKoE,MAAOwa,EAAO,IAAOD,EAAQ1gB,QAC3B,MCrC1BwgB,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACAlgB,IAAI+Z,EAAU5U,cAEHmb,GAASzC,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,SACPpG,YAAa,yDACbqG,qBAAsB,iDACtBE,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,sBACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,IACL8a,KAAM,IAERsB,GAAoB,CAClBvhB,KAAM,SACN0gB,aAAc,YACdvD,aAAc0G,GACdlD,eAAgBA,IACd3C,GAAiB,CACfhe,KAAM,QACNmd,aAAc0G,GAAe,QAIrCjd,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,EAAmBH,YAAawR,EAAoBD,IAASrlB,EAAA,MAAM,CACpEslB,qBACAC,YAAaF,EAAO7e,KAAKoE,MAAMqJ,EAAoBoR,EAAO5gB,SAC3D,IACDlE,IAA4E,IAAzE8T,UAAU,mBAAEiR,EAAkB,YAAEC,GAAa,MAAElS,EAAK,YAAEa,GAAa3T,EACpE,MAAMilB,EAAWtR,EAAYb,GAE7B,GAAIyL,EAAUvU,cAAcib,GAC1B,MAAO,CAAC,EAAG,EAAG,EAAG,GAGnB,MAAMC,EACJH,EAAqB,EACjBxG,EAAUzS,iBAAiBmZ,EAAUF,GACrCE,EACAJ,EAAOtG,EAAUhU,qBAAqB2a,GAE5C,MAAO,CACJL,EAAOG,EAAY,GAAM,IACzBH,EAAOG,EAAY,GAAM,IACzBH,EAAOG,EAAY,GAAM,IAC1B,IACD,MC7DDN,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACAlgB,IAAI+Z,EAAU5U,cAEHwb,GAAmB9C,GAAY,CAC1CxhB,KAAM,oBACN0hB,MAAO,SACPpG,YACE,kEACF8B,OAAQ,CACNmE,GAAoB,CAClBvhB,KAAM,SACN0gB,aAAc,YACdvD,aAAc0G,GACdlD,eAAgBA,IACd3C,GAAiB,CACfhe,KAAM,QACNmd,aAAc0G,GAAe,OAGnCvD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAauR,EAAQxV,IAAU7P,EAAA,OAC3Cyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KAC7C,MAAMC,EAAoBF,EAAaC,EACjC2R,EAAUN,EAAO7e,KAAKoE,MAAMqJ,EAAoBoR,EAAO5gB,SAEvD4K,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,WAAYqM,EAAU/H,UAAUN,EAAMjF,YAAY,IAAMwX,IACxDtW,cACA,GACF,ICxDOuW,GAAehD,GAAY,CACtCxhB,KAAM,gBACN0hB,MAAO,OACPpG,YAAa,aACbuG,mBAAmB,EACnBzE,OAAQ,CACN4B,GAAW,CAAEhf,KAAM,YAAamd,aAAc,GAAIjY,IAAK,KAEzD0B,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,EAAmBH,YAAa+R,IAAY7lB,EAAA,MAAM,CACnD2kB,QAASkB,EAAYrf,KAAKoe,KAAK,EAAIpe,KAAKW,GAAK8M,GAC9C,IACD1T,IAA4D,IAAzD8T,UAAU,QAAEsQ,GAAWtR,OAAQrO,EAAGsM,GAAE,YAAE4C,GAAa3T,EACpD,MAAMulB,EAAM9gB,EAAI,IAAM,GAAK,EAAI,EAC/B,OAAOkP,EAAY,CAAClP,EAAIwB,KAAKuE,MAAM+a,EAAMnB,GAAUrT,GAAG,MCd/CrB,GAAa2S,GAAY,CACpCxhB,KAAM,cACN0hB,MAAO,OACPpG,YAAa,yCACb8B,OAAQ,CACNqC,GAAS,CACPzf,KAAM,WACNmd,aAAc,KAEhBsC,GAAS,CACPzf,KAAM,WACNmd,aAAc,KAEhBmD,GAAY,CACVtgB,KAAM,cACNkF,IAAK,EACLC,IAAK,GACL8a,KAAM,EACN9C,aAAc,IAEhBa,GAAiB,CACfhe,KAAM,eACNmd,aAAc,CAAC,EAAG,EAAG,EAAG,MAG5BvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa3D,EAASC,EAASC,EAAYzP,IAAQZ,EAAA,OAC/Dyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCwB,WAAY,CACVE,UACAC,UACAC,aACAzP,cAIT,ICxCQmlB,GAAUnD,GAAY,CACjCxhB,KAAM,WACN0hB,MAAO,SACPpG,YACE,oEACF8B,OAAQ,CACNY,GAAiB,CACfhe,KAAM,UACNmd,aAAc,CAAC,IAAK,EAAG,EAAG,KAE5Ba,GAAiB,CACfhe,KAAM,UACNmd,aAAc,CAAC,EAAG,IAAK,EAAG,MAG9BvW,GAAIyT,EAAU5H,UACZ7T,IAA2D,IAA1D,MAAEqT,EAAK,YAAEa,EAAaJ,YAAakS,EAAQC,IAASjmB,EACnD,MAAMsa,EAAMpG,EAAYb,GACxB,GAAIyL,EAAUvU,cAAc+P,GAC1B,OAAOA,EAGT,MAAMpS,EAAS4W,EAAUhU,qBAAqBwP,GAAO,IACrD,OAAOwE,EAAU9R,oBAAoB,CAAElG,GAAIkf,EAAQjf,GAAIkf,EAAQ/d,UAAS,MCvBjEge,GAAStD,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,YACPpG,YAAa,iCACbuG,mBAAmB,EACnBzE,OAAQ,CACNqC,GAAS,CACPzf,KAAM,SACNsb,YAAa,kBACb6B,aAAenL,GACbA,EAAQ5M,KAAKoE,MAAMwI,EAAMjF,WAAW,GAAK,GAAK,GAChD7H,IAAK,IAEPgY,GAAY,CACVld,KAAM,SACNmd,aAAczG,EAAS3P,iBAG3BH,GAAIyT,EAAUtH,wBACZnU,IAAA,IACEmO,YAAajK,EAAOyJ,GAAO,kBAC3BsG,EACAH,YAAa4Q,EAAQ5c,IACtB9H,EAAA,MAAM,CACLmmB,KAAMrO,EAASjQ,YAAYC,GAAQ,EAA7BgQ,CAAmC7D,GAAqByQ,EAC9D0B,QAASliB,EAAQ,EACjBmiB,QAAS1Y,EAAS,EACnB,IACDpN,IAKO,IAJL8T,UAAU,QAAE+R,EAAO,QAAEC,EAAO,KAAEF,GAC9BhY,YAAajK,EAAOyJ,GACpB0F,OAAQrO,EAAGsM,GAAE,YACb4C,GACD3T,EAEC,MAAM+lB,GAAUthB,EAAIohB,GAAWliB,EACzBqiB,GAAUjV,EAAI+U,GAAW1Y,EAI/B,OAAOuG,EAAY,CAAClP,EAFJwB,KAAKoE,MAAMub,EAAOG,GAEDhV,EADjB9K,KAAKuE,MAAMob,EAAOI,IACY,MCvCvCC,GAAO5D,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,OACPpG,YAAa,4BACbuG,mBAAmB,EACnBzE,OAAQ,CACNF,GAAY,CACVld,KAAM,QACNmd,aAAc,CACZ,CAAC,IAAM,KACP,CAAC,IAAM,SAIbvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaiR,IAAQ/kB,EAAA,OACjCyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,IAC7C0P,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCoB,QAAS4W,GAAiB,CACxBzS,aACAD,aACAgR,eAIT,IAGC0B,GAAmBlmB,IAQV,IARW,WACxBwT,EAAU,WACVC,EAAU,MACV+Q,GAKDxkB,EACC,MAAMykB,EAAWjR,GAAcC,EAAa,GAE5C,OAAOxN,KAAKuE,MAAoD,IAA9C+M,EAASjQ,YAAYkd,GAAO,EAA5BjN,CAAkCkN,GAAgB,ECzCzDjH,GAAO6E,GAAY,CAC9BzgB,UAAU,EACV2gB,MAAO,QACP1hB,KAAM,mBACNsb,YACE,oEACF8B,OAAQ,CACNY,GAAiB,CACfhe,KAAM,4BACNmd,aAAc,CAAC,EAAG,EAAG,EAAG,OAE1BmD,GAAY,CACVtgB,KAAM,YACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAmE,IAAhEoT,MAAOsT,EAAU5S,YAAa6S,EAAgBC,IAAY5mB,EAC/D,MAAMoT,EAAQqI,EAAUxG,eAAeyR,GAEvC,IACE,IAAI3S,EAAa,EACjBA,EAAaX,EAAMK,OAAOhP,OAC1BsP,GAAc,EAEd8S,GAAU,CACRzT,QACAW,aACA4S,iBACAG,SAAUhI,EAAU5T,kBACpB0b,cAIJ,OAAOxT,CAAK,IAKVyT,GAAYtmB,IAYX,IAZY,MACjB6S,EAAK,WACLW,EAAU,eACV4S,EAAc,SACdG,EAAQ,UACRF,GAODrmB,EACC,MAAMwmB,EAAU,MACd,MAAMjQ,EAAM,IAAIkQ,IAChB,MAAO,CACLC,IAAK9lB,IAAoB,IAAlB6D,EAAGsM,GAASnQ,EACjB2V,EAAImQ,IAAI,GAAGjiB,KAAKsM,IAAI,EAEtB4V,IAAKzkB,IAAA,IAAEuC,EAAGsM,GAAS7O,EAAA,OAAKqU,EAAIoQ,IAAI,GAAGliB,KAAKsM,IAAI,EAE/C,EARe,GASV6V,EAAiB,CAAC,CAAC,EAAG/T,EAAMjF,WAAW,GAAK,IAC5CoI,EAAQlD,IACP0T,EAAQG,IAAI7T,KACf0T,EAAQE,IAAI5T,GACZ8T,EAAM5Q,KAAKlD,GACb,EAGF,KAAO8T,EAAM1iB,OAAS,GAAG,CACvB,MAAM4O,EAAQ8T,EAAMC,OACbpiB,EAAGsM,GAAK+B,EACf,GACErO,EAAI,GACJA,GAAKoO,EAAMjF,WAAW,IACtBmD,EAAI,GACJA,GAAK8B,EAAMjF,WAAW,GAGtB,SAGF,MAAMkZ,EAAY5L,EAAUtI,mBAC1BC,EAAMjF,WACNiF,EAAMK,OAAOM,GACbV,GAEmD,IAAjDyL,EAAUtS,UAAU6a,EAAWV,GAAwBC,IAI3DnL,EAAUrG,SAAS,CACjBhC,QACAW,aACAnT,MAAOkmB,EACPzT,MAAOA,IAGTkD,EAAK,CAACvR,EAAI,EAAGsM,IACbiF,EAAK,CAACvR,EAAI,EAAGsM,IACbiF,EAAK,CAACvR,EAAGsM,EAAIA,IACbiF,EAAK,CAACvR,EAAGsM,EAAI,IACf,GCxGWgW,GAAU1E,GAAY,CACjCxhB,KAAM,UACN0hB,MAAO,OACPpG,YAAa,wDACbuG,mBAAmB,EACnBzE,OAAQ,CACNqC,GAAS,CACPzf,KAAM,SACNsb,YAAa,kBACb6B,aAAenL,GACbA,EAAQ5M,KAAKoE,MAAMwI,EAAMjF,WAAW,GAAK,GAAK,GAChD7H,IAAK,KAGT0B,GAAIyT,EAAUtH,wBACZnU,IAIO,IAJN,kBACCiU,EACA9F,YAAajK,EAAOyJ,GACpBmG,YAAa4Q,IACd1kB,EAEC,MAAO,CACLmmB,MAFgBlS,EAAoB,GAEjBA,EAAoB,EAAIA,GAAqByQ,EAChE0B,QAASliB,EAAQ,EACjBmiB,QAAS1Y,EAAS,EACnB,IAEHpN,IAA2E,IAAxE8T,UAAU,KAAE8R,EAAI,QAAEC,EAAO,QAAEC,GAAWhT,OAAQrO,EAAGsM,GAAE,YAAE4C,GAAa3T,EACnE,MAAMgnB,EAAQ/gB,KAAKU,MAAMmf,EAAU/U,EAAG8U,EAAUphB,GAIhD,OAAOkP,EAAY,CAAClP,EAFJwB,KAAKuE,MAAMob,EAAO3f,KAAKqe,IAAI0C,IAEVjW,EADjB9K,KAAKuE,MAAMob,EAAO3f,KAAKoe,IAAI2C,KACG,MC/BvCC,GAAO5E,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,OACPpG,YAAa,4DACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,YACNsb,YAAa,wCACb6B,aAAc,GACdjY,IAAK,EACLC,IAZgB,GAahB8a,KAAM,IAERK,GAAY,CACVtgB,KAAM,aACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,MAGTyB,GAAIyT,EAAU5H,UACZ7T,IAAgE,IAA/D,MAAEqT,EAAK,YAAEa,EAAaJ,YAAa2T,EAAUC,IAAY1nB,EACxD,MAAMqiB,EAAInO,EAAYb,IACfrO,EAAGsM,GAAK+B,EAEf,IAAIsU,GAAW,EACf,GAAID,EAAY,KAAO,EAErBC,EAAW3iB,EAAIyiB,IAAa,GAAKnW,EAAImW,IAAa,MAC7C,CAGL,MAAMG,GAlCQ,GAmCMH,GAnCN,GAmCmC,GAAM,IAEjDI,EAAUC,IACd,MAAMzhB,EAAK,EAAIohB,GAAanW,EAAI9K,KAAKuhB,IAAIC,GAAMF,IAAiB9iB,GAChE,OAAOwB,KAAK4F,IAAI5F,KAAKuE,MAAM1E,GAAKA,GAAKuhB,CAAS,EAGhDD,EAAWE,EAAOH,IAAcG,EAAOH,EAAY,GACrD,CAEA,OAAOC,EAAWtF,EAAIvD,EAAU5S,iBAAiBmW,GAAI,IAAI,MAKzD2F,GAAS/W,GAAqBA,EAAUzK,KAAKW,GAAM,IClD5C8gB,GAAYrF,GAAY,CACnCxhB,KAAM,aACN0hB,MAAO,SACPpG,YAAa,wDACb8B,OAAQ,CACNkC,GAAe,CACbtf,KAAM,MACNmd,aAAc,MAEhBmD,GAAY,CACVtgB,KAAM,SACNsb,YAAa,4BACbpW,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN9C,aAAc,MAGlBvW,GAAIyT,EAAU5H,UACZ7T,IAAA,IAAC,MAAEqT,EAAK,YAAEa,EAAaJ,YAAaoU,EAAQhgB,IAASlI,EAAA,OACnD8e,EAAU3T,gBAAgB+I,EAAYb,GAAQ6U,EAAQhgB,EAAO,MCpBtDigB,GAAWvF,GAAY,CAClCxhB,KAAM,YACN0hB,MAAO,SACPpG,YAAa,0DACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,SACNsb,YAAa,0CACbpW,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN9C,aAAc,MAGlBvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa5L,IAASlI,EAAA,OAClCyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCsB,UAAoB,IAAT7H,OAGlB,ICxBQkgB,GAAgBxF,GAAY,CACvCxhB,KAAM,kBACN0hB,MAAO,SACPpG,YAAa,yDACbuG,mBAAmB,EACnBzE,OAAQ,CACNkC,GAAe,CACbtf,KAAM,MACNmd,aAAc,MAEhBD,GAAY,CACVld,KAAM,SACNmd,aAAc,CACZ,CAAC,IAAM,KACP,CAAC,IAAM,SAIbvW,GAAIyT,EAAU5H,UACZ7T,IAMO,IANN,MACCqT,EAAK,YACLa,EAAW,WACXF,EAAU,WACVD,EACAD,YAAa1I,EAAKtD,IACnB9H,EACC,MAAMkI,EAAS4P,EAASjQ,YACtBC,GACA,EAFagQ,CAGb/D,EAAaC,GACf,OAAO8K,EAAU3T,gBAAgB+I,EAAYb,GAAQjI,EAAc,IAATlD,EAAa,MC9BhEmgB,GAAUzF,GAAY,CACjCxhB,KAAM,WACN0hB,MAAO,SACPpG,YAAa,yDACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,YACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN3E,YAAa,8CAEfgF,GAAY,CACVtgB,KAAM,SACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,GACLmW,YAAa,6BAGjB1U,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,GAAmBjU,EAAA,MAAM,CAC1BsoB,OAAQ,EAAIrU,EAAoB,EAAIzN,KAAKW,GAC1C,IACD5G,IAMO,IALL8T,UAAU,MAAEiU,GAAO,MACnBjV,EACAlF,YAAa,CAAER,GACfmG,YAAa+R,EAAW0C,GAAO,YAC/BrU,GACD3T,EACC,MAAO,CAAE+Q,GAAK+B,EACRnL,EAAS1B,KAAKuE,MAClB8a,EAAYrf,KAAKoe,IAAKtT,EAAI3D,EAAU4a,EAAS/hB,KAAKW,GAAKmhB,IAGzD,OAAOxJ,EAAUlT,SAASsI,EAAYb,GAASnL,EAAS,IAAO,IAAI,M,wBCpCzE,MAAMsgB,GAAgC,CACpC,CAAC,EAAG,GAAI,GAAI,KACZ,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,MAGLC,GAAY7F,GAAY,CACnCxhB,KAAM,YACN0hB,MAAO,OACPpG,YAAa,+CACbuG,mBAAmB,EACnBzE,OAAQ,CACNoD,GAAU,CACRxgB,KAAM,cACNsb,YACE,mEACF6B,aAAc,eAGlBvW,GAAIhI,IAAoC,IAAnC,MAAEoT,EAAOU,YAAa4U,IAAO1oB,EAChC,MAAM2K,EAASge,KAAWD,GAC1B,OAAOjN,EAAUlI,UAAUH,GAAQzE,IACjC,MAAM1J,EAAI0F,IACJie,EAAiB3jB,EAAI,GAAM,EAAIA,EAAI,IAAO,EAAIA,EAAI,IAAO,EAAI,EAEnE,OAAOwW,EAAU/H,UAAUN,EAAMjF,YAAakF,IAC5C,MAAMiH,EAAMmB,EAAUtI,mBAAmBC,EAAMjF,WAAYQ,EAAM0E,GAEjE,GAAIyL,EAAUvU,cAAc+P,GAC1B,OAAOkO,GAAqBI,GAG9B,GAAIA,EAAiB,EAAG,CAEtB,MAAMC,EAAM,KAAOD,EACnB,MAAO,CAACtO,EAAI,GAAKuO,EAAKvO,EAAI,GAAKuO,EAAKvO,EAAI,GAAKuO,EAAKvO,EAAI,GACxD,CAGA,OAAOA,CAAG,GACV,GACF,IC5COvS,GAAS6a,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,QACPpG,YAAa,oBACb8B,OAAQ,CACN2C,GAAW,CACT/f,KAAM,YACNke,QAAS,CACP,CACEle,KAAM,aACNoY,MAAO,cAET,CACEpY,KAAM,WACNoY,MAAO,aAGX+E,aAAc,gBAGlBvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaxQ,IAAYtD,EAAA,OACrCyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlT,eAAe/B,EAAY,CACpCgC,gBAA+B,eAAdnN,GAA8B,EAAI,EACnDoN,cAA6B,aAAdpN,GAA4B,EAAI,EAC/CuN,sBACgB,eAAdvN,EAA6B8P,EAAMjF,WAAW,GAAK,EACrD2C,oBACgB,aAAdxN,EAA2B8P,EAAMjF,WAAW,GAAK,OAG1D,ICnCQ2a,GAAOlG,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,OACPpG,YAAa,WACbuG,mBAAmB,EACnBzE,OAAQ,GACRxW,GAAIyT,EAAU5H,UAAS7T,IAAgD,IAA/C,MAAEqT,EAAK,YAAEa,EAAW,kBAAED,GAAmBjU,EAC/D,MAAM4nB,EAAgC,IAApB3T,GACXtK,EAAGC,EAAGC,EAAGoB,GAAKiJ,EAAYb,IAC1BvH,EAAGlG,EAAGyF,GAAKC,MAAYC,IAAI5B,EAAGC,EAAGC,IACjC2B,EAAMC,EAAMC,GAAQJ,MAAYK,IAAI,CAACG,EAAGlG,EAAGyF,EAAIuc,EAAYvc,EAAI,IACtE,MAAO,CAACG,EAAMC,EAAMC,EAAML,EAAIuc,EAAY3c,EAAI,EAAE,MCXvC4E,GAAU+S,GAAY,CACjCxhB,KAAM,UACN0hB,MAAO,QACPpG,YAAa,gCACbqG,qBACE,wJAGFvE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,SACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa5L,IAASlI,EAAA,OAClCyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,QAAS3H,OAEnD,ICxBQ6gB,GAAQnG,GAAY,CAC/BxhB,KAAM,QACN0hB,MAAO,QACPpG,YAAa,8DACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,4DACbpW,IAAK,EACLC,IAAK,GACLgY,aAAc,KAGlBvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAakV,IAAQhpB,EAAA,OACjCyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,IAC7C0P,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCsB,UAAYgE,EAAaC,EAAc,IAAMgV,OAGpD,ICxBQC,GAAkBrG,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,QACPpG,YACE,6EACFuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,4DACbpW,IAAK,EACLC,IAAK,GACLgY,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaoV,EAAYrZ,IAAU7P,EAAA,OAC/Cyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KAC7C,MACMmV,EADoBpV,EAAaC,EACLkV,EAAa,IAAO,IAChDvD,EAAU7G,EAAU7S,aAAakd,GAEjC9Z,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,WAAYqM,EAAU/H,UAAUN,EAAMjF,YAAY,IAAMwX,IACxDtW,cACA,GACF,IC3CO+Z,GAAcxG,GAAY,CACrCxhB,KAAM,eACN0hB,MAAO,QACPpG,YACE,0EACFuG,mBAAmB,EACnBzE,OAAQ,GACRxW,GAAIyT,EAAU5H,UAAS7T,IAAA,IAAC,MAAEqT,EAAK,YAAEa,EAAW,kBAAED,GAAmBjU,EAAA,OAC/D8e,EAAUlT,SAASsI,EAAYb,GAA4B,IAApBY,EAAwB,MCNtDoV,GAAczG,GAAY,CACrCxhB,KAAM,eACN0hB,MAAO,QACPpG,YAAa,8BACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,SACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPmb,GAAY,CACVtgB,KAAM,cACNkF,IAAK,EACLC,IAAK,GACL8a,KAAM,EACN9C,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNmd,aAAc,KAEhBsC,GAAS,CACPzf,KAAM,WACNmd,aAAc,MAGlBvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAawV,EAAQjZ,EAAYF,EAASC,IAAUpQ,EAAA,OAChEyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KAC7C,MACMqR,EAAkB,GAClBkE,EAA+B,KAFXxV,EAAaC,GAGjCwV,EAAU,IAAMF,EACtB,IAAK,IAAIrkB,EAAI,EAAGA,EAAIqkB,EAAQrkB,GAAK,EAC/BogB,EAAO9O,KAAKuI,EAAU7S,cAAcsd,EAAWC,EAAUvkB,GAAK,MAGhE,OAAOwkB,GAAa,CAClBrb,QACAiX,SACAhV,aACAlC,WAAYiF,EAAMjF,WAClBgC,UACAC,WACA,GACF,IAGAqZ,GAAelpB,IAcH,IAdI,MACpB6N,EAAK,WACLD,EAAU,OACVkX,EAAM,QACNlV,EAAO,QACPC,EAAO,WACPC,GAQD9P,EACC,MAAOK,KAAU8oB,GAAQrE,EACnBsE,EAAWjG,EAAW5U,qBAAqB,CAC/CX,aACAC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CACjCwB,WAAY,CACVE,UACAC,UACAC,aACAzP,aAKR,OAAoB,IAAhB8oB,EAAKjlB,OACAklB,EAGAF,GAAa,CAClBrb,MAAOub,EACPtE,OAAQqE,EACRvb,aACAkC,aACAF,UACAC,WAEJ,ECtFI6U,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACAlgB,IAAI+Z,EAAU5U,cAEH0f,GAAiBhH,GAAY,CACxCxhB,KAAM,kBACN0hB,MAAO,QACPpG,YAAa,0DACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,wCACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPoc,GAAoB,CAClBvhB,KAAM,SACN0gB,aAAc,YACdpF,YAAa,0BACb6B,aAAc0G,GACdlD,eAAgBA,IACd3C,GAAiB,CACfhe,KAAM,QACNmd,aAAc0G,GAAe,OAGnCpE,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAGG,IAHF,MACHoT,EACAU,YAAa+V,EAAYxE,EAAQlV,EAASC,EAASP,IACpD7P,EACC,MAAOkE,EAAOyJ,GAAUyF,EAAMjF,WAExB2b,EAAczE,EAAO5gB,OAASolB,EAC9BE,EAAmBvjB,KAAKuE,MAAM,IAAM+e,GAI1C,IAAIE,EAAe3E,EAAO5gB,OAC1B,KAA6D,QAArDqlB,EAAcE,GAAcC,QAAQ,GAAGvkB,OAAO,IACpDskB,GAAgB,EAGlB,MAAME,EAAgB,CAAChmB,EAAQ,EAAIiM,EAASxC,EAAS,EAAIyC,GAEzD,OAAOqL,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KACpD,MAAMC,EAAoBF,EAAaC,EAEjC5E,EAAaqM,EAAU/H,UAAUN,EAAMjF,YAAakF,IACxD,MAAM8W,EAAarS,EAASjR,eAAewM,EAAO6W,GAE5CE,EACJ5jB,KAAKoE,MAAMuf,EAAaJ,GAAoBC,EAGxC3kB,GACHmB,KAAKoE,MAAMqJ,EAAoB+V,GAAgBI,GAChDJ,EACF,OAAO3E,EAAOhgB,EAAI,IAGdgK,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,aACAC,cACA,GACF,IC1GOgb,GAAkBzH,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,QACPpG,YAAa,8CACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,0CACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPmb,GAAY,CACVtgB,KAAM,WACNkF,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN9C,aAAc,KAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,KAGlBvW,GAAIyT,EAAUtH,wBACZnU,IAGO,IAFLmO,YAAajK,EAAOyJ,GACpBmG,YAAa+V,EAAY3hB,EAAQiI,EAASC,IAC3CpQ,EAEC,MAAO,CAAEkqB,OADa,CAAChmB,EAAQ,EAAIiM,EAASxC,EAAS,EAAIyC,GACxC,IAEnB7P,IAMO,IALL8T,UAAU,OAAE6V,GAAQ,MACpB7W,EAAK,kBACLY,EAAiB,YACjBC,EACAJ,YAAa+V,EAAYS,IAC1B/pB,EACC,MAAMilB,EAAWtR,EAAYb,GAGvB8V,GADarR,EAASjR,eAAewM,EAAO6W,GACvBL,EAAiC,IAApB5V,GAA2B,IAEnE,OAAO6K,EAAU3T,gBAAgBqa,EAAU2D,EAAMmB,EAAS,MCnDnDC,GAA4B3H,GAAY,CACnDxhB,KAAM,8BACN0hB,MAAO,QACPpG,YAAa,iDACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,0CACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPsa,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa+V,EAAY1Z,EAASC,EAASP,IAAU7P,EAAA,OACjEyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KAC7C,MAAMC,EAAoBF,EAAaC,GAChC9P,EAAOyJ,GAAUyF,EAAMjF,WACxB+b,EAAgB,CAAChmB,EAAQ,EAAIiM,EAASxC,EAAS,EAAIyC,GAEnDhB,EAAaqM,EAAU/H,UAAUN,EAAMjF,YAAakF,IACxD,MACM8V,GADarR,EAASjR,eAAewM,EAAO6W,GACvBL,EAAiC,IAApB5V,GAA2B,IACnE,OAAO6K,EAAU7S,aAAakd,EAAK,IAG/B9Z,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,aACAC,cACA,GACF,ICpDA4V,GAAiB,CACrB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACAlgB,IAAI+Z,EAAU5U,cAEHsgB,GAAiB5H,GAAY,CACxCxhB,KAAM,kBACN0hB,MAAO,QACPpG,YAAa,0DACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,wCACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPoc,GAAoB,CAClBvhB,KAAM,SACN0gB,aAAc,YACdpF,YAAa,oCACb6B,aAAc0G,GACdlD,eAAgBA,IACd3C,GAAiB,CACfhe,KAAM,QACNmd,aAAc0G,GAAe,OAGnCpE,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAGG,IAHF,MACHoT,EACAU,YAAa+V,EAAYxE,EAAQlV,EAASC,EAASP,IACpD7P,EACC,OAAOyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KACpD,MAAMC,EAAoBF,EAAaC,GAChC9P,EAAOyJ,GAAUyF,EAAMjF,WAExBsc,EAAYzV,aAAM,EAAG6U,GAAYa,SAAQ,IAAMrF,IAC/Ce,EAAUliB,EAAQ,EAClBmiB,EAAU1Y,EAAS,EAEnByB,EAAaqM,EAAU/H,UAAUN,EAAMjF,YAAY5N,IAAa,IAAXyE,EAAGsM,GAAE/Q,EAC9D,MAAMyG,EAAahC,EAAIohB,EAAUjW,EAC3BlJ,EAAaqK,EAAI+U,EAAUjW,EAE3Bua,EAAUnkB,KAAKoB,KAClB1D,EAAQ,GAAMA,EAAQ,GAAMyJ,EAAS,GAAMA,EAAS,IAEjDid,EAAiBpkB,KAAKoB,KAC1BX,EAAaA,EAAaD,EAAaA,GAGnCojB,EACJ5jB,KAAKoE,OAAO,EAAIggB,EAAiBD,GAAWF,EAAUhmB,QACtDgmB,EAAUhmB,OAGNY,GACHmB,KAAKoE,MAAMqJ,EAAoBwW,EAAUhmB,QAAU2lB,GACpDK,EAAUhmB,OACZ,OAAOgmB,EAAUplB,EAAI,IAGjBgK,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,aACAC,cACA,GACF,IC3GOwb,GAAkBjI,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,QACPpG,YAAa,sCACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,0CACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPmb,GAAY,CACVtgB,KAAM,WACNkF,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN9C,aAAc,KAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,KAGlBvW,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAGmO,YAAajK,EAAOyJ,IAAS3N,EAAA,MAAM,CACpComB,QAASliB,EAAQ,EACjBmiB,QAAS1Y,EAAS,EAClBgd,QAASnkB,KAAKoB,KACX1D,EAAQ,GAAMA,EAAQ,GAAMyJ,EAAS,GAAMA,EAAS,IAExD,IACDpN,IAMO,IALL8T,UAAU,QAAE+R,EAAO,QAAEC,EAAO,QAAEsE,GAAS,MACvCtX,EAAK,kBACLY,EACAH,YAAa+V,EAAYS,EAAUna,EAASC,GAAQ,YACpD8D,GACD3T,EACC,MAAM+Z,EAAMpG,EAAYb,IAEjBrO,EAAGsM,GAAK+B,EACTrM,EAAahC,EAAIohB,EAAUjW,EAC3BlJ,EAAaqK,EAAI+U,EAAUjW,EAM3B+Y,GAC8B,KAAhC,EALmB3iB,KAAKoB,KAC1BX,EAAaA,EAAaD,EAAaA,GAIhB2jB,GAAiBd,EACtC,IAAM5V,GACR,IAEF,OAAO6K,EAAU3T,gBAAgBmP,EAAK6O,EAAMmB,EAAS,MC7D9CQ,GAA4BlI,GAAY,CACnDxhB,KAAM,8BACN0hB,MAAO,QACPpG,YAAa,sCACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,cACNsb,YAAa,0CACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,KAEPsa,GAAS,CACPzf,KAAM,WACNsb,YAAa,+CACb6B,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,WACNsb,YAAa,6CACb6B,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,qBACNmd,aAAc,IACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa+V,EAAY1Z,EAASC,EAASP,IAAU7P,EAAA,OACjEyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO2F,EAAYC,KAC7C,MAAMC,EAAoBF,EAAaC,GAChC9P,EAAOyJ,GAAUyF,EAAMjF,WACxBiY,EAAUliB,EAAQ,EAClBmiB,EAAU1Y,EAAS,EACnBgd,EAAUnkB,KAAKoB,KAClB1D,EAAQ,GAAMA,EAAQ,GAAMyJ,EAAS,GAAMA,EAAS,IAGjDyB,EAAaqM,EAAU/H,UAAUN,EAAMjF,YAAY5N,IAAa,IAAXyE,EAAGsM,GAAE/Q,EAC9D,MAAMyG,EAAahC,EAAIohB,EAAUjW,EAC3BlJ,EAAaqK,EAAI+U,EAAUjW,EAM3B+Y,GAC8B,KAAhC,EALmB3iB,KAAKoB,KAC1BX,EAAaA,EAAaD,EAAaA,GAIhB2jB,GAAiBd,EACtC,IAAM5V,GACR,IAEF,OAAO6K,EAAU7S,aAAakd,EAAK,IAG/B9Z,EACQ,MAAZQ,EACIzB,EACAsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GACViV,EAAWlU,YAAYf,EAAY,CAAEoB,cAG/C,OAAO6T,EAAWvU,cAAc,CAC9BhB,WAAYiF,EAAMjF,WAClBiB,aACAC,cACA,GACF,I,cCrEC,MAAM0b,GAAqBnI,GAAY,CAC5CxhB,KAAM,uBACN0hB,MAAO,SACPpG,YACE,0EACFqG,qBACE,uEACFvE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,oBACNsb,YACE,kFACF6B,aAAc,GACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIyT,EAAUtH,wBACZnU,IAAgD,IAA/C,MAAEoT,EAAOU,YAAakX,IAAmBhrB,EAGxC,MAAMirB,EAAe,IAAIjE,IACzBvL,EAAUlI,UAAUH,GAAQhF,GAC1BqN,EAAU/H,UAAUN,EAAMjF,YAAakF,IACrC,MAAMmC,EAAKiG,EAAUtI,mBACnBC,EAAMjF,WACNC,EACAiF,GAGF,OADA4X,EAAahE,IAAInI,EAAUpV,WAAW8L,IAC/BsJ,EAAU5T,iBAAiB,MAItC,MAAMggB,EAAYlP,MAAMxD,KAAKyS,GAAclmB,IAAI+Z,EAAU5U,cACnDihB,EAAY3kB,KAAKD,IACrBC,KAAKoE,MAAOsgB,EAAUzmB,QAAU,IAAMumB,GAAqB,KAC3D,GAQII,EACJF,EAAUnmB,KAAKgF,IAAC,CACdnJ,MAAOmJ,EACPshB,iBAAkB,MAGtB,IAAK,IAAIpmB,EAAI,EAAGA,EAAIimB,EAAUzmB,OAAQQ,GAAK,EAAG,CAC5C,IAAIqmB,EAAkB,EAClBC,EAAmBzM,EAAUtS,UAC/B0e,EAAUjmB,GACVimB,EAAUI,IAGZ,IAAK,IAAIE,EAAI,EAAGA,EAAIN,EAAUzmB,OAAQ+mB,GAAK,EAAG,CAC5C,GAAIA,IAAMvmB,EAER,SAEF,MAAMkhB,EAAOrH,EAAUtS,UAAU0e,EAAUM,GAAIN,EAAUjmB,IACrDkhB,EAAOoF,IACTD,EAAkBE,EAClBD,EAAmBpF,EAEvB,CACAiF,EAASE,GAAiBD,kBAAoB,CAChD,CAMA,MAAO,CAAEnG,aAJYuG,aAAOL,EAAU,CAAErhB,GAAMA,EAAEshB,iBAAkB,SAC/D3lB,MAAM,EAAGylB,GACTpmB,KAAIxE,IAAA,IAAC,MAAEK,GAAOL,EAAA,OAAKK,CAAK,IAEJ,IAEzBO,IAAyD,IAAxD,MAAEkS,EAAK,YAAEa,EAAaG,UAAU,aAAE6Q,IAAgB/jB,EACjD,MAAMqU,EAAKtB,EAAYb,GAKvB,OAHqBqY,aAAMxG,GAAenS,GACxC+L,EAAUtS,UAAUuG,EAAKyC,IAER,MCtFZmW,GAAkB/I,GAAY,CACzCxhB,KAAM,mBACN0hB,MAAO,YACPpG,YAAa,qDACbqG,qBAAsB,iDACtBE,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,oBACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,MAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa8X,IAAa5rB,EAAA,MAAM,CAC5CmO,WAAYiF,EAAMjF,WAClBsF,OAAQuB,aAAM,EAAG5B,EAAMK,OAAOhP,QAAUmnB,EAAa,IAAI7mB,KACtDE,GAAMmO,EAAMK,OAAOxO,EAAImO,EAAMK,OAAOhP,UAExC,ICnBU8P,GAAcqO,GAAY,CACrCxhB,KAAM,eACN0hB,MAAO,QACPpG,YAAa,+CACb8B,OAAQ,CACNqC,GAAS,CACPzf,KAAM,QACNsb,YACE,wEACF6B,aAAenL,GAAWA,EAAQA,EAAMjF,WAAW,GAAK,EACxD7H,IAAK,IAEPua,GAAS,CACPzf,KAAM,SACNsb,YACE,uEACF6B,aAAenL,GAAWA,EAAQA,EAAMjF,WAAW,GAAK,EACxD7H,IAAK,IAEPsY,GAAc,CACZxd,KAAM,aACNsb,YACE,oEACF6B,cAAc,KAGlBvW,GAAIhI,IAAwE,IAAvE,MAAEoT,EAAOU,YAAaqP,EAAeC,EAAgB1O,IAAY1U,EACpE,MAAOqjB,EAAUC,GAAalQ,EAAMjF,WAC9BqG,EACc,IAAlB2O,EACI3c,KAAK4Q,KAAMiM,EAAWC,EAAaF,GACnCD,EACA1O,EACe,IAAnB2O,EACI5c,KAAK4Q,KAAMkM,EAAYD,EAAYF,GACnCC,EACN,OAAO3H,EAAUlH,YAAY,CAC3BnB,QACAoB,WACAC,YACAC,aACA,IC1COmX,GAAmBjJ,GAAY,CAC1CxhB,KAAM,oBACN0hB,MAAO,YACPpG,YAAa,yBACbuG,mBAAmB,EACnBzE,OAAQ,GACRxW,GAAIhI,IAAA,IAAC,MAAEoT,GAAOpT,EAAA,MAAM,CAClBmO,WAAYiF,EAAMjF,WAClBsF,OAAQ+Q,aAAQpR,EAAMK,QACvB,ICRUqY,GAASlJ,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,OACPpG,YAAa,qCACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,YACNmd,aAAc,GACdjY,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN3E,YAAa,2CAEfgF,GAAY,CACVtgB,KAAM,SACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,GACLmW,YAAa,+BAGjB1U,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,GAAmBjU,EAAA,MAAM,CAC1BsoB,MAA2B,EAApBrU,EAAwBzN,KAAKW,GACrC,IACD5G,IAMO,IALL8T,UAAU,MAAEiU,GACZjV,OAAQrO,EAAGsM,GACXnD,YAAa,CAAER,GACfmG,YAAa+R,EAAW0C,GAAO,YAC/BrU,GACD3T,EAKC,OAAO2T,EAAY,CAAClP,EAJLwB,KAAKuE,MAClB8a,EAAYrf,KAAKoe,IAAKtT,EAAI3D,EAAU4a,EAAS/hB,KAAKW,GAAKmhB,IAGzBhX,GAAG,MCrC5BH,GAASyR,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,YACPpG,YAAa,qCACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,QACNmd,aAAc,EACdjY,IAAK,EACLC,IAAK,IACL8a,KAAM,EACN3E,YACE,gFAGN1U,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAayT,IAAQvnB,EAAA,OACjCyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GAAeiV,EAAW1S,cAAcvC,EAAY8Y,MAEnE,ICtBQwE,GAAUnJ,GAAY,CACjCxhB,KAAM,UACN0hB,MAAO,OACPpG,YAAa,sBACbuG,mBAAmB,EACnBzE,OAAQ,GACRxW,GAAIyT,EAAUtH,wBACZnU,IAAyD,IAAtDmO,YAAajK,EAAOyJ,GAAO,kBAAEsG,GAAmBjU,EAMjD,MAAMgsB,EAAQxlB,KAAKoE,MAA0B,EAApBqJ,GACnBgY,EAA6C,GAAjChY,EAAoB+X,EAAQ,GAExCE,EAAY1lB,KAAKW,GAAK,EAAK,GAE3BogB,EACM,IAAVyE,EACI,EACU,IAAVA,EACAC,EAAWC,EACD,IAAVF,EACAE,GACC,EAAID,GAAYC,EAEvB,MAAO,CACL3E,QACA1C,IAAKre,KAAKqe,IAAa,MAAR0C,GACf3C,IAAKpe,KAAKoe,IAAa,MAAR2C,GACf4E,aAAsB,IAARjoB,EACdkoB,aAAuB,GAATze,EACf,IAEHpN,IAIO,IAHL8T,UAAU,MAAEkT,EAAK,IAAE1C,EAAG,IAAED,EAAG,aAAEuH,EAAY,aAAEC,GAC3C/Y,OAAQrO,EAAGsM,GAAE,YACb4C,GACD3T,EACC,MAAMyG,EAAaR,KAAKoE,MAAM5F,EAAImnB,EAAe,EAAI3lB,KAAKoe,IAAI2C,IACxDtgB,EAAaT,KAAKoE,MAAM0G,EAAI8a,EAAe,EAAI5lB,KAAKqe,IAAI0C,IAO9D,OAAOrT,EALiB,CACtB1N,KAAKuE,MAAMohB,EAAenlB,EAAa6d,EAAM5d,EAAa2d,GAC1Dpe,KAAKuE,MAAMqhB,EAAenlB,EAAa4d,EAAM7d,EAAa4d,IAGhC,MChDrBtQ,GAAasO,GAAY,CACpCxhB,KAAM,cACN0hB,MAAO,QACPpG,YAAa,kDACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,QACNkF,IAAK,GACLC,IAAK,EACL8a,KAAM,GACN9C,aAAc,KAGlBvW,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAavC,IAAQvR,EAAA,OACjCyb,EAAUnH,WAAW,CACnBlB,QACA3C,gBAAiBc,EACjBb,cAAea,GACf,IClBO8a,GAAqBzJ,GAAY,CAC5CxhB,KAAM,uBACN0hB,MAAO,YACPE,WAAY,IACZtG,YAAa,oCACb8B,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,mBACNsb,YAAa,kDACb6B,aAAenL,GACNA,EAAQA,EAAMK,OAAOhP,OAAS,EAEvC6B,IAAK,EACLC,IAAK,MAGTyB,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaE,IAAahU,EAAA,OACtCyb,EAAUpG,iBAAiBjC,EAAOY,EAAW,ICjBpCsY,GAAQ1J,GAAY,CAC/BxhB,KAAM,QACN0hB,MAAO,OACPpG,YAAa,sCACbuG,mBAAmB,EACnBzE,OAAQ,CACN4B,GAAW,CACThf,KAAM,YACNmd,aAAenL,GACbA,EAAQ5M,KAAKoE,MAAMwI,EAAMjF,WAAW,GAAK,IAAM,GACjD7H,IAAK,KAGT0B,GAAIyT,EAAUtH,wBACZnU,IAAA,IAAC,kBAAEiU,EAAmBH,YAAa+R,IAAY7lB,EAAA,MAAM,CACnD2kB,QAASne,KAAKuE,MACZ8a,EAAYrf,KAAKqe,IAAwB,EAApB5Q,EAAwBzN,KAAKW,KAErD,IACD5G,IAAA,IAAG8T,UAAU,QAAEsQ,GAAWtR,OAAQrO,EAAGsM,GAAE,YAAE4C,GAAa3T,EAAA,OACpD2T,EAAY,CAAClP,EAAI2f,EAASrT,GAAG,MCnBtBib,GAAgB3J,GAAY,CACvCxhB,KAAM,iBACN0hB,MAAO,YACPpG,YAAa,+DACbqG,qBAAsB,4CACtBE,mBAAmB,EACnBzE,OAAQ,CACN2C,GAA+B,CAC7B/f,KAAM,qBACNke,QAAS,CACP,CAAEle,KAAM,QAASoY,MAAO,SACxB,CAAEpY,KAAM,SAAUoY,MAAO,WAE3B+E,aAAc,QACd7B,YACE,yJAIN1U,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAa9K,IAAOhJ,EAAA,MAAM,CACtCmO,WAAYiF,EAAMjF,WAClBsF,OAAQuB,aAAM,EAAyB,EAAtB5B,EAAMK,OAAOhP,OAAa,GAAGM,KAAKE,IAKjD,GAAIA,EAAI,IAAM,EACZ,OAAOmO,EAAMK,OAAOxO,EAAI,GAG1B,MAAMunB,GAAcvnB,EAAI,GAAK,EAE7B,MAAa,UAAT+D,EAEKoK,EAAMK,OAAO+Y,GAIf/Q,EAAU/H,UAAUN,EAAMjF,YAAakF,IAC5C,MAAOnG,EAAIC,EAAIC,EAAIqf,GAAMhR,EAAUtI,mBACjCC,EAAMjF,WACNiF,EAAMK,OAAO+Y,GACbnZ,IAEKhG,EAAIC,EAAIC,EAAImf,GAAMjR,EAAUtI,mBACjCC,EAAMjF,WACNiF,EAAMK,OAAO+Y,EAAa,GAC1BnZ,GAEF,MAAO,EAAEnG,EAAKG,GAAM,GAAIF,EAAKG,GAAM,GAAIF,EAAKG,GAAM,GAAIkf,EAAKC,GAAM,EAAE,GACnE,IAEL,ICrDUC,GAAO/J,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,YACPpG,YAAa,+DACbuG,mBAAmB,EACnBzE,OAAQ,CACN2C,GAAoC,CAClC/f,KAAM,YACNmd,aAAc,YACde,QAAS,CACP,CAAEle,KAAM,YAAaoY,MAAO,aAC5B,CAAEpY,KAAM,oBAAqBoY,MAAO,eAI1CxR,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaxQ,IAAYtD,EAAA,OACrCyb,EAAUlI,UAAUH,GAAO,CAAChF,EAAO/I,EAAK2O,KACtC,MAAMuT,GACa,YAAdjkB,EAA0B,GAAK,GAAK+B,EAAO2O,EAAc,IAC9D,OAAO0P,EAAW5U,qBAAqB,CACrCX,WAAYiF,EAAMjF,WAClBC,QACAW,UAAYN,GAAeiV,EAAW1S,cAAcvC,EAAY8Y,IAChE,GACF,ICxBOqF,GAAUhK,GAAY,CACjCxhB,KAAM,SACN0hB,MAAO,OACPpG,YAAa,6CACb8B,OAAQ,CACN2C,GAAwC,CACtC/f,KAAM,OACNsb,YAAa,6DACb6B,aAAc,aACde,QAAS,CACP,CACEle,KAAM,aACNoY,MAAO,cAET,CACEpY,KAAM,aACNoY,MAAO,iBAIbkI,GAAY,CACVtgB,KAAM,WACNsb,YAAa,sDACb6B,aAAc,GACdjY,IAAK,EACLC,IAAK,IACL8a,KAAM,KAGVrZ,GAAIyT,EAAU5H,UACZ7T,IAAmE,IAAlE,MAAEqT,EAAK,YAAEa,EAAaJ,YAAa9K,EAAMshB,GAAS,OAAE3f,GAAQ3K,EAC3D,MAAMsa,EAAMpG,EAAYb,GAElBwZ,EAAe/N,EAAUvU,cAAc+P,GAE7C,GAAa,eAATtR,EAAwB6jB,GAAgBA,EAC1C,OAAOvS,EAGT,GAAIuS,GAAyB,eAAT7jB,EAAuB,CACzC,MAAM8jB,EAAUtmB,KAAK4Q,KAAgB,IAAXzM,KAAkB2f,EACtCyC,EAAOvmB,KAAK4Q,KAAgB,IAAXzM,KAEvB,OAAOmiB,EAAU,CAACC,EAAMA,EAAMA,EAAM,KAAOzS,CAC7C,CAEA,MAAM0S,EAAWxmB,KAAK4Q,KAAgB,IAAXzM,KAAkB2f,EACvCyC,EAAOvmB,KAAK4Q,KAAgB,IAAXzM,KAEvB,OAAOqiB,EAAW,CAACD,EAAMA,EAAMA,EAAMzS,EAAI,IAAMA,CAAG,MCjDlD2S,GAAQ,CACZ,QACA,UACA,SACA,eACA,kBACA,UACA,WACA,cACA,mBAGW/R,GAAO0H,GAAY,CAC9BxhB,KAAM,OACN0hB,MAAO,QACPpG,YAAa,yBACb8B,OAAQ,CACNoD,GAAU,CACRxgB,KAAM,OACNsb,YAAa,+BACb6B,aAAc,M5DkB4BxJ,G4DhB9B,CACZ3T,KAAM,OACNmd,aAAc0O,GAAM,GACpB3N,QAAS2N,GAAMloB,KAAKmoB,IAAI,CAAQ9rB,KAAM8rB,EAAM1T,MAAO0T,O5DmBhD,CACL9rB,KAAM2T,GAAK3T,KACXmd,aAAc5B,GAAgB5H,GAAKwJ,cACnCvW,GAAKwW,GAEDre,cAACkf,GAAa,CACZje,KAAM2T,GAAK3T,KACXoY,MAAOgF,EAAOhF,MACd8F,QAASvK,GAAKuK,QACd5C,YAAa3H,GAAK2H,YAClBhD,SAAU8E,EAAO9E,a4D3BvBmH,GAAS,CACPzf,KAAM,IACNmd,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,IACNmd,aAAc,IAEhBsC,GAAS,CACPzf,KAAM,OACNmd,aAAc,GACdjY,IAAK,IAEP8Y,GAAiB,CACfhe,KAAM,QACNmd,aAAcO,EAAU5U,aAAa,cAGzClC,GAAIhI,IAAA,IAAC,MAAEoT,EAAOU,YAAaoH,EAAMgS,EAAMloB,EAAGsM,EAAGxQ,EAAUF,IAAQZ,EAAA,OAC7Dyb,EAAUlI,UAAUH,GAAQhF,GAC1BsV,EAAW5U,qBAAqB,CAC9BX,WAAYiF,EAAMjF,WAClBC,QACAY,WAAYzO,IAAc,IAAb,IAAEuN,GAAKvN,EAClBuN,EAAIof,KAAO,GAAGpsB,OAAcosB,IAC5Bpf,EAAI8P,UAAYkB,EAAUpV,WAAW9I,GACrCkN,EAAIqf,SAASjS,EAAMlW,EAAGsM,EAAE,KAG7B,I5DlBE,IAAyCyD,G6DrCzC,MAAMqY,GAASxK,GAAY,CAChCxhB,KAAM,SACN0hB,MAAO,OACPpG,YAAa,4CACbuG,mBAAmB,EACnBzE,OAAQ,CACNkD,GAAY,CACVtgB,KAAM,mBACNsb,YAAa,mCACbpW,IAAK,EACLC,IAAK,GACLgY,aAAc,IAEhBmD,GAAY,CACVtgB,KAAM,gBACNsb,YAAa,yCACbpW,IAAK,EACLC,IAAK,IACLgY,aAAc,KAEhBmD,GAAY,CACVtgB,KAAM,aACNsb,YAAa,uDACb6B,aAAc,EACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIhI,IAA6D,IAA5D,MAAEoT,EAAOU,YAAauZ,EAAWC,EAAc5d,IAAO1P,EACzD,MAAMutB,EACH/mB,KAAKD,IAAI6M,EAAMjF,WAAW,GAAIiF,EAAMjF,WAAW,IAAM,IAASuB,EAY3D+D,EAAsB,GAC5B,IAAK,IAAIxO,EAAI,EAAGA,EAAImO,EAAMK,OAAOhP,OAAQQ,GAAK,EAAG,CAC/C,MAAM2I,EAAS8V,EAAWhW,aAAa0F,EAAMjF,YAC7C,IAAK,IAAI9H,EAAIgnB,EAAWhnB,EAAI,EAAGA,GAAK,EAAG,CACrC,MAAMhB,EAAMJ,EAAIoB,EAAI,EACdmnB,EAAWnoB,GAAO,EAAIA,EAAM+N,EAAMK,OAAOhP,OAASY,EAElDkQ,EAAcnC,EAAMK,OAAO+Z,GACd,MAAfjY,IACFmO,EAAWlU,YAAY5B,EAAQ,CAC7BiC,QAASrJ,KAAKoE,MAAOvE,EAAIgnB,EAAaC,GACtC5d,KAAMlJ,KAAKoE,MAAMvE,EAAIknB,KAEvB7J,EAAW9U,kBAAkB,CAC3Bd,IAAKF,EAAOE,IACZK,WAAYiF,EAAMjF,WAClBC,MAAOmH,IAGb,CACAmO,EAAWlU,YAAY5B,EAAQ,CAC7BiC,QAAS,IACTH,KAAM,IAERgU,EAAW9U,kBAAkB,CAC3Bd,IAAKF,EAAOE,IACZK,WAAYiF,EAAMjF,WAClBC,MAAOgF,EAAMK,OAAOxO,KAEtBwO,EAAO8C,KAAKmN,EAAWlV,cAAcZ,GACvC,CAEA,MAAO,CACLO,WAAYiF,EAAMjF,WAClBsF,SACD,IC9EQga,GAAe7K,GAAY,CACtCxhB,KAAM,eACN0hB,MAAO,QACPpG,YAAa,uCACb8B,OAAQ,CACNI,GAAc,CACZxd,KAAM,0BACNsb,YACE,6HACF6B,cAAc,IAEhBa,GAAiB,CACfhe,KAAM,QACNmd,aAAcO,EAAU5U,aAAa,aAEvCwX,GAAY,CACVtgB,KAAM,YACNsb,YACE,uGACF6B,aAAc,GACdjY,IAAK,EACLC,IAAK,OAGTyB,GAAIyT,EAAU5H,UACZ7T,IAIO,IAJN,MACCqT,EAAK,YACLa,EACAJ,YAAa4Z,EAAoBC,EAAe/G,IACjD5mB,EACC,MAAMsa,EAAMpG,EAAYb,GAElBua,EACsC,IAA1C9O,EAAUtS,UAAU8N,EAAKqT,IAAwB/G,EAEnD,OAAI8G,EAAqBE,GAAmBA,GACnC,CAACtT,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAI,GAE3BA,CAAG,MCtCHuT,GAAYjL,GAAY,CACnCxhB,KAAM,YACN0hB,MAAO,QACPpG,YAAa,2CACb8B,OAAQ,CACNqC,GAAS,CAAEzf,KAAM,IAAKmd,aAAc,IACpCsC,GAAS,CAAEzf,KAAM,IAAKmd,aAAc,KAEtCvW,GAAIyT,EAAU5H,UACZ7T,IAAA,IAAGqT,OAAQrO,EAAGsM,GAAE,YAAE4C,EAAaJ,YAAaga,EAAQC,IAAS/tB,EAAA,OAC3DkU,EAAY,CAAClP,EAAI8oB,EAAQxc,EAAIyc,GAAQ,MC8CrCC,GAAgC,CACpC,YACA,QACA,QACA,YACA,SACA,QAGWC,GAAmB3J,aAC9B,CACE+H,GACAnJ,GACAviB,GACAgjB,GACAjU,GACAwU,GACAE,GACAK,GACAK,GACAI,GACAG,GACAK,GACAE,GACA3V,GACA8V,GACAG,GACAM,GACAzI,GACAuJ,GACAE,GACAS,GACAE,GACAC,GACAC,GACAI,GACA1gB,GACA+gB,GACAjZ,GACAkZ,GACAE,GACAG,GACAC,GACAO,GACAS,GACAE,GACAC,GACAK,GACAC,GACAC,GACAY,GACApX,GACAsX,GACAC,GACA3a,GACA4a,GACAzX,GACAgY,GACAC,GACAI,GACAC,GACA1R,GACAkS,GACAK,GACAI,IAIFpC,cACGzmB,GAAMgpB,GAAeE,QAAQlpB,EAAE8d,SAC/B9d,IAAC,IAAAmpB,EAAA,OAAM,GAAiB,QAAhBA,EAAInpB,EAAEge,kBAAU,IAAAmL,IAAI,EAAE,IAC9BnpB,GAAMA,EAAE5D,OAEXgtB,cAAQppB,GAAMA,EAAE7C,YAGLksB,GACXjtB,IAEA,MAAMse,EAAIuO,GAAiBK,MAAM5O,GAAMA,EAAEte,OAASA,IAElD,OADA0W,EAASzT,OAAOqb,EAAG,mCAAmCte,KAC/Cse,CAAC,E,gEC1IV,MAAM6O,GAAyBA,IAC7BxsB,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBjC,cAACyD,IAAU,CAAAxB,SAAC,uDACZjC,cAACyD,IAAU,CAAC3B,QAAQ,UAASG,SAAC,mGAI9BjC,cAACyD,IAAU,CAAC3B,QAAQ,UAASG,SAAC,mLAQrBosB,GAAqCA,IAE9CruB,cAACqC,EAAI,CACHpB,KAAK,OACLR,MAAM,YACNF,QAASP,cAACouB,GAAY,IACtB7rB,aAAW,I,yBCjBjB,MAAM+rB,GAAS,CAAC,UAAW,WAEdC,GAAmB9L,GAAY,CAC1CxhB,KAAM,oBACN0hB,MAAO,QACPpG,YACE,oIAEF8B,OAAQ,GACRrc,UAAU,EACV6F,GAAIhI,IAAgB,IAAf,MAAEoT,GAAOpT,EACZ,MAAM2uB,EAAmBA,KACvB,MAAM/gB,EAAS8V,EAAWhW,aAAa0F,EAAMjF,YACvCL,EAAMF,EAAOE,IAGb8gB,EAAaxb,EAAMjF,WAAW,GADlB,GAEZ0gB,EAAczb,EAAMjF,WAAW,GAFnB,GAGlB,IAAK,IAAIlJ,EAAI,EAAGA,EAHE,GAGaA,GAAK,EAClC,IAAK,IAAI6pB,EAAI,EAAGA,EAJA,GAIeA,GAAK,EAClChhB,EAAI8P,UAAY6Q,IAAQxpB,EAAI6pB,GAAK,GACjChhB,EAAIihB,SACF9pB,EAAI2pB,EACJE,EAAID,GACH5pB,EAAI,GAAK2pB,GACTE,EAAI,GAAKD,GAIhB,OAAOjhB,CAAM,EAGf,OAAO6N,EAAUlI,UAAUH,GAAQ/E,GACjCqV,EAAWvU,cAAc,CACvBhB,WAAYiF,EAAMjF,WAClBiB,WAAYuf,IACZtf,WAAYhB,KAEf,ICgDC2gB,GAAqBA,CACzB5b,EACA6b,KAEA,MAAMta,EAAYvB,EAAMK,OAAO1O,KAAKqJ,IAClC,MAAM8gB,EAAM,IAAItb,kBAAkBxF,EAAM3J,QACxC,IAAK,IAAIQ,EAAI,EAAGA,EAAImJ,EAAM3J,OAAQQ,GAAK,EACjCgqB,GAAoB7gB,EAAMnJ,EAAI,GAAK,KAErCiqB,EAAIjqB,GAAKgqB,EAAiB,GAC1BC,EAAIjqB,EAAI,GAAKgqB,EAAiB,GAC9BC,EAAIjqB,EAAI,GAAKgqB,EAAiB,GAC9BC,EAAIjqB,EAAI,GAAK,IAEbiqB,EAAIjqB,GAAKmJ,EAAMnJ,GACfiqB,EAAIjqB,EAAI,GAAKmJ,EAAMnJ,EAAI,GACvBiqB,EAAIjqB,EAAI,GAAKmJ,EAAMnJ,EAAI,GACvBiqB,EAAIjqB,EAAI,GAAK,GAGjB,OAAOiqB,CAAG,IAGZ,MAAO,CACL/gB,WAAYiF,EAAMjF,WAClBsF,OAAQkB,EACT,EAGGwa,GAAYxZ,UAAA,IAAO,MACvBvC,EAAK,iBACL6b,EAAgB,IAChB9X,GAKD5W,EAAA,OACC,IAAI4I,SAAiBC,IACnB,MAAOlF,EAAOyJ,GAAUyF,EAAMjF,WACxB4H,EAAM,IAAIqZ,KAAWlrB,EAAOyJ,GAQlC,GANAoI,EAAIsZ,aAAalY,GACjBpB,EAAIuZ,UAAU,GAGdvZ,EAAIwZ,cAEAN,EAAkB,CAEpB,MAAMzO,EAAW1B,EAAUpV,WAAWulB,GAAkBvpB,MAAM,GAC9DqQ,EAAIyZ,eAAe,KAAKhP,IAC1B,CAEA,IAAI7R,EAAc,GAClBoH,EAAI0Z,GAAG,QAASC,IACd/gB,EAAK4H,KAAKmZ,EAAM,IAElB3Z,EAAI0Z,GAAG,OAAO9Z,UACZ,MAAMkC,EAAO,IAAI9O,KAAK4F,EAAM,CAAE3F,KAAM,cAC9BsO,QAAgBQ,EAAS7O,oBAAoB4O,GACnDzO,EAAQkO,EAAQ,IAGlBlE,EAAMK,OAAOkc,SAASza,IACpBa,EAAI6Z,SAAS1a,EAAE,IAGjBa,EAAI8Z,QAAQ,GACZ,EAEEC,GAAsBA,CAC1B1c,EACAzI,KAUA,IAAIolB,GAAiB,EACrB,MAAMC,EAAa,IAAIhJ,KAChB9iB,EAAOyJ,GAAUyF,EAAMjF,WAC9B,IAAI8hB,GAAyB,EACzBC,EAAUpR,EAAUpV,WAAW,CAAC,EAAG,IAAK,EAAG,MAwB/C,OAvBA0J,EAAMK,OAAOkc,SAASvhB,IACpB,IAAK,IAAIkD,EAAI,EAAGA,EAAI3D,EAAQ2D,GAAK,EAC/B,IAAK,IAAItM,EAAI,EAAGA,EAAId,EAAOc,GAAK,EAAG,CACjC,MAAMwQ,EAAKiG,EAAUtI,mBAAmBC,EAAMjF,WAAYC,EAAO,CAC/DpJ,EACAsM,IAKF,GAHIwN,EAAUrU,uBAAuB+K,KACnCya,GAAyB,GAEvBnR,EAAUvU,cAAciL,GAC1Bua,GAAiB,MACZ,CACL,MAAM5lB,EAAM2U,EAAUpV,WAAW8L,GACjCwa,EAAW/I,IAAI9c,GACXA,IAAQ+lB,IAEVA,EAAUC,GAAwBxlB,EAAQqlB,GAE9C,CACF,CACF,IAEK,CACLf,iBAAkBc,EACdjR,EAAU5U,aAAagmB,QACvBxrB,EACJurB,yBACD,EAGGE,GAA0B,SAC9BxlB,EACAmM,GAEY,IADZsZ,EAAQ5rB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAEX,MAAM6rB,EAAMvR,EAAUpV,WAAWoV,EAAUpU,YAAYC,IACvD,OAAIylB,EAAW,IAENC,EAEFvZ,EAAIoQ,IAAImJ,GACXF,GAAwBxlB,EAAQmM,EAAKsZ,EAAW,GAChDC,CACN,ECjOe,SAASC,KACtB,OAAO,IAAIC,OAAO,IAA0B,6CAC9C,CCSA,MAAMC,GAAiB,IAAIC,IAErBC,GAAeC,GAA2B/V,IAC9C,MAAMgW,EAAcJ,GAAevX,IAAI0X,GAClCC,IAGLA,EAAYxC,OAAOxT,GACnB4V,GAAeK,OAAOF,GAAc,ECTzBG,GACX3U,IAAqB,QAARI,GHQW5G,UAKkB,IALX,MAC/BvC,EAAK,YACL2d,EAAW,WACXC,EAAU,IACV7Z,GACQnX,EACR,MAAM2K,EAASge,KAAWqI,GAEpBC,EAAS5C,GAAa0C,EAAYG,YAClC1nB,QAAeynB,EAAOjpB,GAAG,CAC7BoL,QACAU,WAAYid,EAAYvS,OACxB7T,YAGI,iBAAEskB,EAAgB,uBAAEgB,GAA2BH,GACnDtmB,EACAmB,GAGIoL,QAAYoZ,GAAU,CAE1B/b,MAAO4b,GAAmBxlB,EAAQylB,GAClCA,mBACA9X,QAGF,GAAI8Y,EAAwB,CAC1B,MAAMkB,QAAqBzC,GAAiB1mB,GAAG,CAC7CoL,MAAO5J,EACPsK,WAAY,GACZnJ,WAGF,MAAO,CACLoL,MACA3C,MAAO5J,EACPgS,sBAAsB,EACtBD,6BAA8B4T,GAAU,CACtC/b,MAAO+d,EACPlC,sBAAkBvqB,EAClByS,QAGN,CAAO,CACL,MAAMga,EACgB,MAApBlC,OACIvqB,QACMgqB,GAAiB1mB,GAAG,CACxBoL,MAAO5J,EACPsK,WAAY,GACZnJ,WAGR,MAAO,CACLoL,MACA3C,MAAO5J,EACPgS,sBAAsB,EACtBD,uBACkB,MAAhB4V,OACIzsB,QACMyqB,GAAU,CACd/b,MAAO+d,EACPlC,sBAAkBvqB,EAClByS,QAGZ,GEvD8BpC,GAC9B,IAAI5L,SAA2B,CAACC,EAASglB,KACvC,MAAMgD,EAAS,IAAIC,GAEbV,EAAgB,GAAGW,KAAKC,SAAS/qB,KAAKoE,MAAsB,IAAhBpE,KAAKmE,YACvD6lB,GAAe1Z,IAAI6Z,EAAe,CAChCvnB,UACAglB,WAGFgD,EAAOI,iBAAiB,QAASd,GAAYC,IAC7CS,EAAOI,iBAAiB,eAAgBd,GAAYC,IAEpDS,EAAOK,UAAaC,IAElB,MAAM/iB,EAAO+iB,EAAQ/iB,KACD,aAAhBA,EAAKgjB,QAzBOC,EAACjB,EAAuBnnB,KAC5C,MAAMonB,EAAcJ,GAAevX,IAAI0X,GAClCC,IAGLA,EAAYxnB,QAAQI,GACpBgnB,GAAeK,OAAOF,GAAc,EAoB9BiB,CAAcjB,EAAehiB,EAAKnF,OACpC,EAGF4nB,EAAOS,YAAY9c,EAAK,IExCtB+c,GAAwBpwB,IAAMqwB,cAA4B,CAC9DC,eAAgB,OAGLC,GAAmCjyB,IAAmB,IAAlB,SAAEoC,GAAUpC,EAC3D,MAAMgyB,EAAiBtwB,IAAMyQ,OAAO,GAEpC,OACEhS,cAAC2xB,GAAsBI,SAAQ,CAAC1Y,MAAO,CAAEwY,kBAAiB5vB,SACvDA,GAC8B,EAW9B,SAAS+vB,GAAkB5xB,GAM9B,IAN+B,WACjC6xB,EAAU,QACVC,GAID9xB,EACC,MAAM,eAAEyxB,GAAmBtwB,IAAM4wB,WAAWR,IAEtCS,EAAW7wB,IAAMG,aACrB,CAAC2wB,EAAela,KACdkE,GAAS,WAAY,CAAEgW,QAAOR,mBAC1BQ,IAAUR,EAAe1f,QAC3B8f,EAAW9Z,GAGXkE,GAAS,+BACX,GAEF,CAAC4V,EAAYJ,IAGf,OAAOtwB,IAAMG,aACVkT,IACC,MAAMyd,EAnDWhsB,KAAKoE,MAAsB,IAAhBpE,KAAKmE,UAoDjC6R,GAAS,cAAe,CAAEgW,QAAOzd,SACjCid,EAAe1f,QAAUkgB,EACzB1B,GAAW/b,GACR0d,MAAMna,GAAYia,EAASC,EAAOla,KAClCoa,MAAML,EAAQ,GAEnB,CAACA,EAASE,EAAUP,GAExB,CC/DA,MAAMzD,GAAyBA,IAC7BxsB,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBjC,cAACyD,IAAU,CAAAxB,SAAC,2BACZjC,cAACyD,IAAU,CAAC3B,QAAQ,UAASG,SAAC,mEAG9BjC,cAACyD,IAAU,CAAC3B,QAAQ,UAASG,SAAC,2GAOrBuwB,GAAqCA,IAE9CxyB,cAACqC,EAAI,CACHpB,KAAK,UACLR,MAAM,UACNF,QAASP,cAACouB,GAAY,IACtB7rB,aAAW,ICOXkwB,GAAc7yB,YAAO,MAAPA,EAAcC,IAAA,IAAC,MAAEQ,GAAOR,EAAA,MAAM,CAChD6yB,SAAU,SACV9f,IAAK,OACL+f,QAAS,WACTnyB,gBAAiBH,EAAM2kB,QAAQ4N,QAAQC,aACxC,IAEKC,GAAalzB,YAAO,KAAPA,CAAa,CAC9B+yB,QAAS,IAiBEI,GAAqC3yB,IAS3C,IAAD4yB,EAAAC,EAAA,IAT6C,KACjDC,EAAI,aACJC,EAAY,cACZC,EAAa,gBACbC,EAAe,QACfC,EAAO,eACPC,EAAc,eACdC,EAAc,SACdC,GACDrzB,EACC,MAAO6S,EAAOygB,GAAYnyB,IAAMC,SAE9B,CAAEmyB,WAAW,IAETC,EAAgB5B,GAAmB,CACvCC,WAAa9Z,IACXub,EAAS,CAAEC,WAAW,EAAOxb,WAAU,KAIpC0b,EAAeC,GAAoBvyB,IAAMC,UAAS,IAElDuyB,EAAeC,GAAoBzyB,IAAMC,cAE9C+C,IAEK0vB,EAAOC,GAAY3yB,IAAMC,UAAS,GAEzCD,IAAM2Q,WAAU,KACVkhB,GACFY,EAAiB,CACflD,OAAQsC,EAActC,OACtBzS,OAAQ,IAAI+U,EAAc/U,SAE9B,GACC,CAAC+U,IAEJ7xB,IAAM2Q,WAAU,KAETghB,IACHY,GAAiB,GACjBE,OAAiBzvB,GACjBmvB,EAAS,CAAEC,WAAW,IACxB,GACC,CAACT,IAEJ3xB,IAAM2Q,WAAU,KAEd,GAAKihB,EAIL,OAAKU,OAAL,GACExX,GAAS,mBAETqX,EAAS,CACPC,WAAW,EACXxb,QAASgb,SAEXW,GAAiB,GAEnB,GAIC,CAACX,IAEJ5xB,IAAM2Q,WAAU,KACTihB,GAAiBY,IAItBL,EAAS,CAAEC,WAAW,IACtBC,EAAc,CACZ5c,IAAKsc,EACLzC,WAAY0C,EACZtgB,MAAOkgB,EAAalgB,MACpB2d,YAAa,CACXG,WAAYgD,EAAcjD,OAAO7vB,KACjCod,OAAQ0V,EAAc1V,UAExB,GAGD,CAAC8U,EAAcY,EAAeT,EAASC,IAE1C,MAAMY,EAAcnzB,IAAkC,IAAjC,KAAE8N,GAAyB9N,EACzC8N,GAASilB,GAKdP,EAAeO,EAAe9gB,EAAM0gB,eAAYpvB,EAAY0O,EAAMkF,SAClE+b,GAAS,IALPT,GAKa,EAGX3C,EAA8B,QAAxBkC,EAAgB,OAAbe,QAAa,IAAbA,OAAa,EAAbA,EAAejD,cAAM,IAAAkC,SAAIzuB,EAExC,OACEvE,cAACo0B,KAAM,CAACxZ,WAAS,EAACla,SAAS,KAAKwyB,KAAMA,EAAKjxB,SACxC8xB,GAAiBjD,GAChBlvB,eAAAyyB,WAAA,CAAApyB,SAAA,CACEjC,cAACs0B,KAAW,CAAAryB,SACVjC,cAACgD,IAAK,CAACG,UAAU,MAAME,QAAS,EAAGkxB,UAAW,EAAEtyB,SAC9CjC,cAACof,KAAW,CAACxE,WAAS,EAAA3Y,SACpBjC,cAACw0B,KAAY,CACXC,kBAAgB,EAChBpb,MAAO0a,EAAcjD,OACrB3R,QAASkU,EACTqB,QAAU1Z,GAAMA,EAAE2H,MAClBpJ,SAAUA,CAACob,EAAQC,KAEjBZ,EAAiB,CACflD,OAAQ8D,EACRvW,OAAQuW,EAAUvW,OAAOzZ,KAAKsd,IAAM,IAAA2S,EAAA,OAClC3S,EAAE9D,aAAgC,QAApByW,EAAa,OAAZ1B,QAAY,IAAZA,OAAY,EAAZA,EAAclgB,aAAK,IAAA4hB,SAAItwB,EAAU,MAGpD2vB,GAAS,EAAK,EAEhBY,eAAiBC,GAAWA,EAAO9zB,KACnC+zB,YAAc3W,GACZzc,eAAA,MAAAK,SAAA,CACEL,eAAC6wB,GAAW,CAAAxwB,SAAA,CACVjC,cAACyD,IAAU,CAAC3B,QAAQ,YAAWG,SAC5Boc,EAAOsE,QAEV3iB,cAAC8D,IAAO,OAEV9D,cAAC8yB,GAAU,CAAA7wB,SAAEoc,EAAOpc,aAPboc,EAAO4W,KAUlBC,aAAcA,CAACn1B,EAAO+wB,IACpB9wB,cAAA,SAAQD,EAAKkC,SACXL,eAACoB,IAAK,CAACmyB,WAAY,EAAGlxB,YAAa,EAAEhC,SAAA,CACnCjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAE6uB,EAAO7vB,OACpCjB,cAACyD,IAAU,CAAC3B,QAAQ,UAAUqzB,WAAY,EAAElzB,SACzC6uB,EAAOvU,mBAKhB6Y,YAAc/W,GACZre,cAAC2a,IAAS,IAAK0D,EAAQjd,MAAM,mBAMvCpB,cAACq1B,KAAa,CAAApzB,SACZL,eAACoB,IAAK,CAACsyB,QAASt1B,cAAC8D,IAAO,IAAKT,QAAS,EAAEpB,SAAA,CACtCL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCL,eAAC6B,IAAU,CAAC3B,QAAQ,QAAOG,SAAA,CACxB6uB,EAAOvU,YACRvc,cAAA,OAAAiC,SACG6uB,EAAOlO,sBACN5iB,cAACyD,IAAU,CAAC3B,QAAQ,UAAUqzB,WAAY,EAAElzB,SACzC6uB,EAAOlO,4BAKfkO,EAAOhO,oBACP7P,EAAM0gB,WACP1gB,EAAMkF,QAAQlF,MAAMK,OAAOhP,QAAU,EACnCtE,cAACwyB,GAAwB,IACvB,QAGL1B,EAAOzS,OAAOzZ,KAIb,CAACkd,EAA2B5c,KAC1B,MAAM+c,EAAMH,EAAMja,GAAG,CACnBwR,MAAO0a,EAAc1V,OAAOnZ,GAC5BqU,SAAWC,IACT0a,GAAS,GACTF,EAAiB,IACZD,EACH1V,OAAQ1G,EAASnT,aACfuvB,EAAc1V,OACdnZ,GACA,IAAMsU,KAER,IAGN,OACExZ,cAACuB,IAAMg0B,SAAQ,CAAAtzB,SAGZggB,GAFI,GAAG8R,EAAcjD,OAAO7vB,QAAQ6gB,EAAM7gB,OAG5B,IAIvBjB,cAACgD,IAAK,CAACb,GAAI,CAAEqL,OAAQ,KAAMvL,SACxBgR,EAAM0gB,UACL3zB,cAACw1B,KAAgB,CAACzzB,KAAM,MAExBH,eAAAyyB,WAAA,CAAApyB,SAAA,CACEjC,cAACka,GAAG,CACFC,IACsC,QADnC8Y,EACDhgB,EAAMkF,QAAQiD,8BAAsB,IAAA6X,IACpChgB,EAAMkF,QAAQvC,IAEhBwE,IAAK,UAAU2Z,EAAcjD,OAAO7vB,OACpC+M,WAAYiF,EAAMkF,QAAQlF,MAAMjF,aAEjCiF,EAAMkF,QAAQkD,qBACbrb,cAACquB,GAAwB,IACvB,eAMdzsB,eAAC6zB,KAAa,CAAAxzB,SAAA,CACZjC,cAACiD,IAAM,CACLnB,QAAQ,WACR4zB,WAAS,EACTx0B,QAASA,KACPizB,EAAY,CAAErlB,MAAM,GAAQ,EAC5B7M,SACH,WAGDjC,cAACiD,IAAM,CACLnB,QAAQ,YACR4zB,WAAS,EACT1zB,UAAWiyB,EACX/yB,QAASA,KACPizB,EAAY,CAAErlB,MAAM,GAAO,EAC3B7M,SACH,0BAMA,ECzRP6X,GAAW,IAOX6b,GAA8B91B,IAA6B,IAA5B,OAAEwJ,EAAM,WAAE0nB,GAAYlxB,EACzD,MAAMoT,EAAQ5J,EAAO4J,OACf,OAAEK,EAAM,WAAEtF,GAAeiF,GACxBlP,EAAOyJ,GAAUQ,GAEjB4nB,EAAkBC,GAAuBt0B,IAAMC,UAAS,IAEzD,SAAEs0B,EAAQ,UAAEC,EAAS,OAAEC,EAAM,OAAEC,GAAW10B,IAAMuR,SAAQ,KAC5D,MAAMmH,EAAczM,EAASzJ,EAE7B,IAAI+xB,EAAWhc,GACXic,EAAYjc,GAUhB,OARI/V,EAAQyJ,EAEVuoB,EAAY1vB,KAAKoE,MAAMwP,EAAcH,IAGrCgc,EAAWzvB,KAAKoE,MAAMwP,EAAcH,IAG/B,CACLgc,WACAC,YACAC,OAAQF,EAAW/xB,EACnBkyB,OAAQF,EAAYvoB,EACrB,GACA,CAACA,EAAQzJ,IAENmyB,EAAiB30B,IAAMuR,SAC3B,IACEQ,EAAO1O,KAAI,CAACqJ,EAAO/I,IACjBtD,eAACoB,IAAK,CACJI,WAAW,SAAQnB,SAAA,CAGnBL,eAAC6B,IAAU,CAAC3B,QAAQ,UAASG,SAAA,CAAC,SAAOiD,EAAM,KAC3ClF,cAACqR,GAAa,CAEZtN,MAAO+xB,EACPtoB,OAAQuoB,EACRxkB,cAAgBjD,IACd+B,GAAe/B,EAAY,CACzBgC,gBAAiB0lB,EACjBzlB,cAAe0lB,IAEjBxnB,GAAkB,CAAEd,IAAKW,EAAWX,IAAKK,aAAYC,SAAQ,GAR1D/I,KAJF,GAAGmE,EAAOuM,IAAIugB,UAAU,EAAG,OAAOjxB,QAiB7C,CAAC8I,EAAY+nB,EAAWD,EAAUxiB,EAAQ0iB,EAAQ3sB,EAAOuM,IAAKqgB,IAGhE,OACEr0B,eAAAyyB,WAAA,CAAApyB,SAAA,CACEL,eAACoB,IAAK,CAACI,WAAW,SAAQnB,SAAA,CACxBjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAC,aAE3BoH,EAAOgS,qBACNzZ,eAAAyyB,WAAA,CAAApyB,SAAA,CACEjC,cAACka,GAAG,CACFC,IAAK9Q,EAAO+R,uBACZpN,WAAYA,EACZoM,IAAK2W,IAEP/wB,cAACquB,GAAwB,OAG3BzsB,eAACoB,IAAK,CAACK,QAAS,EAAG+yB,GAAI,EAAEn0B,SAAA,CACvBjC,cAACka,GAAG,CACFC,IACEyb,GAAoBvsB,EAAO+R,uBACvB/R,EAAO+R,uBACP/R,EAAOuM,IAEb5H,WAAYA,EACZoM,IAAK2W,IAE2B,MAAjC1nB,EAAO+R,wBACNxZ,eAACoB,IAAK,CAACG,UAAU,MAAKlB,SAAA,CACpBjC,cAACyD,IAAU,CAAC3B,QAAQ,UAASG,SAAC,sBAC9BjC,cAACue,KAAQ,CACPC,QAASoX,EACTrc,SAAWyB,GAAM6a,EAAoB7a,EAAEC,OAAOuD,oBAO1Dxe,cAAC8D,IAAO,CAACuyB,YAAY,aACpBH,IACA,EAQMI,GAAoCl2B,IAAyB,IAAxB,eAAEm2B,GAAgBn2B,EAClE,MAAoC,SAAhCm2B,EAAeC,MAAMhF,OAChBxxB,cAACw1B,KAAgB,IAIxBx1B,cAAC21B,GAAK,CACJ5E,WAAYwF,EAAexF,WAC3B1nB,OAAQktB,EAAeC,MAAMvjB,OAC7B,EC9EOwjB,GAA0C52B,IAOhD,IAPiD,OACtDixB,EAAM,MACNpsB,EAAK,eACLgyB,EAAc,yBACdC,EAAwB,gBACxBC,EAAe,iBACfC,GACDh3B,EACC,MAAMi3B,EAASv1B,IAAMG,aAAY,KAC/Bi1B,EAAyB,CACvBzD,MAAM,EACNhuB,IAAKR,EACLqyB,OAAO,GACP,GACD,CAACryB,EAAOiyB,IAELK,EAAWz1B,IAAMG,aAAY,KACjCk1B,EAAgBjf,EAAS5S,YAAY2xB,EAAgBhyB,GAAO,GAC3D,CAACgyB,EAAgBhyB,EAAOkyB,IAErBK,EAAa11B,IAAMG,aAAY,KACnC,MAAMw1B,EAASxyB,EAAQ,EACvBkyB,EACEjf,EAAStS,WAAWqxB,EAAgBQ,EAAQL,EAAiBnyB,KAE/DmO,YACE,IACE8jB,EAAyB,CACvBzD,MAAM,EACNhuB,IAAKgyB,EACLH,OAAO,KAEX,EACD,GACA,CACDL,EACAhyB,EACAmyB,EACAD,EACAD,IAGI7T,EAAoBvhB,IAAMuR,SAAQ,KACtC,GAA4B,SAAxBge,EAAO0F,MAAMhF,OACf,OAAO,KAIT,OADUtD,GAAa4C,EAAOC,YACxBjO,mBAAqBgO,EAAO0F,MAAMvjB,MAAMA,MAAMK,OAAOhP,QAAU,EAC5DtE,cAACwyB,GAAwB,IAG3B,IAAI,GACV,CAAC1B,IAEJ,OACElvB,eAACoB,IAAK,CAAAf,SAAA,CACJjC,cAACgiB,IAAK,CAAC9e,MAAO,CAAEyvB,QAAS,GAAKwE,UAAW,EAAEl1B,SACzCL,eAACoB,IAAK,CAACI,WAAW,SAASC,QAAS,EAAEpB,SAAA,CACpCL,eAACoB,IAAK,CAACG,UAAU,MAAME,QAAS,EAAEpB,SAAA,CAChCL,eAAC6B,IAAU,CAAC3B,QAAQ,KAAIG,SAAA,CAAC,IACrByC,EAAQ,EAAE,KAAGosB,EAAOC,cAEvBjO,KAEHlhB,eAACoB,IAAK,CACJG,UAAU,MACVzC,SAAUsb,GAAY,QAAU,KAChC3Y,QAAS,EACTlB,GAAI,CAAEi1B,UAAW,QAASn1B,SAAA,CAE1BL,eAACoB,IAAK,CAACK,QAAS,EAAGg0B,eAAe,SAAQp1B,SAAA,CACxCjC,cAACe,EAAa,CAACK,MAAM,OAAOH,KAAK,WAAWC,QAAS41B,IACrD92B,cAACe,EAAa,CAACK,MAAM,SAASH,KAAK,SAASC,QAAS81B,OAEvDh3B,cAACs2B,GAAQ,CAACC,eAAgBzF,YAIhC9wB,cAAC8D,IAAO,CAAC3B,GAAI,CAAEm1B,GAAI,GAAIr1B,SACrBjC,cAACiD,IAAM,CAAC/B,QAAS+1B,EAAYzb,UAAWxb,cAACqC,EAAI,CAACpB,KAAK,QAASgB,SACzDyC,EAAQgyB,EAAepyB,OAAS,EAC7B,qBACA,uBAGF,EAICizB,GAA6Cn3B,IAInD,IAJoD,SACzDo3B,EAAQ,gBACRnE,EAAe,gBACfuD,GACDx2B,EACC,MAAMs2B,EAAiBc,EAASC,SACzBC,EAAuBf,GAC5Bp1B,IAAMC,SAAgC,CAAE0xB,MAAM,KAEzCyE,EAAWC,GAAgBr2B,IAAMC,WAIxCD,IAAM2Q,WAAU,KACTslB,EAASG,YAAsB,OAATA,QAAS,IAATA,OAAS,EAATA,EAAW/hB,OAAQ4hB,EAASG,UAAU/hB,KAIjEgiB,EAAaD,EAAU,GACtB,CAACH,EAAUG,IAGd,MAAME,EAAqBt2B,IAAMuR,SAAQ,KAGvC,IAAK4kB,EAAsBxE,KACzB,OAGF,MAAM4E,EAAapB,EAAegB,EAAsBxyB,IAAM,GAC9D,OAAI4yB,EACiC,SAA5BA,EAAWtB,MAAMhF,OACpBsG,EAAWtB,MAAMvjB,WACjB1O,EAGCizB,EAASG,SAAS,GACxB,CAACH,EAAUd,EAAgBgB,IAExBtE,EAAgB7xB,IAAMuR,SAAQ,KAClC,IAAK4kB,EAAsBxE,KACzB,OAGF,MAAMlY,EAAI0b,EAAegB,EAAsBxyB,KAC/C,MAAO,CACL4rB,OAAQ5C,GAAalT,EAAE+V,YACvB1S,OAAQrD,EAAE+c,aACX,GACA,CAACL,EAAuBhB,IAErBG,EAAmBt1B,IAAMG,aAC5Bs2B,IAAY,CACXjH,WAAYsC,EAAgB,GAAGpyB,KAC/B82B,aAAc1E,EAAgB,GAAGhV,OAAOzZ,KAAKsd,IAC3C,IAAIjP,EACJ,GAAa,IAAT+kB,EAAY,CAAC,IAADC,EACdhlB,EAA0B,QAArBglB,EAAGT,EAASG,iBAAS,IAAAM,OAAA,EAAlBA,EAAoBhlB,KAC9B,KAAO,CACL,MAAMilB,EAAiBxB,EAAesB,GACD,UAAnB,OAAdE,QAAc,IAAdA,OAAc,EAAdA,EAAgB1B,MAAMhF,UACxBve,EAAQilB,EAAe1B,MAAMvjB,MAAMA,MAEvC,CAEA,OAAOiP,EAAE9D,aAAanL,EAAM,IAE9BujB,MAAO,CAAEhF,OAAQ,WAEnB,CAACgG,EAAUd,EAAgBrD,IAmCvB8E,EAAW52B,IAAMG,aAAY,KACjCk1B,EACEjf,EAAStS,WAAWqxB,EAAgB,EAAGG,EAAiB,KAE1DhkB,YACE,IACE8jB,EAAyB,CACvBzD,MAAM,EACNhuB,IAAK,EACL6xB,OAAO,KAEX,EACD,GACA,CAACL,EAAgBG,EAAkBD,IAEhCwB,EAAW72B,IAAMuR,SAAQ,KAC7B,MAAMulB,EAAa3B,EAAeA,EAAepyB,OAAS,GAC1D,GAAK+zB,GAI2B,SAA5BA,EAAW7B,MAAMhF,OAIrB,OAAO6G,EAAW7B,MAAMvjB,MAAM2C,GAAG,GAChC,CAAC8gB,IAEE4B,EAAuB/2B,IAAMG,aACjC,CACEkzB,EACA2D,KAEKb,EAAsBxE,OAI3B0D,EACEjf,EAASnT,aACPkyB,EACAgB,EAAsBxyB,KACtB,MACE6rB,WAAY6D,EAAU9D,OAAO7vB,KAC7B82B,aAAcnD,EAAUvW,OACxBmY,MAAO+B,EACH,CAAE/G,OAAQ,OAAQve,MAAOslB,GACzB,CAAE/G,OAAQ,aAIpBmF,EAAyB,CAAEzD,MAAM,IAAQ,GAE3C,CAACwD,EAAgBgB,EAAuBd,IAGpC4B,EAAiBj3B,IAAMG,aAAY,KACnCg2B,EAAsBxE,MAAQwE,EAAsBX,OAEtDH,EACEjf,EAAS5S,YAAY2xB,EAAgBgB,EAAsBxyB,MAG/DyxB,EAAyB,CAAEzD,MAAM,GAAQ,GACxC,CAACwD,EAAgBgB,EAAuBd,IAErC6B,EAAYl3B,IAAMG,aAAY,KAClB,MAAZ02B,GACFM,kBAAON,EAAUZ,EAAS/f,OAAS,YACrC,GACC,CAAC2gB,EAAUZ,IAGRmB,EAAYp3B,IAAMuR,SAAQ,IACzB4kB,EAAsBxE,MAIpBwE,EAAsBX,MACzBW,EAAsBxyB,IAJjB0zB,OAAOC,kBAMf,CAACnB,IAEJ,OACE91B,eAACoB,IAAK,CAAAf,SAAA,CACJjC,cAAC+yB,GAAiB,CAChBG,KAAMwE,EAAsBxE,KAC5BG,gBAAiBA,EACjBG,eAAgB8E,EAChB7E,SAAU+E,EACVrF,aAAc0E,EACdzE,cAAeA,EACfE,QAASkE,EAASxgB,IAClBuc,eAAe,cAEjB3xB,eAAC2Z,IAAG,CAAAtZ,SAAA,CACFjC,cAAC8D,IAAO,CAAC3B,GAAI,CAAEi0B,GAAI,GAAIn0B,SACrBjC,cAACiD,IAAM,CAACuY,UAAWxb,cAACqC,EAAI,CAACpB,KAAK,QAAUC,QAASi3B,EAAUl3B,KAAK,MAAKgB,SAAC,0BAIvEy0B,EAAe9xB,KACd,CAAC2a,EAAGyY,IACFA,IAASW,GACP34B,cAACy2B,GAAW,CAEV/xB,MAAOszB,EACPtB,eAAgBA,EAChB5F,OAAQvR,EACRoX,yBAA0BA,EAC1BC,gBAAiBA,EACjBC,iBAAkBA,GA9ThBiC,EAACvZ,EAAmBra,IACpC,GAAGqa,EAAEwR,cAAc7rB,KACE,SAAnBqa,EAAEiX,MAAMhF,OAAoBjS,EAAEiX,MAAMvjB,MAAM2C,IAAIugB,UAAU,EAAG,IAAM,YAsThD2C,CAAUvZ,EAAGyY,SAWf,MAAZI,GACCp4B,cAACgiB,IAAK,CAAC9e,MAAO,CAAEyvB,QAAS,GAAKwE,UAAW,EAAEl1B,SACzCL,eAACoB,IAAK,CAACI,WAAW,SAASC,QAAS,EAAEpB,SAAA,CACpCjC,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,iBACzBjC,cAACka,GAAG,CAACC,IAAKie,EAAUhe,IAAKod,EAAS/f,OAAS,cAC3CzX,cAACiD,IAAM,CACLnB,QAAQ,YACRZ,QAASu3B,EACTjd,UAAWxb,cAACqC,EAAI,CAACpB,KAAK,aAAcgB,SACrC,oBAMD,ECtXN82B,GAAoB,kBAgEbC,GAAgBxC,IAC3B,IACElpB,OAAO2rB,aAAaC,QAAQH,GAAmBI,GAAkB3C,GACnE,CAAE,MAAOte,GAEP/S,QAAQsV,MAAM,sCAAuCvC,EAAI8O,OAAS9O,EACpE,GAGWkhB,GAAgBA,KAC3B,IACE9rB,OAAO2rB,aAAaI,WAAWN,GACjC,CAAE,MAAO7gB,GAEP/S,QAAQsV,MAAM,0CAA2CvC,EAAI8O,OAAS9O,EACxE,GAGIihB,GAAqB3C,IAA6B,IAAD8C,EACrD,MAAMC,EAA8B,IAC/B/C,EAEHmB,UAA0B,QAAjB2B,EAAE9C,EAAMmB,iBAAS,IAAA2B,OAAA,EAAfA,EAAiB1jB,IAC5B6hB,QAASjB,EAAMiB,QAAQ7yB,KAAK2a,IAAC,IACxBA,EAGHiX,MAAO,CAAEhF,OAAQ,aAGrB,OAAOgI,KAAKC,UAAUF,EAAQ,E,wBCvFzB,MAAMG,GAAen4B,IAAMqwB,cAA4B,CAC5D+H,MAAO,KACPC,SAAUA,KACR,MAAM,IAAIx1B,MAAM,0BAA0B,IAIjCy1B,GAA0Bh6B,IAAmB,IAAlB,SAAEoC,GAAUpC,EAClD,MAAOi6B,EAAYC,GAAiBx4B,IAAMC,SAAqB,MAE/D,OACExB,cAAC05B,GAAa3H,SAAQ,CACpB1Y,MAAO,CAAEsgB,MAAOG,EAAYF,SAAUG,GAAgB93B,SAErDA,GACqB,EAIf+3B,GAA0BA,KACrC,MAAM,MAAEL,EAAK,SAAEC,GAAar4B,IAAM4wB,WAAWuH,IAC7C,OACE15B,cAACi6B,KAAQ,CAAC/G,KAAe,MAATyG,EAAc13B,SAClB,MAAT03B,OAAgBp1B,EACfvE,cAACk6B,KAAK,CAACC,SAAUR,EAAMQ,SAAUC,QAASA,IAAMR,EAAS,MAAM33B,SAC5D03B,EAAMpI,WAGF,ECHT8I,GAAW9Y,GAAY,CAC3BtgB,KAAM,8BACNmd,aAHkB,GAIlBjY,IAAK,EACLC,IAAK,KAGDk0B,GAA0B,CAC9BC,QAXgC,EAYhC9C,QAAS,GACTE,eAAWpzB,EACXyS,IAZkB,IAed2e,GAAkBA,KACtB,MAAOa,EAAOgE,GAAej5B,IAAMC,SAAS84B,KACrCG,EAAWC,GAAgBn5B,IAAMC,SAEtC,CAAEyS,SAAS,KACN0mB,EAAcC,GAAmBr5B,IAAMC,SAC5C,MAGIo4B,EDhBmBiB,MACzB,MAAM,SAAEjB,GAAar4B,IAAM4wB,WAAWuH,IACtC,OAAOE,CAAQ,ECcEiB,GAEjBt5B,IAAM2Q,WAAU,KACV8J,IACF4d,EAAS,CACPO,SAAU,UACV5I,QACE,gFAEN,GACC,CAACqI,IAEJr4B,IAAM2Q,WAAU,KACd,WAEE,MAAM4oB,OFxDqBtlB,WAC/B,IACE,MAAMslB,EAASxtB,OAAO2rB,aAAa8B,QAAQhC,IAC3C,GAAI+B,EAAQ,CACV,MAAME,EAAaxB,KAAK9Z,MAAMob,GAC9B,GAAIjf,MAAMof,QAAQD,EAAWvD,SAAU,CACrC,MAAMjB,EAAQwE,EAEd,IAAIE,EACAC,EAAW,GACf,GAA+B,kBAApB3E,EAAMmB,UACf,GAAInB,EAAMmB,UAAUzc,WAAW,kBAAmB,CAChD,MAAMxD,EAAOC,EAAS1P,cAAcuuB,EAAMmB,WACpC5iB,EAAI,IAAI6C,KAAK,CAACF,GAAO8e,EAAM/e,QAC3B,MAAExE,EAAK,IAAE+D,SAAcmE,EAAgBjE,UAAUnC,GACvDmmB,EAAoB,CAClBtlB,IAAK4gB,EAAMmB,UACXvc,uBAAwBob,EAAMmB,UAC9B1kB,QACAoI,sBAAsB,GAExB8f,EAAWnkB,CACb,KAAO,CAEL,MAAM,MAAE/D,SAAgBkI,EAAgBjE,UACtC8jB,EAAWrD,WAEbuD,EAAoB,CAClBtlB,IAAK4gB,EAAMmB,UACXvc,uBAAwBob,EAAMmB,UAC9B1kB,QACAoI,qBAAsBC,EAAUhR,uBAAuB2I,GAE3D,CAEF,MAAO,IACFujB,EACHmB,UAAWuD,EACXlkB,IAAKmkB,EAET,CACF,CACF,CAAE,MAAOjjB,GAEP/S,QAAQsV,MAAM,yCAA0CvC,EAAI8O,OAAS9O,EACvE,CAEgB,EESS+gB,GACjB6B,IA1CwB,IA2CtBA,EAAOP,SACTC,EAAYM,GACZJ,EAAa,CAAEzmB,SAAS,EAAMmnB,WAAY,KAG1CnC,KAGL,EAZD,EAYI,GACH,IAEH,MAAMoC,EAAW95B,IAAMG,aACrB,CACEmG,EAAoChI,KAEhC,IADJ,QAAEoU,GAA8CpU,EAEhD26B,GAAac,IACX,MAAMC,EAAW1zB,EAAGyzB,GAOpB,GANArC,GAA0BsC,GAEd,QAARnf,KACD9O,OAAekuB,MAAQD,GAGV,OAAZtnB,GAA0C,MAAtBsnB,EAAS5D,UAAmB,CAG9CgD,IACF9gB,aAAa8gB,GACbC,EAAgB,OAGlB,MAAMa,ERhDcr7B,KAM0B,IANzB,UAC7Bs7B,EAAS,UACTC,GAIDv7B,EACC,GACEs7B,EAAU1kB,MAAQ2kB,EAAU3kB,KAC5B0kB,EAAU/D,YAAcgE,EAAUhE,UAGlC,OADAtb,GAAS,kCACF,CAAEuf,MAAM,EAAMl3B,MAAO,GAG9B,MAAMm3B,EAAcH,EAAUjE,QACxBqE,EAAcH,EAAUlE,QAG9B,IAAK,IAAI3yB,EAAI,EAAGA,EAAI+2B,EAAYv3B,OAAQQ,GAAK,EAAG,CAC9C,MAAMi3B,EAAQF,EAAY/2B,GACpBk3B,EAAQF,EAAYh3B,GAC1B,IAAKk3B,EAEH,OADA3f,GAAS,mBAAoBvX,GACtB,CAAE82B,MAAM,EAAMl3B,MAAOI,GAG9B,GAA2B,SAAvBk3B,EAAMxF,MAAMhF,OAEd,OADAnV,GAAS,kBAAmBvX,GACrB,CAAE82B,MAAM,EAAMl3B,MAAOI,GAG9B,GAAIi3B,EAAMhL,aAAeiL,EAAMjL,WAE7B,OADA1U,GAAS,yBAA0BvX,GAC5B,CAAE82B,MAAM,EAAMl3B,MAAOI,GAI9B,IAAK,IAAIm3B,EAAK,EAAGA,EAAKF,EAAMhE,aAAazzB,OAAQ23B,GAAM,EAAG,CACxD,MAAMC,EAAaH,EAAMhE,aAAakE,GAChCE,EAASH,EAAMjE,aAAakE,GAClC,GAAIzC,KAAKC,UAAUyC,KAAgB1C,KAAKC,UAAU0C,GAEhD,OADA9f,GAAS,kBAAmBvX,EAAGm3B,GACxB,CAAEL,MAAM,EAAMl3B,MAAOI,EAEhC,CACF,CAGA,OADAuX,GAAS,WACF,CAAEuf,MAAM,EAAO,EQDMQ,CAAe,CACjCT,UAAWL,EACXI,UAAWH,IAGTE,EAAYG,OACE,QAAZ3nB,EACFymB,EAAa,CAAEzmB,SAAS,EAAMmnB,WAAYK,EAAY/2B,SAEtDg2B,EAAa,CAAEzmB,SAAS,IACxB2mB,EACE/nB,YAAW,KACT+nB,EAAgB,MAChBF,EAAa,CACXzmB,SAAS,EACTmnB,WAAYK,EAAY/2B,OACxB,GA/FY,OAoGxB,CAEA,OAAO62B,CAAQ,GACf,GAGJ,IAsDF,OAnDAh6B,IAAM2Q,WAAU,KACdmK,GAAS,uBAAwBoe,IACP,IAAtBA,EAAUxmB,UAMdymB,EAAa,CAAEzmB,SAAS,IACxB,WACEonB,GACGM,IAAS,IACLA,EACHlE,QAASkE,EAAUlE,QAAQ7yB,KAAI,CAAC2a,EAAGza,IAC7BA,EAAI21B,EAAUW,WACT7b,EAEA,IACFA,EACHiX,MAAO,CAAEhF,OAAQ,mBAKzB,CAAEvd,QAAS,YRpJgBuB,WAQb,IAMhBvC,GAdoC,MACxCujB,EAAK,iBACL6F,EAAgB,UAChBC,GAKDz8B,EAOC,GANA8X,EAASzT,OACPsyB,EAAMmB,UACN,oDAIuB,IAArB0E,EACFppB,EAAQujB,EAAMmB,UAAU1kB,UACnB,CACL,MAAMspB,EAAkB/F,EAAMiB,QAAQ4E,EAAmB,GAAG7F,MAC5D7e,EAASzT,OACoB,SAA3Bq4B,EAAgB/K,OAChB,oFAEFve,EAAQspB,EAAgBtpB,MAAMA,KAChC,CAEA,IAAK,IAAInO,EAAIu3B,EAAkBv3B,EAAI0xB,EAAMiB,QAAQnzB,OAAQQ,GAAK,EAAG,CAC/D,MAAMgsB,EAAS0F,EAAMiB,QAAQ3yB,GAEvBuE,QAAesnB,GAAW,CAC9BE,WAAY2F,EAAMmB,UAAU/hB,IAC5B3C,QACA2d,YAAa,CACXG,WAAYD,EAAOC,WACnB1S,OAAQyS,EAAOiH,cAEjB/gB,IAAKwf,EAAMxf,MAGb/D,EAAQ5J,EAAO4J,MAEfqpB,EAAUjzB,EAAQvE,EACpB,GQ6GU03B,CAAoB,CACxBhG,QACA8F,UAAWA,CAACrpB,EAAOwpB,KACjBpB,GACGM,IAAS,IACLA,EACHlE,QAAS9f,EAASnT,aAChBm3B,EAAUlE,QACVgF,GACCld,IAAC,IACGA,EACHiX,MAAO,CAAEhF,OAAQ,OAAQve,gBAI/B,CAAEgB,QAAS,MACZ,EAEHooB,iBAAkB5B,EAAUW,YAE/B,EAtCD,GAsCI,GAEH,CAACX,IAGF74B,eAAAyyB,WAAA,CAAApyB,SAAA,CACEjC,cAAC08B,IAAiB,IAClB18B,cAAC28B,IAAS,CAACj8B,SAAUsb,GAAY,KAAO,KAAK/Z,SAC3CL,eAACoB,IAAK,CACJK,QAAS,EACTg0B,eAAe,eACfj0B,WAAW,SACXW,MAAOiY,GAAY,UAAOzX,EAC1B+wB,QAASt1B,cAAC8D,IAAO,IAAI7B,SAAA,CAErBjC,cAACyD,IAAU,CAAC3B,QAAQ,KAAK86B,GAAI,EAAE36B,SAAC,cAGhCL,eAACoB,IAAK,CAACK,QAAS,EAAGiyB,QAASt1B,cAAC8D,IAAO,IAAI7B,SAAA,CACtCjC,cAAC2D,GAAO,CAAA1B,SACNjC,cAACwD,EAAI,MAEPxD,cAAC2D,GAAO,CAAA1B,SACNL,eAACoB,IAAK,CAACK,QAAS,EAAGD,WAAW,SAAQnB,SAAA,CACpCjC,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,iBACzBjC,cAACua,GAAW,CACVtZ,KAAK,wBACLuZ,aAAcgc,EAAMmB,UACpBpe,SAAUA,CAACoe,EAAWlgB,EAAOT,KAC3B,GAAIgF,GAAW,CACb,MAAOjY,EAAOyJ,GAAUmqB,EAAU1kB,MAAMjF,WACxC,GAAIjK,EAAQ,KAAOyJ,EAAS,IAO1B,YANAosB,EAAS,CACPO,SAAU,QACV5I,QACE,4DAKR,CAEA8J,GACGM,IAAS,IACLA,EACHhE,YACAlgB,QACAT,SAEF,CAAE/C,QAAS,OACZ,IAGJomB,GAASxyB,GAAG,CACXwR,MAAOmd,EAAMxf,IACbuC,SAAWvC,GACTqkB,GACGM,IAAS,IACLA,EACH3kB,SAEF,CAAE/C,QAAS,iBAKD,MAAnBuiB,EAAMmB,WACL/1B,eAAAyyB,WAAA,CAAApyB,SAAA,CACEjC,cAAC2D,GAAO,CAAA1B,SACNjC,cAACu3B,GAAe,CACdC,SAAUhB,EACVnD,gBAAiBvF,GACjB8I,gBAAkBa,GAChB4D,GACGM,IAAS,IACLA,EACHlE,aAEF,CAAExjB,QAAS,YAKnBjU,cAAC2D,GAAO,CAAA1B,SACNL,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBjC,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,kBACzBL,eAAC6B,IAAU,CAAC3B,QAAQ,QAAOG,SAAA,CACzBjC,cAACqC,EAAI,CAACpB,KAAK,UAAUR,MAAM,YAAY,gEAGzCT,cAACiD,IAAM,CACLuY,UAAWxb,cAACqC,EAAI,CAACpB,KAAK,UACtBkB,GAAI,CAAEzB,SAAU,SAChBoB,QAAQ,YACRrB,MAAM,UACNS,QAASA,KACP,MAAMq6B,EAAqB,IACtBjB,GACH3C,UAAWnB,EAAMmB,WAEnB6C,EAAYe,GACZtC,GAA0BsC,EAAS,EACnCt5B,SACH,0BAOTjC,cAAA,KACE68B,KAAK,4CACL5hB,OAAO,SACP6hB,IAAI,aAAY76B,SAEhBjC,cAAA,OACEma,IAAI,+EACJpW,MAAO,GACPyJ,OAAQ,GACR4M,IAAI,0BAOdpa,cAACgD,IAAK,CAAC45B,GAAI,EAAE36B,SACXjC,cAACg6B,GAAa,QAEf,EAIDr2B,GAAoBvD,IAAA,IAAC,SAAE6B,GAAU7B,EAAA,OACrCJ,cAACgiB,IAAK,CAAC9e,MAAO,CAAEyvB,QAAS,GAAIjyB,SAAUsb,GAAY,aAAUzX,GAAYtC,SACtEA,GACK,EAKG86B,GAAgBA,IAEzB/8B,cAAC8xB,GAAsB,CAAA7vB,SACrBjC,cAAC65B,GAAa,CAAA53B,SACZjC,cAAC21B,GAAK,QC9TP,MAAMqH,WAA8Bz7B,IAAM07B,UAAwBC,cAAA,SAAA74B,WAAA,KAChEmyB,MAAe,CACpB2G,UAAU,EACV,CAEF,+BAAOC,CAAyB3iB,GAE9B,OADAtV,QAAQsV,MAAMA,GACP,CAAE0iB,UAAU,EACrB,CAEAE,kBAAkB5iB,EAAc6iB,GAC9Bn4B,QAAQsV,MAAM,kBAAmBA,EAAO6iB,EAC1C,CAEAC,SACE,OAAIC,KAAKhH,MAAM2G,SAEXv7B,eAACoB,IAAK,CAACK,QAAS,EAAEpB,SAAA,CAChBjC,cAACyD,IAAU,CAAC3B,QAAQ,KAAIG,SAAC,WACzBjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAC,sCAG5BjC,cAACyD,IAAU,CAAC3B,QAAQ,QAAOG,SAAC,6FAI5BjC,cAACiD,IAAM,CACLnB,QAAQ,YACRK,GAAI,CAAEzB,SAAU,SAChB+8B,QAASz9B,cAACqC,IAAI,CAAAJ,SAAC,kBACfuZ,UAAWxb,cAACqC,IAAI,CAAAJ,SAAC,kBACjBf,QAASs8B,KAAKz9B,MAAM29B,oBAAoBz7B,SACzC,gCAOAu7B,KAAKz9B,MAAMkC,QACpB,EC5CF,MAAM5B,GAAQs9B,YAAY,CACxB/8B,WAAY,CACVg9B,WAAY,oBAIhBC,IAASN,OACPv9B,cAACuB,IAAMu8B,WAAU,CAAA77B,SACfjC,cAAC+9B,IAAa,CAAC19B,MAAOA,GAAM4B,SAC1BjC,cAACg9B,GAAqB,CACpBU,oBAAqBA,KACnBzE,KACA3rB,OAAO0wB,SAASC,QAAQ,EACxBh8B,SAEFjC,cAAC+8B,GAAG,UAIVlvB,SAASqwB,eAAe,Q","file":"static/js/main.8ccc0e5e.chunk.js","sourcesContent":["import React from 'react';\r\nimport {\r\n  Fab,\r\n  Icon as MuiIcon,\r\n  styled,\r\n  Tooltip,\r\n  tooltipClasses,\r\n  TooltipProps,\r\n  IconProps as MuiIconProps,\r\n} from '@material-ui/core';\r\n\r\n// From https://mui.com/material-ui/material-icons/\r\nexport type Icons =\r\n  | 'add'\r\n  | 'remove'\r\n  | 'clear'\r\n  | 'circle'\r\n  | 'delete'\r\n  | 'arrow_upward'\r\n  | 'arrow_downward'\r\n  | 'arrow_right'\r\n  | 'arrow_left'\r\n  | 'arrow_circle_right'\r\n  | 'arrow_circle_left'\r\n  | 'keyboard_double_arrow_right'\r\n  | 'keyboard_double_arrow_left'\r\n  | 'info'\r\n  | 'edit'\r\n  | 'image'\r\n  | 'priority_high'\r\n  | 'list'\r\n  | 'settings'\r\n  | 'save_alt'\r\n  | 'warning';\r\n\r\nconst HtmlTooltip = styled(({ className, ...props }: TooltipProps) => (\r\n  <Tooltip {...props} classes={{ popper: className }} />\r\n))(({ theme }) => ({\r\n  [`& .${tooltipClasses.tooltip}`]: {\r\n    backgroundColor: '#f5f5f9',\r\n    color: 'rgba(0, 0, 0, 0.87)',\r\n    maxWidth: 220,\r\n    fontSize: theme.typography.pxToRem(12),\r\n    border: '1px solid #dadde9',\r\n  },\r\n}));\r\n\r\nexport interface ClickableIconProps {\r\n  name: Icons;\r\n  onClick?: () => void;\r\n  isDisabled?: boolean;\r\n  label: string;\r\n}\r\n\r\nexport const ClickableIcon: React.FC<ClickableIconProps> = ({\r\n  name,\r\n  onClick,\r\n  isDisabled,\r\n  label,\r\n}) => {\r\n  const [hover, setHover] = React.useState(false);\r\n\r\n  const onMouseEnter = React.useCallback(() => {\r\n    if (onClick) {\r\n      setHover(true);\r\n    }\r\n  }, [onClick]);\r\n\r\n  const onMouseLeave = React.useCallback(() => {\r\n    if (onClick) {\r\n      setHover(false);\r\n    }\r\n  }, [onClick]);\r\n\r\n  return (\r\n    <Fab\r\n      variant=\"extended\"\r\n      size=\"small\"\r\n      disabled={isDisabled}\r\n      onClick={onClick}\r\n      onMouseEnter={onMouseEnter}\r\n      onMouseLeave={onMouseLeave}\r\n      color={hover ? 'secondary' : 'primary'}\r\n    >\r\n      <MuiIcon sx={{ mr: 1 }}>{name}</MuiIcon>\r\n      {label}\r\n    </Fab>\r\n  );\r\n};\r\n\r\nexport interface IconProps {\r\n  name: Icons;\r\n  htmlTooltip?: boolean;\r\n  tooltip?: React.ReactNode;\r\n  color?: MuiIconProps['color'];\r\n}\r\n\r\nexport const Icon: React.FC<IconProps> = ({\r\n  name,\r\n  tooltip,\r\n  htmlTooltip,\r\n  color,\r\n}) => {\r\n  const inner = <MuiIcon color={color}>{name}</MuiIcon>;\r\n  if (tooltip) {\r\n    return htmlTooltip ? (\r\n      <HtmlTooltip title={tooltip}>{inner}</HtmlTooltip>\r\n    ) : (\r\n      <Tooltip title={tooltip}>{inner}</Tooltip>\r\n    );\r\n  } else {\r\n    return inner;\r\n  }\r\n};\r\n","import { Button, ClickAwayListener, Collapse, Stack } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { Icon } from './Icon';\r\n\r\ninterface ExpandableProps {\r\n  mainEle: JSX.Element;\r\n}\r\n\r\nexport const Expandable: React.FC<ExpandableProps> = ({\r\n  mainEle,\r\n  children,\r\n}) => {\r\n  const [collapsed, setCollapsed] = React.useState(true);\r\n\r\n  return (\r\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\r\n      <Stack>\r\n        <Button\r\n          variant=\"text\"\r\n          onClick={() => setCollapsed(!collapsed)}\r\n          style={{ color: 'black' }}\r\n          size=\"small\"\r\n        >\r\n          <Stack direction=\"row\" alignItems=\"center\" spacing={4}>\r\n            <div>{mainEle}</div>\r\n            <Icon name={collapsed ? 'add' : 'remove'} />\r\n          </Stack>\r\n        </Button>\r\n        <Collapse in={!collapsed}>{children}</Collapse>\r\n      </Stack>\r\n    </ClickAwayListener>\r\n  );\r\n};\r\n","import { Divider, Icon, Stack, Typography } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { Expandable } from './Expandable';\r\n\r\nexport const Help: React.FC = () => (\r\n  <Expandable\r\n    mainEle={<Typography variant=\"h5\">Click here for Help</Typography>}\r\n  >\r\n    <Group>\r\n      <Expandable\r\n        mainEle={<Typography variant=\"h6\">Getting Started</Typography>}\r\n      >\r\n        <Section>\r\n          <SectionHeader>Start by importing an image.</SectionHeader>\r\n          <SectionText>\r\n            You may upload a png, jpg, or gif from your device.\r\n          </SectionText>\r\n          <SectionText>\r\n            Alternatively, you can post a URL to a png, jpg, or gif, though this\r\n            can be a little flaky, and does not support animated images.\r\n          </SectionText>\r\n          <SectionText>\r\n            The frames per second controls how fast the final gif will animate.\r\n          </SectionText>\r\n          <SectionText>\r\n            Remember that gifs do not support partial transparency. A pixel will\r\n            be either completely transparent, or not transparent at all. Some\r\n            effects will create partially transparent pixels. When your gif has\r\n            partially transparent pixels, you'll see a fake background applied\r\n            behind it in the preview.\r\n          </SectionText>\r\n        </Section>\r\n      </Expandable>\r\n\r\n      <Expandable\r\n        mainEle={<Typography variant=\"h6\">Adding Effects</Typography>}\r\n      >\r\n        <Group>\r\n          <Section>\r\n            <Section>\r\n              <SectionHeader>\r\n                Effects are applied to an image to manipulate it\r\n              </SectionHeader>\r\n              <SectionText>\r\n                Some may adjust the basic attributes of an image, such as size,\r\n                or number of animation frames.\r\n              </SectionText>\r\n              <SectionText>\r\n                Others may apply animated effects, such as making the image\r\n                spin, or cycle through colors.\r\n              </SectionText>\r\n            </Section>\r\n          </Section>\r\n\r\n          <Divider />\r\n\r\n          <Section>\r\n            <SectionHeader>\r\n              For static images, you'll likely want to first \"Set Animation\r\n              Length\".\r\n            </SectionHeader>\r\n            <SectionText>\r\n              This controls how many frames are in the animation. Typically this\r\n              is between 10 and 20.\r\n            </SectionText>\r\n            <SectionText>\r\n              More frames will increase both the time to compute the image, and\r\n              the final file size.\r\n            </SectionText>\r\n            <SectionText>\r\n              Remember that some places (like Slack and Discord) have strict\r\n              limits on the file size of emojis, so you may need to reduce the\r\n              number of frames in order to meet those requirements. Slack has a\r\n              limit of 128kb, and Discord has a limit of 256kb.\r\n            </SectionText>\r\n          </Section>\r\n\r\n          <Divider />\r\n\r\n          <Section>\r\n            <SectionHeader>\r\n              If uploading to Slack or Discord, you will probably want to use\r\n              \"Adjust Image\" to set the width and height.\r\n            </SectionHeader>\r\n            <SectionText>\r\n              Slack has a limit of 128x128 pixels. Discord has a limit of\r\n              256x256.\r\n            </SectionText>\r\n            <SectionText>\r\n              Making images smaller will also decrease how long it takes to\r\n              apply effects.\r\n            </SectionText>\r\n          </Section>\r\n\r\n          <Divider />\r\n\r\n          <Section>\r\n            <SectionHeader>The order of effects matters</SectionHeader>\r\n            <SectionText>\r\n              The result of each effect is send to the next effect.\r\n            </SectionText>\r\n            <SectionText>\r\n              Because of this, the order of effects matter.\r\n            </SectionText>\r\n            <SectionText>\r\n              Experiment with moving effects around to see different effects.\r\n            </SectionText>\r\n            <SectionText>\r\n              For instance, applying a background color before rotating the\r\n              image will have a very different effect than rotating before\r\n              setting a background color.\r\n            </SectionText>\r\n          </Section>\r\n        </Group>\r\n      </Expandable>\r\n\r\n      <Expandable mainEle={<Typography variant=\"h6\">Creating Gifs</Typography>}>\r\n        <Group>\r\n          <Section>\r\n            <SectionHeader>Gifs will compute automatically</SectionHeader>\r\n            <SectionText>\r\n              Whenever you add an effect, it will automatically compute a new\r\n              gif with that effect.\r\n            </SectionText>\r\n            <SectionText>\r\n              The gif below each effect shows the results of that effect.\r\n            </SectionText>\r\n            <SectionText>\r\n              Click on \"Save Gif\" at the bottom to export the final version of\r\n              the gif after all effects have been applied.\r\n            </SectionText>\r\n          </Section>\r\n        </Group>\r\n      </Expandable>\r\n    </Group>\r\n  </Expandable>\r\n);\r\n\r\nconst Group: React.FC = ({ children }) => <Stack spacing={2}>{children}</Stack>;\r\n\r\nconst Section: React.FC = ({ children }) => (\r\n  <Stack width=\"sm\" spacing={1}>\r\n    {children}\r\n  </Stack>\r\n);\r\n\r\nconst SectionHeader: React.FC = ({ children }) => (\r\n  <Typography variant=\"body1\" paddingLeft=\"0.5rem\">\r\n    {children}\r\n  </Typography>\r\n);\r\n\r\nconst SectionText: React.FC = ({ children }) => (\r\n  <Typography variant=\"body2\" paddingLeft=\"1.0rem\">\r\n    <Icon sx={{ fontSize: 8, marginRight: 1 }}>circle</Icon> {children}\r\n  </Typography>\r\n);\r\n","import bezier from 'bezier-easing';\r\nimport type { Coord, BezierTuple } from '~/domain/types';\r\n\r\n/**\r\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\r\n *\r\n * @example\r\n * ```ts\r\n * const foo: string|undefined = getSomeData();\r\n * assert(foo, 'foo must be defined');\r\n * console.log(foo.length); // OK\r\n * ```\r\n */\r\nexport function assert(\r\n  condition: unknown,\r\n  message = 'Unexpected falsy value'\r\n): asserts condition {\r\n  if (!condition) {\r\n    throw new Error(`AssertionFailure: ${message}`);\r\n  }\r\n}\r\n\r\n/** Returns a new array where the item at the given index is replaced by the given value */\r\nexport const replaceIndex = <T>(\r\n  arr: T[],\r\n  index: number,\r\n  newValueFn: (oldValue: T) => T\r\n): T[] => arr.map((x, i) => (index === i ? newValueFn(x) : x));\r\n\r\n/** Returns a new array with the element at the index removed */\r\nexport const removeIndex = <T>(arr: T[], index: number): T[] =>\r\n  arr.filter((_t, idx) => {\r\n    console.log('Removing', { index, idx });\r\n    return index !== idx;\r\n  });\r\n\r\n/**\r\n * Returns a new array with the new item inserted into the given index.\r\n * @example\r\n * insertInto(['a','b','c'], 1, 'z'); // ['a','z','b','c']\r\n */\r\nexport const insertInto = <T>(arr: T[], index: number, newValue: T): T[] => {\r\n  return [...arr.slice(0, index), newValue, ...arr.slice(index)];\r\n};\r\n\r\nexport const isUrl = (s: string): boolean =>\r\n  /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/.test(\r\n    s\r\n  );\r\n\r\nexport const copyToClipboard = (s: string): Promise<void> =>\r\n  navigator.clipboard.writeText(s);\r\n\r\nexport const readFromClipboard = (): Promise<string> =>\r\n  navigator.clipboard.readText();\r\n\r\nexport const clamp = (n: number, min: number, max: number) =>\r\n  Math.max(Math.min(n, max), min);\r\n\r\n/**\r\n * Calculate a value between v1 and v2, determined by percent.\r\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\r\n */\r\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\r\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\r\n\r\n/**\r\n * Returns the angle in degrees (0 to 360) from c2 to c1\r\n */\r\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\r\n  const xRelCenter = c2[0] - c1[0];\r\n  const yRelCenter = c2[1] - c1[1];\r\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\r\n};\r\n\r\nexport const pointDistance = ([x1, y1]: Coord, [x2, y2]: Coord): number => {\r\n  const xDiff = Math.pow(x2 - x1, 2);\r\n  const yDiff = Math.pow(y2 - y1, 2);\r\n  return Math.sqrt(xDiff + yDiff);\r\n};\r\n\r\n/**\r\n * Calculates a cubic bezier curve for a given value.\r\n * Each value in the BezierTuple must also be between 0 and 1.\r\n * The amount must be between 0 and 1.\r\n * If mirror is true, then amount of [0, 0.5] will go from 0 to 1, and (0.5, 1] will go from 1 to 0.\r\n * The returned value will be between 0 and 1\r\n */\r\nexport const bezierCurve = (easing: BezierTuple, mirror?: boolean) => {\r\n  const fn = bezier(easing[0][0], easing[0][1], easing[1][0], easing[1][1]);\r\n  if (!mirror) {\r\n    return (amount: number): number => fn(amount);\r\n  }\r\n  return (amount: number): number => {\r\n    return amount < 0.5 ? fn(amount * 2) : fn(1 - 2 * (amount - 0.5));\r\n  };\r\n};\r\n\r\nexport const LINEAR_BEZIER: BezierTuple = [\r\n  [0.1, 0.1],\r\n  [0.9, 0.9],\r\n];\r\n\r\n// Shamelessly stolen from https://stackoverflow.com/questions/12168909/blob-from-dataurl\r\nexport const dataURItoBlob = (dataURI: string): Blob => {\r\n  // convert base64 to raw binary data held in a string\r\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\r\n  const split = dataURI.split(',');\r\n  const byteString = atob(split[1]);\r\n\r\n  // separate out the mime component\r\n  const mimeString = split[0].split(':')[1].split(';')[0];\r\n\r\n  // write the bytes of the string to an ArrayBuffer\r\n  const ab = new ArrayBuffer(byteString.length);\r\n\r\n  // create a view into the buffer\r\n  const ia = new Uint8Array(ab);\r\n\r\n  // set the bytes of the buffer to the correct values\r\n  for (let i = 0; i < byteString.length; i++) {\r\n    ia[i] = byteString.charCodeAt(i);\r\n  }\r\n\r\n  // write the ArrayBuffer to a blob, and you're done\r\n  return new Blob([ab], { type: mimeString });\r\n};\r\n\r\nexport const blobOrFileToDataUrl = (file: File | Blob) =>\r\n  new Promise<string>((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result as string);\r\n    reader.readAsDataURL(file);\r\n  });\r\n","import * as convert from 'color-convert';\r\nimport type { Color } from '~/domain/types';\r\nimport { clamp, weightedValue } from './misc';\r\n\r\n/**\r\n * Converts a Pixel into a hex string like '#00FF00'\r\n */\r\nexport const toHexColor = ([r, g, b]: Color) => {\r\n  const toHexValue = (c: number) => {\r\n    const s = c.toString(16).toUpperCase();\r\n    return s.length === 2 ? s : '0' + s;\r\n  };\r\n\r\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\r\n};\r\n\r\nexport const fromHexColor = (hex: string): Color => [\r\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\r\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\r\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\r\n  255,\r\n];\r\n\r\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\r\n\r\n/**\r\n * Our effect functions allow for an alpha channel, but gifs do not.\r\n * All pixels are either fully solid or fully transparent.\r\n * This function returns true if the color's alpha is below a certain threshold.\r\n */\r\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\r\n\r\n/**\r\n * Returns true if the pixel is partially transparent enough that\r\n *  it would cause issues rendering.\r\n */\r\nexport const isPartiallyTransparent = (pixel: Color) =>\r\n  !isTransparent(pixel) && pixel[3] < 128;\r\n\r\nexport const randomColor = (random: seedrandom.prng): Color => [\r\n  Math.floor(random.int32() * 256),\r\n  Math.floor(random.int32() * 256),\r\n  Math.floor(random.int32() * 256),\r\n  255,\r\n];\r\n\r\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\r\n  Math.round((r + g + b) / 3);\r\n\r\nexport const clampColor = ([r, g, b, a]: Color): Color => [\r\n  clamp(r, 0, 255),\r\n  clamp(g, 0, 255),\r\n  clamp(b, 0, 255),\r\n  clamp(a, 0, 255),\r\n];\r\n\r\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\r\n\r\n/**\r\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\r\n * @param hue [0, 360)\r\n * @param amount [0, 100]\r\n */\r\nexport const shiftTowardsHue = (\r\n  [r, g, b, a]: Color,\r\n  hue: number,\r\n  amount: number\r\n): Color => {\r\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\r\n  const [newR, newG, newB] = convert.hsl.rgb([\r\n    hue,\r\n    weightedValue(amount, s, 100),\r\n    l,\r\n  ]);\r\n  return [\r\n    weightedValue(amount, r, newR),\r\n    weightedValue(amount, g, newG),\r\n    weightedValue(amount, b, newB),\r\n    a,\r\n  ];\r\n};\r\n\r\n/**\r\n * Adds the given amount to the hue of the color.\r\n * Amount should be between 0 and 360\r\n */\r\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\r\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\r\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\r\n  return [newR, newG, newB, a];\r\n};\r\n\r\n// Amount: 0 - 100\r\nexport const setBrightness = ([r, g, b, a]: Color, amount: number): Color => {\r\n  const [h, s] = convert.rgb.hsl([r, g, b]);\r\n  const [newR, newG, newB] = convert.hsl.rgb([h, s, amount]);\r\n  return [newR, newG, newB, a];\r\n};\r\n\r\n/**\r\n * Turn a hue value (0 - 360) into a Color\r\n */\r\nexport const colorFromHue = (hue: number): Color => [\r\n  ...convert.hsl.rgb([hue, 100, 50]),\r\n  255,\r\n];\r\n\r\nexport const adjustSaturation = (color: Color, amount: number): Color => {\r\n  const [r, g, b, a] = color;\r\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\r\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\r\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\r\n  return [newR, newG, newB, a];\r\n};\r\n\r\n// Amount: -100 to 100\r\nexport const adjustBrightness = (color: Color, amount: number): Color => {\r\n  const d = (amount / 100) * 128;\r\n  const [r, g, b, a] = color;\r\n  return clampColor([r + d, g + d, b + d, a]);\r\n};\r\n\r\n// Amount: -100 to 100\r\nexport const adjustContrast = (color: Color, amount: number): Color => {\r\n  const d = amount / 100 + 1;\r\n  const [r, g, b, a] = color;\r\n  return clampColor([\r\n    d * (r - 128) + 128,\r\n    d * (g - 128) + 128,\r\n    d * (b - 128) + 128,\r\n    a,\r\n  ]);\r\n};\r\n\r\n/**\r\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\r\n */\r\nexport const colorDiff = (c1: Color, c2: Color): number => {\r\n  // Red-mean color diff algorithm\r\n  // https://en.wikipedia.org/wiki/Color_difference\r\n  const deltaRed = c1[0] - c2[0];\r\n  const deltaBlue = c1[1] - c2[1];\r\n  const deltaGreen = c1[2] - c2[2];\r\n  const rSomething = (c1[0] + c2[0]) / 2;\r\n\r\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\r\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\r\n  const gComponent = 4 * deltaGreen * deltaGreen;\r\n  // 765 = ~ difference between black and white pixels\r\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\r\n};\r\n\r\n/**\r\n * Returns a color between c1 and c2.\r\n * Amount is between 0 and 1.\r\n * An amount of 0 will return c1, and amount of 1 will return c2.\r\n */\r\nexport const linearInterpolation = ({\r\n  c1: [r1, g1, b1],\r\n  c2: [r2, g2, b2],\r\n  amount,\r\n}: {\r\n  c1: Color;\r\n  c2: Color;\r\n  amount: number;\r\n}): Color => {\r\n  return [\r\n    Math.floor((1 - amount) * r1 + amount * r2),\r\n    Math.floor((1 - amount) * g1 + amount * g2),\r\n    Math.floor((1 - amount) * b1 + amount * b2),\r\n    255,\r\n  ];\r\n};\r\n","// When in a web worker, the window isn't defined.\r\nexport const IS_WORKER = typeof window === 'undefined';\r\n","import type { CanvasData, Dimensions, FrameData, Color } from '~/domain/types';\r\nimport { toHexColor } from './color';\r\nimport { IS_WORKER } from './isWorker';\r\nimport { assert } from './misc';\r\n\r\nexport const createCanvas = ([width, height]: Dimensions): CanvasData => {\r\n  if (IS_WORKER) {\r\n    // Note that mobile does NOT support OffscreenCanvas.\r\n    // So if mobile, then we can not use web workers!\r\n    const canvas = new OffscreenCanvas(width, height);\r\n    const ctx = canvas.getContext('2d');\r\n    assert(ctx, 'Canvas not supported');\r\n    return { canvas, ctx };\r\n  } else {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    const ctx = canvas.getContext('2d');\r\n    assert(ctx, 'Canvas not supported');\r\n    return { canvas, ctx };\r\n  }\r\n};\r\n\r\n/** Converts a frame to a CanvasData */\r\nexport const frameToCanvas = ({\r\n  dimensions,\r\n  frame,\r\n}: {\r\n  dimensions: Dimensions;\r\n  frame: FrameData;\r\n}): CanvasData => {\r\n  const [width, height] = dimensions;\r\n  const { canvas, ctx } = createCanvas(dimensions);\r\n\r\n  const imageData = new ImageData(frame, width, height);\r\n\r\n  ctx.putImageData(imageData, 0, 0);\r\n\r\n  return { canvas, ctx };\r\n};\r\n\r\n/** Convert a CanvasData into a FrameData */\r\nexport const canvasToFrame = (canvasData: CanvasData): FrameData => {\r\n  const imageData = canvasData.ctx.getImageData(\r\n    0,\r\n    0,\r\n    canvasData.canvas.width,\r\n    canvasData.canvas.height\r\n  );\r\n  return imageData.data;\r\n};\r\n\r\n/**\r\n * Draws a frame onto the canvas.\r\n * This respects transforms applied to the canvas, such as scaling.\r\n */\r\nexport const drawImageOnCanvas = ({\r\n  ctx,\r\n  dimensions,\r\n  frame,\r\n}: {\r\n  ctx: OffscreenCanvasRenderingContext2D | CanvasRenderingContext2D;\r\n  dimensions: Dimensions;\r\n  frame: FrameData;\r\n}): void => {\r\n  ctx.drawImage(frameToCanvas({ dimensions, frame }).canvas, 0, 0);\r\n};\r\n\r\n/**\r\n * Allows you to apply a JS Canvas to an image.\r\n * Use the `preEffect` and `postEffect` functions to manipulate the image\r\n *  both before and after drawing the image to the canvas.\r\n */\r\nexport const applyCanvasFromFrame = ({\r\n  dimensions,\r\n  frame,\r\n  preEffect,\r\n  postEffect,\r\n}: {\r\n  dimensions: Dimensions;\r\n  frame: FrameData;\r\n  /** Manipulate the context *before* drawing the image. Set things like filters here */\r\n  preEffect?: (canvasData: CanvasData) => void;\r\n  /** Manipulate the context *after* drawing the image. Use this to draw on top of the image */\r\n  postEffect?: (canvasData: CanvasData) => void;\r\n}): FrameData => {\r\n  // Create a new Canvas using our existing image.\r\n  // We can then draw that onto a second canvas, which will have effects applied to it.\r\n  const canvasData = createCanvas(dimensions);\r\n\r\n  canvasData.ctx.save();\r\n  preEffect?.(canvasData);\r\n  canvasData.ctx.drawImage(frameToCanvas({ dimensions, frame }).canvas, 0, 0);\r\n  canvasData.ctx.restore();\r\n  postEffect?.(canvasData);\r\n\r\n  return canvasData.ctx.getImageData(0, 0, dimensions[0], dimensions[1]).data;\r\n};\r\n\r\n/**\r\n * Combines two canvases or frames together.\r\n * It's assumed that the foreground has some transparency to it.\r\n */\r\nexport const combineImages = ({\r\n  dimensions,\r\n  background,\r\n  foreground,\r\n}: {\r\n  dimensions: Dimensions;\r\n  background: FrameData | CanvasData;\r\n  foreground: FrameData | CanvasData;\r\n}): FrameData => {\r\n  const backgroundCanvas =\r\n    'canvas' in background\r\n      ? background\r\n      : frameToCanvas({\r\n          dimensions: dimensions,\r\n          frame: background,\r\n        });\r\n\r\n  const foregroundCanvas =\r\n    'canvas' in foreground\r\n      ? foreground\r\n      : frameToCanvas({\r\n          dimensions: dimensions,\r\n          frame: foreground,\r\n        });\r\n\r\n  backgroundCanvas.ctx.drawImage(foregroundCanvas.canvas, 0, 0);\r\n\r\n  return canvasToFrame(backgroundCanvas);\r\n};\r\n\r\nexport const applyFilter = (\r\n  canvas: CanvasData,\r\n  {\r\n    blur,\r\n    brightness,\r\n    contrast,\r\n    opacity,\r\n    saturation,\r\n    hueRotate,\r\n    sepia,\r\n    dropShadow,\r\n  }: {\r\n    /** Number of pixels */\r\n    blur?: number;\r\n    /** [0, 100) percent */\r\n    opacity?: number;\r\n    /** [0, 100) percent */\r\n    brightness?: number;\r\n    /** [0, 100) percent */\r\n    contrast?: number;\r\n    /** [0, 100) percent */\r\n    saturation?: number;\r\n    /** [0, 360) degrees */\r\n    hueRotate?: number;\r\n    /** [0, 100) percent */\r\n    sepia?: number;\r\n    dropShadow?: {\r\n      offsetX: number;\r\n      offsetY: number;\r\n      color: Color;\r\n      /** Positive number, defaults to 0 */\r\n      blurRadius?: number;\r\n    };\r\n  }\r\n): CanvasData => {\r\n  const shadow = dropShadow\r\n    ? [\r\n        `${dropShadow.offsetX}px`,\r\n        `${dropShadow.offsetY}px`,\r\n        `${dropShadow.blurRadius ?? 0}px`,\r\n        `${toHexColor(dropShadow.color)}`,\r\n      ].join(' ')\r\n    : null;\r\n\r\n  const filters = [\r\n    blur == null ? '' : `blur(${blur}px)`,\r\n    brightness == null ? '' : `brightness(${brightness}%)`,\r\n    contrast == null ? '' : `contrast(${contrast}%)`,\r\n    opacity == null ? '' : `opacity(${opacity}%)`,\r\n    saturation == null ? '' : `saturate(${saturation}%)`,\r\n    hueRotate == null ? '' : `hue-rotate(${hueRotate}deg)`,\r\n    sepia == null ? '' : `sepia(${sepia}%)`,\r\n    shadow == null ? '' : `drop-shadow(${shadow})`,\r\n  ].filter((x) => x.length > 0);\r\n\r\n  canvas.ctx.filter = filters.join(' ');\r\n\r\n  return canvas;\r\n};\r\n\r\nexport const applyTransform = (\r\n  canvas: CanvasData,\r\n  {\r\n    horizontalScale,\r\n    verticalScale,\r\n    horizontalSkew,\r\n    verticalSkew,\r\n    horizontalTranslation,\r\n    verticalTranslation,\r\n  }: {\r\n    horizontalScale?: number;\r\n    verticalScale?: number;\r\n    horizontalSkew?: number;\r\n    verticalSkew?: number;\r\n    horizontalTranslation?: number;\r\n    verticalTranslation?: number;\r\n  }\r\n): CanvasData => {\r\n  canvas.ctx.transform(\r\n    horizontalScale ?? 1,\r\n    verticalSkew ?? 0,\r\n    horizontalSkew ?? 0,\r\n    verticalScale ?? 1,\r\n    horizontalTranslation ?? 0,\r\n    verticalTranslation ?? 0\r\n  );\r\n  return canvas;\r\n};\r\n\r\n/**\r\n * Rotates a canvas a number of degrees.\r\n * 0 degrees points to the right, 90 degrees points up.\r\n */\r\nexport const applyRotation = (\r\n  canvas: CanvasData,\r\n  degrees: number\r\n): CanvasData => {\r\n  const offsetX = canvas.canvas.width / 2;\r\n  const offsetY = canvas.canvas.height / 2;\r\n  applyTransform(canvas, {\r\n    horizontalTranslation: offsetX,\r\n    verticalTranslation: offsetY,\r\n  });\r\n  const radians = -(degrees * Math.PI) / 180;\r\n  canvas.ctx.rotate(radians);\r\n  applyTransform(canvas, {\r\n    horizontalTranslation: -offsetX,\r\n    verticalTranslation: -offsetY,\r\n  });\r\n  return canvas;\r\n};\r\n\r\n/**\r\n * Scales the canvas a given amount for the x and or y axis.\r\n * A scale of 1 leaves the image unchanged.\r\n */\r\nexport const applyScale = (\r\n  canvas: CanvasData,\r\n  [x, y]: [number, number]\r\n): CanvasData => {\r\n  canvas.ctx.scale(x, y);\r\n  return canvas;\r\n};\r\n","import React from 'react';\r\nimport type { CanvasData, Coord } from '~/domain/types';\r\n\r\nexport type BezierTuple = [Coord, Coord];\r\n\r\nexport interface CanvasElementProps {\r\n  width: number;\r\n  height: number;\r\n  cursorIsPointer?: boolean;\r\n  onCanvasMount: (canvasData: CanvasData) => void;\r\n  onMouseDown?: (coord: Coord) => void;\r\n  onMouseMove?: (coord: Coord) => void;\r\n  onMouseUp?: (coord: Coord) => void;\r\n  onMouseLeave?: (coord: Coord) => void;\r\n}\r\n\r\nexport const CanvasElement: React.FC<CanvasElementProps> = ({\r\n  width,\r\n  height,\r\n  cursorIsPointer,\r\n  onCanvasMount,\r\n  onMouseDown: onMouseDownEvt,\r\n  onMouseUp: onMouseUpEvt,\r\n  onMouseMove: onMouseMoveEvt,\r\n  onMouseLeave: onMouseLeaveEvt,\r\n}) => {\r\n  const ref = React.useRef<HTMLCanvasElement>(null);\r\n  const isMounted = React.useRef(false);\r\n\r\n  React.useEffect(() => {\r\n    if (ref.current && !isMounted.current) {\r\n      const ctx = ref.current.getContext('2d');\r\n      if (ctx != null) {\r\n        onCanvasMount({ canvas: ref.current, ctx });\r\n        isMounted.current = true;\r\n      }\r\n    }\r\n  }, [isMounted, onCanvasMount]);\r\n\r\n  const onEvent =\r\n    (callback: undefined | ((c: Coord) => void)) =>\r\n    (evt: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (!ref.current || !callback) {\r\n        return;\r\n      }\r\n\r\n      const rect = ref.current.getBoundingClientRect();\r\n      const x = evt.clientX - rect.left;\r\n      const y = evt.clientY - rect.top;\r\n      setTimeout(() => callback([x, y]), 0);\r\n    };\r\n\r\n  const style = React.useMemo((): React.CSSProperties | undefined => {\r\n    if (cursorIsPointer) {\r\n      return { cursor: 'pointer' };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }, [cursorIsPointer]);\r\n\r\n  const onMouseDown = React.useMemo(\r\n    () => onEvent(onMouseDownEvt),\r\n    [onMouseDownEvt]\r\n  );\r\n  const onMouseUp = React.useMemo(() => onEvent(onMouseUpEvt), [onMouseUpEvt]);\r\n  const onMouseMove = React.useMemo(\r\n    () => onEvent(onMouseMoveEvt),\r\n    [onMouseMoveEvt]\r\n  );\r\n  const onMouseLeave = React.useMemo(\r\n    () => onEvent(onMouseLeaveEvt),\r\n    [onMouseLeaveEvt]\r\n  );\r\n\r\n  return (\r\n    <canvas\r\n      ref={ref}\r\n      width={width}\r\n      height={height}\r\n      onMouseDown={onMouseDown}\r\n      onMouseUp={onMouseUp}\r\n      onMouseMove={onMouseMove}\r\n      onMouseLeave={onMouseLeave}\r\n      style={style}\r\n    ></canvas>\r\n  );\r\n};\r\n","import { range } from 'remeda';\r\nimport type {\r\n  Color,\r\n  Coord,\r\n  Dimensions,\r\n  EffectFn,\r\n  EffectFnOpts,\r\n  FrameData,\r\n  Image,\r\n  Random,\r\n} from '~/domain/types';\r\nimport {\r\n  applyCanvasFromFrame,\r\n  applyTransform,\r\n  canvasToFrame,\r\n  createCanvas,\r\n  frameToCanvas,\r\n} from './canvas';\r\nimport {\r\n  clampColor,\r\n  TRANSPARENT_COLOR,\r\n  isPartiallyTransparent as isColorPartiallyTransparent,\r\n} from './color';\r\n\r\nexport const getPixelFromSource = (\r\n  dimensions: Dimensions,\r\n  image: FrameData,\r\n  coord: Coord\r\n): Color => {\r\n  const [width, height] = dimensions;\r\n  const [x, y] = coord;\r\n  if (x < 0 || x >= width || y < 0 || y >= height) {\r\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\r\n  }\r\n\r\n  const idx = getImageIndex(dimensions, x, y);\r\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\r\n};\r\n\r\n/********** Mapping Utils ***********/\r\n// Maps all frames from the original image into new frames.\r\n// Assumes all mapped frames are the same dimension as the original image.\r\nexport const mapFrames = (\r\n  image: Image,\r\n  cb: (\r\n    imageData: FrameData,\r\n    frameIndex: number,\r\n    frameCount: number\r\n  ) => FrameData\r\n): Image => ({\r\n  dimensions: image.dimensions,\r\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\r\n});\r\n\r\n/**\r\n * Maps the coordinates in a given shape into an image\r\n */\r\nexport const mapCoords = (\r\n  dimensions: Dimensions,\r\n  cb: (coord: Coord) => Color\r\n): FrameData => {\r\n  const [width, height] = dimensions;\r\n  const transformedImageData = new Uint8ClampedArray(width * height * 4);\r\n  for (let y = 0; y < height; y += 1) {\r\n    for (let x = 0; x < width; x += 1) {\r\n      const c = clampColor(cb([x, y]));\r\n      const idx = getImageIndex(dimensions, x, y);\r\n      transformedImageData[idx] = c[0];\r\n      transformedImageData[idx + 1] = c[1];\r\n      transformedImageData[idx + 2] = c[2];\r\n      transformedImageData[idx + 3] = c[3];\r\n    }\r\n  }\r\n  return transformedImageData;\r\n};\r\n\r\n/**\r\n * Combines mapFrames and mapCoords into one function.\r\n * Used for transforming each pixel in an image into another pixel.\r\n */\r\nexport const mapImage = <T>(\r\n  cb: (args: {\r\n    image: Image;\r\n    dimensions: Dimensions;\r\n    random: Random;\r\n    parameters: T;\r\n    coord: Coord;\r\n    frameCount: number;\r\n    frameIndex: number;\r\n    /** Between 0 and 1 */\r\n    animationProgress: number;\r\n    getSrcPixel: (coord: Coord) => Color;\r\n  }) => Color\r\n): EffectFn<T> => {\r\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\r\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\r\n      mapCoords(image.dimensions, (coord) =>\r\n        cb({\r\n          image,\r\n          dimensions: image.dimensions,\r\n          random,\r\n          parameters,\r\n          coord,\r\n          frameCount,\r\n          frameIndex,\r\n          animationProgress: frameIndex / frameCount,\r\n          getSrcPixel: (c: Coord) =>\r\n            getPixelFromSource(image.dimensions, imageData, c),\r\n        })\r\n      )\r\n    );\r\n};\r\n\r\n/**\r\n * Similar to mapImage, but the first argument pre-computes some things for\r\n *  each frame, which is then passed to the second callback function.\r\n * This is useful for performance (only compute things every frame rather than every pixel),\r\n *  and also allows you to generate some random value that will be the same for every frame.\r\n */\r\nexport const mapImageWithPrecompute = <T, R>(\r\n  compute: (args: {\r\n    image: Image;\r\n    dimensions: Dimensions;\r\n    random: Random;\r\n    parameters: T;\r\n    frameCount: number;\r\n    frameIndex: number;\r\n    /** Between 0 and 1 */\r\n    animationProgress: number;\r\n  }) => R,\r\n  cb: (args: {\r\n    computed: R;\r\n    image: Image;\r\n    dimensions: Dimensions;\r\n    random: Random;\r\n    parameters: T;\r\n    coord: Coord;\r\n    frameCount: number;\r\n    frameIndex: number;\r\n    /** Between 0 and 1 */\r\n    animationProgress: number;\r\n    getSrcPixel: (coord: Coord) => Color;\r\n  }) => Color\r\n): EffectFn<T> => {\r\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\r\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const computed = compute({\r\n        image,\r\n        dimensions: image.dimensions,\r\n        random,\r\n        parameters,\r\n        frameCount,\r\n        frameIndex,\r\n        animationProgress,\r\n      });\r\n\r\n      return mapCoords(image.dimensions, (coord) =>\r\n        cb({\r\n          computed,\r\n          image,\r\n          dimensions: image.dimensions,\r\n          random,\r\n          parameters,\r\n          coord,\r\n          frameCount,\r\n          frameIndex,\r\n          animationProgress,\r\n          getSrcPixel: (c: Coord) =>\r\n            getPixelFromSource(image.dimensions, imageData, c),\r\n        })\r\n      );\r\n    });\r\n};\r\n\r\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\r\n  (x + y * width) * 4;\r\n\r\n/**\r\n * Scales the image according to a coefficient\r\n * Coefficient should be greater than 0.\r\n * A coefficient of 1 equals no scaling.\r\n * The image will be centered.\r\n */\r\nexport const scaleImage = ({\r\n  image,\r\n  horizontalScale,\r\n  verticalScale,\r\n}: {\r\n  image: Image;\r\n  horizontalScale?: number;\r\n  verticalScale?: number;\r\n}): Image => {\r\n  const [width, height] = image.dimensions;\r\n  // Adjust how much the image is offset in order to keep it centered\r\n  const offsetX = (width / 2) * (horizontalScale ?? 1) - width / 2;\r\n  const offsetY = (height / 2) * (verticalScale ?? 1) - height / 2;\r\n  return mapFrames(image, (imageData) =>\r\n    applyCanvasFromFrame({\r\n      dimensions: image.dimensions,\r\n      frame: imageData,\r\n      preEffect: (canvasData) =>\r\n        applyTransform(canvasData, {\r\n          horizontalScale,\r\n          verticalScale,\r\n          horizontalTranslation: -offsetX,\r\n          verticalTranslation: -offsetY,\r\n        }),\r\n    })\r\n  );\r\n};\r\n\r\n/**\r\n * Resize the image to the given dimensions.\r\n * If `keepScale` is true, then the image will be automatically\r\n *  resized to keep match the new dimensions.\r\n * If false, then the image will remain the same size, and will be cropped\r\n *  if the new dimensions are smaller.\r\n */\r\nexport const resizeImage = ({\r\n  image,\r\n  newWidth,\r\n  newHeight,\r\n  keepScale,\r\n}: {\r\n  image: Image;\r\n  newWidth: number;\r\n  newHeight: number;\r\n  keepScale: boolean;\r\n}): Image => {\r\n  const newFrames = mapFrames(image, (frame) => {\r\n    const rootCanvas = createCanvas([newWidth, newHeight]);\r\n    const imgCanvas = frameToCanvas({ dimensions: image.dimensions, frame });\r\n\r\n    if (keepScale) {\r\n      // Just blow it up\r\n      rootCanvas.ctx.drawImage(imgCanvas.canvas, 0, 0, newWidth, newHeight);\r\n    } else {\r\n      // Keep the image the same size, but be sure to center it\r\n      const offsetX = newWidth / 2 - image.dimensions[0] / 2;\r\n      const offsetY = newHeight / 2 - image.dimensions[1] / 2;\r\n      rootCanvas.ctx.drawImage(\r\n        imgCanvas.canvas,\r\n        offsetX,\r\n        offsetY,\r\n        image.dimensions[0],\r\n        image.dimensions[1]\r\n      );\r\n    }\r\n\r\n    return canvasToFrame(rootCanvas);\r\n  });\r\n\r\n  return {\r\n    dimensions: [newWidth, newHeight],\r\n    frames: newFrames.frames,\r\n  };\r\n};\r\n\r\nexport const createNewImage = (args: {\r\n  frameCount: number;\r\n  dimensions: Dimensions;\r\n}): Image => ({\r\n  dimensions: args.dimensions,\r\n  frames: range(0, args.frameCount).map(\r\n    // 4 == bytes used per color (RGBA)\r\n    () => new Uint8ClampedArray(args.dimensions[0] * args.dimensions[1] * 4)\r\n  ),\r\n});\r\n\r\nexport const duplicateImage = (image: Image): Image => ({\r\n  dimensions: image.dimensions,\r\n  frames: image.frames.map((f) => new Uint8ClampedArray(f)),\r\n});\r\n\r\nexport const getPixel = (args: {\r\n  image: Image;\r\n  frameIndex: number;\r\n  coord: Coord;\r\n}) =>\r\n  getPixelFromSource(\r\n    args.image.dimensions,\r\n    args.image.frames[args.frameIndex],\r\n    args.coord\r\n  );\r\n\r\nexport const setPixel = (args: {\r\n  image: Image;\r\n  frameIndex: number;\r\n  coord: Coord;\r\n  color: Color;\r\n}) => {\r\n  const idx = getImageIndex(\r\n    args.image.dimensions,\r\n    args.coord[0],\r\n    args.coord[1]\r\n  );\r\n  const frame = args.image.frames[args.frameIndex];\r\n  frame[idx] = args.color[0];\r\n  frame[idx + 1] = args.color[1];\r\n  frame[idx + 2] = args.color[2];\r\n  frame[idx + 3] = args.color[3];\r\n};\r\n\r\nexport const changeFrameCount = (image: Image, frameCount: number): Image => {\r\n  const currentFrames = image.frames;\r\n\r\n  // Resulting image will contain frameCount frames.\r\n  // If the original image had fewer than that, then we'll\r\n  //  duplicate some frames to approximately slow the animation.\r\n  // If the original has more frames, then we'll discard some frames.\r\n  return {\r\n    dimensions: image.dimensions,\r\n    frames: range(0, frameCount).map((i) => {\r\n      const frameToCopy = Math.floor((i / frameCount) * currentFrames.length);\r\n      return currentFrames[frameToCopy];\r\n    }),\r\n  };\r\n};\r\n\r\nexport const isPartiallyTransparent = (image: Image): boolean => {\r\n  // Could probably optimize this to just read the image data arrays directly, for every 4th index\r\n  for (const frame of image.frames) {\r\n    for (let x = 0; x < image.dimensions[0]; x += 1) {\r\n      for (let y = 0; y < image.dimensions[1]; y += 1) {\r\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\r\n        if (isColorPartiallyTransparent(px)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n","// @ts-ignore\r\nimport getPixels from 'get-pixels';\r\nimport { parseGIF, decompressFrames } from 'gifuct-js';\r\nimport type { Dimensions, FrameData, Image } from '~/domain/types';\r\nimport { canvasToFrame, createCanvas } from './canvas';\r\nimport * as miscUtil from './misc';\r\n\r\nconst toArrayBuffer = (file: File): Promise<ArrayBuffer> =>\r\n  new Promise<ArrayBuffer>((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => resolve(reader.result as ArrayBuffer);\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n\r\nconst readGifFromFile = async (\r\n  file: File\r\n): Promise<{ image: Image; fps: number }> => {\r\n  const buffer = await toArrayBuffer(file);\r\n  const gif = parseGIF(buffer);\r\n\r\n  const dimensions: Dimensions = [gif.lsd.width, gif.lsd.height];\r\n  const finalCanvas = createCanvas(dimensions);\r\n\r\n  const frameDelays: number[] = [];\r\n\r\n  const frames = decompressFrames(gif, true).map(\r\n    (parsedFrame): Uint8ClampedArray => {\r\n      const delay = parsedFrame.delay;\r\n      if (typeof delay === 'number' && delay > 0) {\r\n        // Some gifs have undefined frame delays, despite the typings saying otherwise\r\n        frameDelays.push(delay);\r\n      }\r\n\r\n      // Disposal Type explanation https://www.matthewflickinger.com/lab/whatsinagif/animation_and_transparency.asp\r\n      // 0 = Not animated, so it doesn't matter\r\n      // 1 = Draw this frame onto the previous frame\r\n      // 2 = Draw onto a blank frame\r\n      if (parsedFrame.disposalType === 2) {\r\n        finalCanvas.ctx.clearRect(0, 0, dimensions[0], dimensions[1]);\r\n      }\r\n\r\n      const frameDims: Dimensions = [\r\n        parsedFrame.dims.width,\r\n        parsedFrame.dims.height,\r\n      ];\r\n\r\n      // This is somewhat stolen from the gifuct-js demo.js file\r\n      const patch = createCanvas(frameDims);\r\n      const imageData = patch.ctx.createImageData(frameDims[0], frameDims[1]);\r\n      imageData.data.set(parsedFrame.patch);\r\n      patch.ctx.putImageData(imageData, 0, 0);\r\n\r\n      finalCanvas.ctx.drawImage(\r\n        patch.canvas,\r\n        parsedFrame.dims.left,\r\n        parsedFrame.dims.top\r\n      );\r\n\r\n      return canvasToFrame(finalCanvas);\r\n    }\r\n  );\r\n\r\n  const averageDelay =\r\n    frameDelays.reduce((acc, val) => acc + val, 0) / frameDelays.length;\r\n\r\n  const fps = Math.ceil(1000 / averageDelay);\r\n\r\n  return {\r\n    image: { dimensions, frames },\r\n    fps,\r\n  };\r\n};\r\n\r\ninterface ReadResult {\r\n  image: Image;\r\n  dataUrl: string;\r\n  fps: number;\r\n}\r\n\r\nexport const readImage = async (\r\n  fileOrDataUrl: File | string\r\n): Promise<ReadResult> => {\r\n  let dataUrl: string;\r\n  let file: File;\r\n  if (typeof fileOrDataUrl === 'string') {\r\n    const fileType = getFileType(fileOrDataUrl);\r\n    file = dataUrlToFile({\r\n      dataUrl: fileOrDataUrl,\r\n      fname: `image.${fileType ?? 'gif'}`,\r\n    });\r\n    dataUrl = fileOrDataUrl;\r\n  } else {\r\n    file = fileOrDataUrl;\r\n    dataUrl = await miscUtil.blobOrFileToDataUrl(file);\r\n  }\r\n\r\n  const isGif = file.name.endsWith('.gif');\r\n\r\n  if (isGif) {\r\n    const { image, fps } = await readGifFromFile(file);\r\n    return {\r\n      dataUrl,\r\n      image,\r\n      fps,\r\n    };\r\n  }\r\n\r\n  const image = await new Promise<Image>((res, rej) =>\r\n    getPixels(\r\n      dataUrl,\r\n      (err: Error, results: { shape: number[]; data: FrameData }) => {\r\n        if (err) {\r\n          return rej(err);\r\n        }\r\n\r\n        if (results.shape.length === 3) {\r\n          const [width, height] = results.shape;\r\n          // Single frame\r\n          return res({\r\n            frames: [Uint8ClampedArray.from(results.data)],\r\n            dimensions: [width, height],\r\n          });\r\n        }\r\n\r\n        // Multiple frames, need to slice up the image data into numFrames slices\r\n        const [numFrames, width, height] = results.shape;\r\n        const sliceSize = width * height * 4;\r\n        const frames: Uint8ClampedArray[] = [];\r\n        for (let i = 0; i < numFrames; i += 1) {\r\n          const frame = results.data.subarray(\r\n            i * sliceSize,\r\n            (i + 1) * sliceSize\r\n          );\r\n          // Contrary to the TS types, the result of subarray returns a regular Uint8Array, NOT a clamped one!\r\n          frames.push(Uint8ClampedArray.from(frame));\r\n        }\r\n        return res({\r\n          frames,\r\n          dimensions: [width, height],\r\n        });\r\n      }\r\n    )\r\n  );\r\n\r\n  return {\r\n    image,\r\n    dataUrl,\r\n    fps: 20, // Default FPS\r\n  };\r\n};\r\n\r\nexport const getImageFromUrl = async (url: string): Promise<string> => {\r\n  const res = await fetch(url);\r\n  const contentType = res.headers.get('content-type');\r\n  if (!contentType) {\r\n    throw new Error('Unable to determine content type');\r\n  }\r\n\r\n  const arrayBuffer = await res.arrayBuffer();\r\n  const base64String = btoa(\r\n    new Uint8Array(arrayBuffer).reduce(\r\n      (data, byte) => data + String.fromCharCode(byte),\r\n      ''\r\n    )\r\n  );\r\n\r\n  return `data:${contentType};base64,${base64String}`;\r\n};\r\n\r\nfunction dataUrlToFile({\r\n  dataUrl,\r\n  fname,\r\n}: {\r\n  dataUrl: string;\r\n  fname: string;\r\n}): File {\r\n  const blob = miscUtil.dataURItoBlob(dataUrl);\r\n  return new File([blob], fname);\r\n}\r\n\r\nfunction getFileType(dataUrl: string): string | undefined {\r\n  const matched = dataUrl.match(/^data:image\\/(\\w+);/);\r\n  return matched?.[1];\r\n}\r\n","import React from 'react';\r\n\r\ninterface Props<T> {\r\n  value: T;\r\n  debounceMillis?: number;\r\n  onChange: (newValue: T) => void;\r\n}\r\n\r\nexport function useDebounce<T>({\r\n  value,\r\n  debounceMillis,\r\n  onChange,\r\n}: Props<T>): [T, (newT: T) => void] {\r\n  const [v, setV] = React.useState<T>(value);\r\n  const debounceRef = React.useRef<NodeJS.Timeout>();\r\n  const onValueChange = React.useCallback(\r\n    (newV: T) => {\r\n      setV(newV);\r\n      if (debounceRef.current != null) {\r\n        clearTimeout(debounceRef.current);\r\n      }\r\n      debounceRef.current = setTimeout(() => {\r\n        onChange(newV);\r\n      }, debounceMillis ?? 200);\r\n    },\r\n    [debounceMillis, onChange]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    // Listen to external changes to value\r\n    setV(value);\r\n  }, [value]);\r\n\r\n  return [v, onValueChange];\r\n}\r\n","import React from 'react';\r\nimport type { Dimensions } from '~/domain/types';\r\n\r\nconst MAX_SIZE = 220;\r\n\r\nexport interface GifProps {\r\n  src: string;\r\n  alt: string;\r\n  dimensions?: Dimensions;\r\n}\r\n\r\n/**\r\n * Returns a size that will make the image at most 300px width or tall,\r\n *  while preserving the aspect ratio.\r\n */\r\nconst calculateDimensions = (dimensions: Dimensions | undefined) => {\r\n  if (dimensions == null) {\r\n    // TODO This happens in image picker, where we don't have a parsed image.\r\n    // We can probably parse the image in the image picker instead of just using a URL.\r\n    return {\r\n      maxWidth: `${MAX_SIZE}px`,\r\n      maxHeight: `${MAX_SIZE}px`,\r\n      width: 128,\r\n    };\r\n  }\r\n\r\n  const [width, height] = dimensions;\r\n  const aspectRatio = height / width;\r\n  if (width > height) {\r\n    const maxWidth = MAX_SIZE;\r\n    const maxHeight = aspectRatio * MAX_SIZE;\r\n    // If width is bigger, then limit by width\r\n    return {\r\n      maxWidth: `${maxWidth}px`,\r\n      maxHeight: `${maxHeight}px`,\r\n      width: 128,\r\n      height: 128 * aspectRatio,\r\n    };\r\n  } else {\r\n    // Else, limit by height\r\n    const maxHeight = MAX_SIZE;\r\n    const maxWidth = (1 / aspectRatio) * MAX_SIZE;\r\n    return {\r\n      maxHeight: `${maxHeight}px`,\r\n      maxWidth: `${maxWidth}px`,\r\n      width: 128,\r\n      height: 128 * aspectRatio,\r\n    };\r\n  }\r\n};\r\n\r\nexport const Gif: React.FC<GifProps> = ({ src, alt, dimensions }) => (\r\n  <img\r\n    src={src}\r\n    alt={`gif-${alt}`}\r\n    style={calculateDimensions(dimensions)}\r\n  ></img>\r\n);\r\n","import { Button, Icon, Stack, Box, TextField } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { miscUtil, imageUtil, imageImportUtil } from '~/domain/utils';\r\nimport type { ImageEffectResult } from '~/domain/types';\r\nimport { Gif } from './Gif';\r\n\r\nconst parseFileName = (s: string): string => {\r\n  const parts = s.split('/'); // For URLs\r\n  return parts[parts.length - 1]; // Return the last segment\r\n};\r\n\r\ninterface ImagePickerProps {\r\n  currentImage?: ImageEffectResult;\r\n  name?: string;\r\n  width?: number;\r\n  height?: number;\r\n  onChange: (image: ImageEffectResult, fileName: string, fps: number) => void;\r\n}\r\n\r\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\r\n  currentImage,\r\n  onChange,\r\n}) => {\r\n  const [error, setError] = React.useState<string | undefined>();\r\n  return (\r\n    <Stack spacing={2} alignItems=\"center\">\r\n      <Stack direction=\"row\">\r\n        <TextField\r\n          label=\"URL\"\r\n          variant=\"outlined\"\r\n          fullWidth\r\n          error={!!error}\r\n          helperText={error}\r\n          onBlur={async (e) => {\r\n            const text = e.target.value;\r\n            try {\r\n              setError(undefined);\r\n\r\n              if (text.startsWith('data:')) {\r\n                // Data URL\r\n                const { image, fps } = await imageImportUtil.readImage(text);\r\n                onChange(\r\n                  {\r\n                    gif: text,\r\n                    image,\r\n                    gifWithBackgroundColor: text,\r\n                    partiallyTransparent:\r\n                      imageUtil.isPartiallyTransparent(image),\r\n                  },\r\n                  'image',\r\n                  fps\r\n                );\r\n                return;\r\n              }\r\n\r\n              if (!miscUtil.isUrl(text)) {\r\n                setError('Does not appear to be a valid URL');\r\n                return;\r\n              }\r\n              const gif = await imageImportUtil.getImageFromUrl(text);\r\n              const { image, fps } = await imageImportUtil.readImage(gif);\r\n              onChange(\r\n                {\r\n                  gif,\r\n                  image,\r\n                  gifWithBackgroundColor: gif,\r\n                  partiallyTransparent: imageUtil.isPartiallyTransparent(image),\r\n                },\r\n                parseFileName(text),\r\n                fps\r\n              );\r\n            } catch (err) {\r\n              console.error('Error importing url', err);\r\n              setError('Error importing url');\r\n            }\r\n          }}\r\n        />\r\n      </Stack>\r\n      <Box>OR</Box>\r\n      <Button\r\n        startIcon={<Icon>image</Icon>}\r\n        sx={{ maxWidth: '300px' }}\r\n        variant=\"contained\"\r\n        component=\"label\"\r\n      >\r\n        Upload an Image\r\n        <input\r\n          type=\"file\"\r\n          hidden\r\n          accept=\"image/png,image/jpg,image/jpeg,image/gif\"\r\n          name=\"source-image\"\r\n          onChange={async (event) => {\r\n            const files = Array.from(event.target.files ?? []);\r\n            const file = files[0];\r\n            if (file) {\r\n              const { dataUrl, image, fps } = await imageImportUtil.readImage(\r\n                file\r\n              );\r\n              onChange(\r\n                {\r\n                  gif: dataUrl,\r\n                  image,\r\n                  gifWithBackgroundColor: dataUrl,\r\n                  partiallyTransparent: imageUtil.isPartiallyTransparent(image),\r\n                },\r\n                parseFileName(file.name),\r\n                fps\r\n              );\r\n            }\r\n          }}\r\n        />\r\n      </Button>\r\n      {currentImage && (\r\n        <Gif\r\n          src={currentImage.gif}\r\n          dimensions={currentImage.image.dimensions}\r\n          alt=\"Source\"\r\n        />\r\n      )}\r\n    </Stack>\r\n  );\r\n};\r\n","// DO NOT IMPORT THIS FILE FROM A WEB WORKER\r\n// Web workers do not have access to `window`\r\n\r\nimport MobileDetect from 'mobile-detect';\r\n\r\nexport const IS_MOBILE =\r\n  new MobileDetect(window.navigator.userAgent).mobile() != null;\r\n\r\nexport const ENV = (window as any).ENV as 'DEV' | 'PROD';\r\n\r\nexport const debugLog = ENV === 'DEV' ? console.log : () => undefined;\r\n","import { Icon, Tooltip } from '@material-ui/core';\r\nimport React from 'react';\r\n\r\ninterface TooltipProps {\r\n  description?: string;\r\n}\r\n\r\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\r\n  description ? (\r\n    <Tooltip title={description}>\r\n      <Icon fontSize=\"small\" color=\"action\">\r\n        help\r\n      </Icon>\r\n    </Tooltip>\r\n  ) : null;\r\n","import type { JsonType, ParamFnDefault, ParamFunction } from '~/domain/types';\r\n\r\nexport const toParamFunction = <T extends JsonType>(\r\n  x: ParamFnDefault<T>\r\n): ParamFunction<T>['defaultValue'] => {\r\n  if (typeof x === 'function') {\r\n    return x;\r\n  }\r\n  return () => x;\r\n};\r\n","import React from 'react';\r\nimport * as R from 'remeda';\r\nimport { Box, Stack, Typography } from '@material-ui/core';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type {\r\n  Coord,\r\n  ParamFnDefault,\r\n  ParamFunction,\r\n  BezierTuple,\r\n  CanvasData,\r\n} from '~/domain/types';\r\nimport { CanvasElement, useDebounce, miscUtil } from '~/domain/utils';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst BezierParam: React.FC<{\r\n  name: string;\r\n  value: BezierTuple;\r\n  description?: string;\r\n  onChange: (v: BezierTuple) => void;\r\n}> = ({ name, value, description, onChange }) => {\r\n  const WIDTH = 64;\r\n  const HEIGHT = 64;\r\n  const MARKER_RADIUS = 5;\r\n  const DEBOUNCE_TIME = 200;\r\n\r\n  const [curValue, setCurValue] = useDebounce({\r\n    value,\r\n    onChange,\r\n    debounceMillis: DEBOUNCE_TIME,\r\n  });\r\n\r\n  const [latestMouseLocation, setLatestMouseLocation] = React.useState<Coord>([\r\n    0, 0,\r\n  ]);\r\n\r\n  const [canvasCtx, setCanvasCtx] = React.useState<CanvasData['ctx'] | null>(\r\n    null\r\n  );\r\n  const onCanvasMount = React.useCallback(({ ctx }: CanvasData) => {\r\n    setCanvasCtx(ctx);\r\n  }, []);\r\n\r\n  const [isDragging, setIsDragging] = React.useState<number | null>(null);\r\n\r\n  const closestPointIdx = React.useMemo(() => {\r\n    const distances = curValue.map((c, idx) => ({\r\n      idx,\r\n      coord: c,\r\n      distance: miscUtil.pointDistance(\r\n        [c[0] * WIDTH, c[1] * HEIGHT],\r\n        latestMouseLocation\r\n      ),\r\n    }));\r\n\r\n    const sorted = R.sortBy(distances, (d) => d.distance);\r\n    const closest = sorted[0];\r\n    return closest.distance < MARKER_RADIUS ? closest.idx : null;\r\n  }, [latestMouseLocation, curValue]);\r\n\r\n  React.useEffect(() => {\r\n    if (!canvasCtx) {\r\n      return;\r\n    }\r\n\r\n    canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\r\n\r\n    // Draw each dot - 4x4 circle\r\n    canvasCtx.fillStyle = 'red';\r\n    for (const coord of curValue) {\r\n      const x = coord[0] * WIDTH;\r\n      const y = coord[1] * HEIGHT;\r\n      canvasCtx.beginPath();\r\n      canvasCtx.ellipse(x, y, MARKER_RADIUS, MARKER_RADIUS, 0, 0, 2 * Math.PI);\r\n      canvasCtx.fill();\r\n    }\r\n\r\n    // Draw the bezier curve itself\r\n    canvasCtx.beginPath();\r\n    canvasCtx.moveTo(0, 0);\r\n    canvasCtx.strokeStyle = 'black';\r\n    canvasCtx.bezierCurveTo(\r\n      curValue[0][0] * WIDTH,\r\n      curValue[0][1] * HEIGHT,\r\n      curValue[1][0] * WIDTH,\r\n      curValue[1][1] * HEIGHT,\r\n      WIDTH,\r\n      HEIGHT\r\n    );\r\n    canvasCtx.stroke();\r\n  }, [curValue, canvasCtx]);\r\n\r\n  const onMouseDown = React.useCallback(() => {\r\n    setIsDragging(closestPointIdx);\r\n  }, [closestPointIdx]);\r\n\r\n  const onMouseUp = React.useCallback(() => {\r\n    setIsDragging(null);\r\n  }, []);\r\n\r\n  const onMouseMove = React.useCallback(\r\n    (c: Coord) => {\r\n      setLatestMouseLocation(c);\r\n\r\n      const newCoord: Coord = [\r\n        miscUtil.clamp(c[0] / WIDTH, 0, WIDTH),\r\n        miscUtil.clamp(c[1] / HEIGHT, 0, HEIGHT),\r\n      ];\r\n\r\n      if (isDragging === 0) {\r\n        setCurValue([newCoord, curValue[1]]);\r\n      } else if (isDragging === 1) {\r\n        setCurValue([curValue[0], newCoord]);\r\n      }\r\n    },\r\n    [isDragging, curValue, setCurValue]\r\n  );\r\n\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\r\n          {name}\r\n        </Typography>\r\n        <span style={{ paddingTop: '0.5rem' }}>\r\n          <HelpTooltip description={description} />\r\n        </span>\r\n        <Box border={1}>\r\n          <CanvasElement\r\n            width={WIDTH}\r\n            height={HEIGHT}\r\n            onCanvasMount={onCanvasMount}\r\n            onMouseDown={onMouseDown}\r\n            onMouseUp={onMouseUp}\r\n            onMouseLeave={onMouseUp}\r\n            onMouseMove={onMouseMove}\r\n            cursorIsPointer={closestPointIdx != null}\r\n          />\r\n        </Box>\r\n      </Stack>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function bezierParam(args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<BezierTuple>;\r\n  description?: string;\r\n}): ParamFunction<BezierTuple> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <BezierParam\r\n          name={args.name}\r\n          value={params.value}\r\n          onChange={params.onChange}\r\n          description={args.description}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import React from 'react';\r\nimport { Checkbox, Stack, Typography } from '@material-ui/core';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst CheckboxParam: React.FC<{\r\n  name: string;\r\n  value?: boolean;\r\n  description?: string;\r\n  onChange: (v: boolean) => void;\r\n}> = ({ name, value, description, onChange }) => {\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\r\n          {name}\r\n        </Typography>\r\n        <span style={{ paddingTop: '0.5rem' }}>\r\n          <HelpTooltip description={description} />\r\n        </span>\r\n        <Checkbox\r\n          aria-label={name}\r\n          checked={value}\r\n          onChange={(e) => onChange(e.target.checked)}\r\n        />\r\n      </Stack>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function checkboxParam(args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<boolean>;\r\n  description?: string;\r\n}): ParamFunction<boolean> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <CheckboxParam\r\n          name={args.name}\r\n          value={params.value}\r\n          onChange={params.onChange}\r\n          description={args.description}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import { Stack, Typography } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { SketchPicker } from 'react-color';\r\nimport { Expandable } from '~/components/Expandable';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { Color, ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { colorUtil } from '~/domain/utils';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\r\n  <div\r\n    style={{\r\n      width: '1.5em',\r\n      height: '1.5em',\r\n      backgroundColor: colorUtil.toHexColor(color),\r\n    }}\r\n  />\r\n);\r\n\r\nconst ColorPickerParam: React.FC<{\r\n  name: string;\r\n  value: Color;\r\n  description?: string;\r\n  onChange: (v: Color) => void;\r\n}> = ({ name, value, description, onChange }) => {\r\n  return (\r\n    <Expandable\r\n      mainEle={\r\n        <Stack direction=\"row\" spacing={4}>\r\n          <Typography variant=\"body2\">{name}</Typography>\r\n          <HelpTooltip description={description} />\r\n          {value && <ColorBox color={value} />}\r\n        </Stack>\r\n      }\r\n    >\r\n      <SketchPicker\r\n        disableAlpha={true}\r\n        presetColors={[]}\r\n        color={colorUtil.toHexColor(value)}\r\n        onChangeComplete={(c) => {\r\n          onChange(colorUtil.fromHexColor(c.hex));\r\n        }}\r\n      />\r\n    </Expandable>\r\n  );\r\n};\r\n\r\nexport function colorPickerParam(args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<Color>;\r\n  description?: string;\r\n}): ParamFunction<Color> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <ColorPickerParam\r\n          name={args.name}\r\n          value={params.value}\r\n          onChange={params.onChange}\r\n          description={args.description}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import {\r\n  FormControl,\r\n  MenuItem,\r\n  Select,\r\n  Stack,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst DropdownParam: React.FC<{\r\n  name: string;\r\n  options: readonly { name: string; value: string }[];\r\n  value?: any;\r\n  description?: string;\r\n  onChange: (v: string) => void;\r\n}> = ({ name, options, value, description, onChange }) => {\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <FormControl>\r\n        <Select\r\n          autoWidth\r\n          value={value}\r\n          onChange={(event) => onChange(event.target.value as string)}\r\n        >\r\n          {options.map((t) => (\r\n            <MenuItem key={t.value} value={t.value}>\r\n              {t.name}\r\n            </MenuItem>\r\n          ))}\r\n        </Select>\r\n      </FormControl>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function dropdownParam<T extends string>(args: {\r\n  name: string;\r\n  options: readonly { name: string; value: T }[];\r\n  description?: string;\r\n  defaultValue: ParamFnDefault<T>;\r\n}): ParamFunction<T> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <DropdownParam\r\n          name={args.name}\r\n          value={params.value}\r\n          options={args.options}\r\n          description={args.description}\r\n          onChange={params.onChange as any}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import {\r\n  FormControl,\r\n  FormHelperText,\r\n  Stack,\r\n  TextField,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\ntype ParsedParam<T> =\r\n  | { valid: true; value: T }\r\n  | { valid: false; reason: string };\r\n\r\nconst FloatParam: React.FC<{\r\n  name: string;\r\n  value: number;\r\n  description?: string;\r\n  parse: (s: string) => ParsedParam<number>;\r\n  onChange: (v: number) => void;\r\n}> = ({ name, value, description, parse, onChange }) => {\r\n  const [val, setVal] = React.useState(value.toString());\r\n  const [invalidText, setInvalidText] = React.useState('');\r\n\r\n  const onBlur = () => {\r\n    if (val === value.toString()) {\r\n      return; // Don't fire an onChange event if things haven't changed\r\n    }\r\n\r\n    const n = parse(val);\r\n    if (n.valid) {\r\n      setInvalidText('');\r\n      onChange(n.value);\r\n    } else {\r\n      setInvalidText(n.reason);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <FormControl>\r\n        <TextField\r\n          error={!!invalidText}\r\n          value={val}\r\n          onBlur={onBlur}\r\n          onChange={(e) => {\r\n            setVal(e.target.value);\r\n          }}\r\n        />\r\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\r\n      </FormControl>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport const floatParam = (args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<number>;\r\n  min?: number;\r\n  max?: number;\r\n  description?: string;\r\n}): ParamFunction<number> => ({\r\n  name: args.name,\r\n  defaultValue: toParamFunction(args.defaultValue),\r\n  fn: (params) => {\r\n    const { min, max } = args;\r\n    const parse = (s: string): ParsedParam<number> => {\r\n      const n = parseFloat(s);\r\n      if (isNaN(n) || n.toString() !== s) {\r\n        return { valid: false, reason: 'Must be a number' };\r\n      }\r\n      if (min !== undefined && n < min) {\r\n        return {\r\n          valid: false,\r\n          reason: `Must be greater than or equal to ${min}`,\r\n        };\r\n      }\r\n      if (max !== undefined && n > max) {\r\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\r\n      }\r\n      return { valid: true, value: n };\r\n    };\r\n\r\n    return (\r\n      <FloatParam\r\n        name={args.name}\r\n        description={args.description}\r\n        parse={parse}\r\n        onChange={params.onChange}\r\n        value={params.value}\r\n      />\r\n    );\r\n  },\r\n});\r\n","import { Stack, Typography } from '@material-ui/core';\r\nimport * as convert from 'color-convert';\r\nimport React from 'react';\r\nimport { HuePicker } from 'react-color';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { colorUtil } from '~/domain/utils';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst HuePickerParam: React.FC<{\r\n  name: string;\r\n  value?: number;\r\n  description?: string;\r\n  onChange: (v: number) => void;\r\n}> = ({ name, value, description, onChange }) => {\r\n  const hexColor = React.useMemo(\r\n    () =>\r\n      value === undefined\r\n        ? undefined\r\n        : colorUtil.toHexColor([...convert.hsl.rgb([value, 100, 50]), 255]),\r\n    [value]\r\n  );\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <HuePicker\r\n        color={hexColor}\r\n        // HSL is in [0-360, 0-100, 0-100]\r\n        onChangeComplete={({ hsl }) => onChange(hsl.h)}\r\n      />\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function huePickerParam(args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<number>;\r\n  description?: string;\r\n}): ParamFunction<number> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <HuePickerParam\r\n          name={args.name}\r\n          value={params.value}\r\n          onChange={params.onChange}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import { ImagePicker } from '~/components/ImagePicker';\r\nimport type { ImageEffectResult, ParamFunction } from '~/domain/types';\r\n\r\ninterface ImagePickerParamsProps {\r\n  name: string;\r\n}\r\n\r\n// Technically a ImageEffectResult but TS pukes for some reason\r\n// type ParamType = {\r\n//   gif: string;\r\n//   gifWithBackgroundColor: string | undefined;\r\n//   image: Image;\r\n//   partiallyTransparent: boolean;\r\n// };\r\n\r\n// Just a 1x1 black jpg. Surprisingly big!\r\nconst DEFAULT_IMAGE: ImageEffectResult = {\r\n  partiallyTransparent: false,\r\n  gif: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\r\n  gifWithBackgroundColor:\r\n    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\r\n  image: {\r\n    dimensions: [1, 1],\r\n    frames: [new Uint8ClampedArray([0, 0, 0, 255])],\r\n  },\r\n};\r\n\r\nexport function imagePickerParam({\r\n  name,\r\n}: ImagePickerParamsProps): ParamFunction<ImageEffectResult> {\r\n  return {\r\n    name,\r\n    defaultValue: () => DEFAULT_IMAGE,\r\n    fn: (params) => (\r\n      <ImagePicker\r\n        currentImage={params.value}\r\n        width={64}\r\n        height={64}\r\n        onChange={params.onChange}\r\n      />\r\n    ),\r\n  };\r\n}\r\n","import {\r\n  FormControl,\r\n  FormHelperText,\r\n  Stack,\r\n  TextField,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\ntype ParsedParam<T> =\r\n  | { valid: true; value: T }\r\n  | { valid: false; reason: string };\r\n\r\nconst IntParam: React.FC<{\r\n  name: string;\r\n  value: number;\r\n  description?: string;\r\n  parse: (s: string) => ParsedParam<number>;\r\n  onChange: (v: number) => void;\r\n}> = ({ name, value, description, parse, onChange }) => {\r\n  const [val, setVal] = React.useState(value.toString());\r\n  const [invalidText, setInvalidText] = React.useState('');\r\n\r\n  const onBlur = () => {\r\n    if (val === value.toString()) {\r\n      return; // Don't fire an onChange event if things haven't changed\r\n    }\r\n    const n = parse(val);\r\n    if (n.valid) {\r\n      setInvalidText('');\r\n      onChange(n.value);\r\n    } else {\r\n      setInvalidText(n.reason);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <FormControl>\r\n        <TextField\r\n          error={!!invalidText}\r\n          value={val}\r\n          onBlur={onBlur}\r\n          onChange={(e) => {\r\n            setVal(e.target.value);\r\n          }}\r\n        />\r\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\r\n      </FormControl>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport const intParam = (args: {\r\n  name: string;\r\n  defaultValue: ParamFnDefault<number>;\r\n  min?: number;\r\n  max?: number;\r\n  description?: string;\r\n}): ParamFunction<number> => ({\r\n  name: args.name,\r\n  defaultValue: toParamFunction(args.defaultValue),\r\n  fn: (params) => {\r\n    const { min, max } = args;\r\n    const parse = (s: string): ParsedParam<number> => {\r\n      const n = parseInt(s, 10);\r\n      if (isNaN(n) || n.toString() !== s) {\r\n        return { valid: false, reason: 'Must be an integer' };\r\n      }\r\n      if (min !== undefined && n < min) {\r\n        return {\r\n          valid: false,\r\n          reason: `Must be greater than or equal to ${min}`,\r\n        };\r\n      }\r\n      if (max !== undefined && n > max) {\r\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\r\n      }\r\n      return { valid: true, value: n };\r\n    };\r\n\r\n    return (\r\n      <IntParam\r\n        name={args.name}\r\n        description={args.description}\r\n        parse={parse}\r\n        onChange={params.onChange}\r\n        value={params.value}\r\n      />\r\n    );\r\n  },\r\n});\r\n","import {\r\n  FormControl,\r\n  FormControlLabel,\r\n  Radio,\r\n  RadioGroup,\r\n  Stack,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst RadioParam: React.FC<{\r\n  name: string;\r\n  options: readonly { name: string; value: string }[];\r\n  value: string;\r\n  description?: string;\r\n  onChange: (s: string) => void;\r\n}> = ({ name, options, value, description, onChange }) => {\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <FormControl component=\"fieldset\">\r\n        <RadioGroup\r\n          aria-label={name}\r\n          defaultValue={value}\r\n          onChange={(event) => onChange(event.target.value)}\r\n        >\r\n          {options.map((t) => (\r\n            <FormControlLabel\r\n              value={t.value}\r\n              control={<Radio />}\r\n              label={t.name}\r\n              key={t.value}\r\n            />\r\n          ))}\r\n        </RadioGroup>\r\n      </FormControl>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function radioParam<T extends string>(args: {\r\n  name: string;\r\n  options: readonly { name: string; value: T }[];\r\n  description?: string;\r\n  defaultValue: ParamFnDefault<T>;\r\n}): ParamFunction<T> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <RadioParam\r\n          name={args.name}\r\n          value={params.value}\r\n          options={args.options}\r\n          description={args.description}\r\n          onChange={(s) => params.onChange(s as T)}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import { Slider, Stack, Typography } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { useDebounce } from '~/domain/utils/useDebounce';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst SliderParam: React.FC<{\r\n  name: string;\r\n  min: number;\r\n  max: number;\r\n  step?: number;\r\n  value: number;\r\n  description?: string;\r\n  onChange: (v: number) => void;\r\n}> = ({ name, value, min, max, step, description, onChange }) => {\r\n  const [val, setVal] = useDebounce({\r\n    value,\r\n    onChange,\r\n    debounceMillis: 500,\r\n  });\r\n\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <Stack\r\n        direction=\"row\"\r\n        spacing={2}\r\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\r\n      >\r\n        <Slider\r\n          aria-label={name}\r\n          value={val}\r\n          step={step}\r\n          valueLabelDisplay=\"off\"\r\n          getAriaValueText={(x) => x.toString()}\r\n          min={min}\r\n          max={max}\r\n          onChange={(e, value) => {\r\n            setVal(value as number);\r\n          }}\r\n        />\r\n        <Typography variant=\"body2\">{val}</Typography>\r\n      </Stack>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport function sliderParam(args: {\r\n  name: string;\r\n  min: number;\r\n  max: number;\r\n  step?: number;\r\n  defaultValue: ParamFnDefault<number>;\r\n  description?: string;\r\n}): ParamFunction<number> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <SliderParam\r\n          name={args.name}\r\n          value={params.value}\r\n          onChange={params.onChange}\r\n          min={args.min}\r\n          max={args.max}\r\n          step={args.step}\r\n          description={args.description}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\nconst TextParam: React.FC<{\r\n  name: string;\r\n  value: string;\r\n  description?: string;\r\n  onChange: (v: string) => void;\r\n}> = ({ name, value, description, onChange }) => {\r\n  const [val, setVal] = React.useState(value);\r\n\r\n  return (\r\n    <Stack spacing={1}>\r\n      <Stack direction=\"row\" spacing={1}>\r\n        <Typography variant=\"body2\">{name}</Typography>\r\n        <HelpTooltip description={description} />\r\n      </Stack>\r\n      <FormControl>\r\n        <TextField\r\n          value={val}\r\n          onChange={(e) => setVal(e.target.value)}\r\n          onBlur={() => {\r\n            if (val.length > 0) {\r\n              onChange(val);\r\n            }\r\n          }}\r\n        />\r\n      </FormControl>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport const textParam = (args: {\r\n  name: string;\r\n  description?: string;\r\n  defaultValue: ParamFnDefault<string>;\r\n}): ParamFunction<string> => ({\r\n  name: args.name,\r\n  defaultValue: toParamFunction(args.defaultValue),\r\n  fn: (params) => (\r\n    <TextParam\r\n      name={args.name}\r\n      description={args.description}\r\n      onChange={params.onChange}\r\n      value={params.value}\r\n    />\r\n  ),\r\n});\r\n","import {\r\n  Button,\r\n  Icon,\r\n  IconButton,\r\n  Paper,\r\n  Stack,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport React from 'react';\r\nimport { HelpTooltip } from '~/components/HelpTooltip';\r\nimport type { JsonType, ParamFnDefault, ParamFunction } from '~/domain/types';\r\nimport { toParamFunction } from './utils';\r\n\r\ninterface VariableLengthProps<T extends JsonType> {\r\n  name: string;\r\n  newParamText: string;\r\n  createNewParam: () => ParamFunction<T>;\r\n  value: T[];\r\n  description?: string;\r\n  onChange: (v: T) => void;\r\n}\r\n\r\ntype ParamState = { param: ParamFunction<any>; pValue: any };\r\n\r\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\r\n  name,\r\n  newParamText,\r\n  createNewParam,\r\n  value,\r\n  description,\r\n  onChange,\r\n}) => {\r\n  const [params, setParams] = React.useState<ParamState[]>(\r\n    value.map((v) => ({ param: createNewParam(), pValue: v }))\r\n  );\r\n  return (\r\n    <Paper>\r\n      <Stack spacing={1}>\r\n        <Stack direction=\"row\" spacing={1}>\r\n          <Typography variant=\"body2\">{name}</Typography>\r\n          <HelpTooltip description={description} />\r\n        </Stack>\r\n        {params.map(({ param, pValue }, idx) => {\r\n          const ele = param.fn({\r\n            value: pValue,\r\n            onChange: (newValue) => {\r\n              const p = params.map((oldP, i) => {\r\n                if (idx === i) {\r\n                  return {\r\n                    param,\r\n                    pValue: newValue,\r\n                  };\r\n                }\r\n                return oldP;\r\n              });\r\n              setParams(p);\r\n              onChange(p.map((n) => n.pValue));\r\n            },\r\n          });\r\n\r\n          return (\r\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\r\n              <IconButton\r\n                onClick={() => {\r\n                  const newParams = params.filter((x, i) => i !== idx);\r\n                  setParams(newParams);\r\n                  onChange(newParams.map((n) => n.pValue));\r\n                }}\r\n                style={{\r\n                  visibility:\r\n                    idx === 0 /* Hide delete on first item */\r\n                      ? 'hidden'\r\n                      : undefined,\r\n                }}\r\n              >\r\n                <Icon>delete</Icon>\r\n              </IconButton>\r\n              {ele}\r\n            </Stack>\r\n          );\r\n        })}\r\n        <Button\r\n          variant=\"contained\"\r\n          onClick={() => {\r\n            const p = createNewParam();\r\n            const newParams: ParamState[] = [\r\n              ...params,\r\n              {\r\n                param: p,\r\n                pValue: p.defaultValue(),\r\n              },\r\n            ];\r\n            setParams(newParams);\r\n            const vals = newParams.map((n) => n.pValue);\r\n            onChange(vals);\r\n          }}\r\n        >\r\n          {newParamText}\r\n        </Button>\r\n      </Stack>\r\n    </Paper>\r\n  );\r\n};\r\n\r\nexport function variableLengthParam<T extends JsonType>(args: {\r\n  name: string;\r\n  newParamText: string;\r\n  createNewParam: () => ParamFunction<T>;\r\n  description?: string;\r\n  defaultValue: ParamFnDefault<T[]>;\r\n}): ParamFunction<T[]> {\r\n  return {\r\n    name: args.name,\r\n    defaultValue: toParamFunction(args.defaultValue),\r\n    fn: (params) => {\r\n      return (\r\n        <VariableLengthParam\r\n          name={args.name}\r\n          newParamText={args.newParamText}\r\n          value={params.value}\r\n          createNewParam={args.createNewParam}\r\n          description={args.description}\r\n          onChange={params.onChange}\r\n        />\r\n      );\r\n    },\r\n  };\r\n}\r\n","import type {\r\n  ParamFunction,\r\n  EffectFn,\r\n  Effect,\r\n  ParamType,\r\n  EffectGroup,\r\n} from '~/domain/types';\r\n\r\nexport const buildEffect = <T extends readonly ParamFunction<any>[]>(args: {\r\n  name: string;\r\n  group: EffectGroup;\r\n  params: T;\r\n  description: string;\r\n  secondaryDescription?: string;\r\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\r\n  disabled?: boolean;\r\n  groupOrder?: number;\r\n  requiresAnimation?: true;\r\n}): Effect<T> => ({\r\n  name: args.name,\r\n  group: args.group,\r\n  params: args.params,\r\n  description: args.description,\r\n  secondaryDescription: args.secondaryDescription,\r\n  fn: args.fn,\r\n  disabled: args.disabled ?? false,\r\n  groupOrder: args.groupOrder,\r\n  requiresAnimation: args.requiresAnimation,\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const adjustImage = buildEffect({\r\n  name: 'Adjust Image',\r\n  group: 'Image',\r\n  groupOrder: 999,\r\n  description: 'Change the dimensions, brightness, contrast etc.',\r\n  params: [\r\n    intParam({\r\n      name: 'Width',\r\n      description:\r\n        'Set to 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\r\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\r\n      min: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Height',\r\n      description:\r\n        'Set to 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\r\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\r\n      min: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Brightness',\r\n      min: -100,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Contrast',\r\n      min: -100,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Saturation',\r\n      min: -100,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Sepia',\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 0,\r\n    }),\r\n  ] as const,\r\n  fn: ({\r\n    image,\r\n    parameters: [\r\n      resizeToWidth,\r\n      resizeToHeight,\r\n      brightness,\r\n      contrast,\r\n      saturation,\r\n      sepia,\r\n    ],\r\n  }) => {\r\n    const [oldWidth, oldHeight] = image.dimensions;\r\n\r\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\r\n\r\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\r\n    const newWidth =\r\n      hasScaleChange && resizeToWidth === 0\r\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\r\n        : resizeToWidth;\r\n    const newHeight =\r\n      hasScaleChange && resizeToHeight === 0\r\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\r\n        : resizeToHeight;\r\n\r\n    // Use this to figure out when we should optimally resize the image\r\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\r\n\r\n    let currImage = image;\r\n\r\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\r\n    if (hasScaleChange && !isBiggerImage) {\r\n      currImage = imageUtil.resizeImage({\r\n        image: currImage,\r\n        newWidth,\r\n        newHeight,\r\n        keepScale: true,\r\n      });\r\n    }\r\n\r\n    currImage = imageUtil.mapFrames(currImage, (imageData) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: currImage.dimensions,\r\n        frame: imageData,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, {\r\n            brightness: brightness + 100,\r\n            contrast: contrast + 100,\r\n            saturation: saturation + 100,\r\n            sepia: sepia,\r\n          }),\r\n      })\r\n    );\r\n\r\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\r\n    if (hasScaleChange && isBiggerImage) {\r\n      currImage = imageUtil.resizeImage({\r\n        image: currImage,\r\n        newWidth,\r\n        newHeight,\r\n        keepScale: true,\r\n      });\r\n    }\r\n\r\n    return currImage;\r\n  },\r\n});\r\n","import { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const backgroundColor = buildEffect({\r\n  name: 'Background Color',\r\n  group: 'Colors',\r\n  description: 'Change all transparent pixels to the given color',\r\n  params: [\r\n    colorPickerParam({\r\n      name: 'Color',\r\n      defaultValue: colorUtil.fromHexColor('#000000'),\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [color, opacity] }) =>\r\n    imageUtil.mapFrames(image, (frame) => {\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background: imageUtil.mapCoords(image.dimensions, () => color),\r\n        foreground,\r\n      });\r\n    }),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { checkboxParam, imagePickerParam, radioParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const backgroundImage = buildEffect({\r\n  name: 'Background Image',\r\n  group: 'Image',\r\n  description: 'Select another image to be used as a background or foreground',\r\n  secondaryDescription:\r\n    'If the selected image is animated, this will speed up/slow down ' +\r\n    'the animation to match the original image',\r\n  params: [\r\n    imagePickerParam({\r\n      name: 'Image',\r\n    }),\r\n    radioParam<'background' | 'foreground'>({\r\n      name: 'Type',\r\n      defaultValue: 'background',\r\n      options: [\r\n        {\r\n          name: 'Background',\r\n          value: 'background',\r\n        },\r\n        {\r\n          name: 'Foreground',\r\n          value: 'foreground',\r\n        },\r\n      ],\r\n    }),\r\n    checkboxParam({\r\n      name: 'Scale Image',\r\n      defaultValue: false,\r\n      description:\r\n        'If true, the new image will be scaled to fit the dimensions of the original image',\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [otherImagePreResize, type, keepScale] }) => {\r\n    const otherImage = imageUtil.resizeImage({\r\n      image: otherImagePreResize.image,\r\n      newWidth: image.dimensions[0],\r\n      newHeight: image.dimensions[1],\r\n      keepScale,\r\n    });\r\n\r\n    return imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n\r\n      const thisFrameCanvas = canvasUtil.frameToCanvas({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n      });\r\n\r\n      const otherImageFrameIndex = Math.floor(\r\n        animationProgress * otherImage.frames.length\r\n      );\r\n      const otherFrameCanvas = canvasUtil.frameToCanvas({\r\n        dimensions: otherImage.dimensions,\r\n        frame: otherImage.frames[otherImageFrameIndex],\r\n      });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background: type === 'background' ? otherFrameCanvas : thisFrameCanvas,\r\n        foreground: type === 'background' ? thisFrameCanvas : otherFrameCanvas,\r\n      });\r\n    });\r\n  },\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const blur = buildEffect({\r\n  name: 'Blur',\r\n  group: 'Transform',\r\n  description: 'Blurs the image',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Amount',\r\n      defaultValue: 2,\r\n      min: 0,\r\n      max: 20,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [amount] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, { blur: amount }),\r\n      })\r\n    ),\r\n});\r\n","import { imageUtil, miscUtil } from '~/domain/utils';\r\nimport { bezierParam, intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const bounce = buildEffect({\r\n  name: 'Bounce',\r\n  group: 'Transform',\r\n  description: 'Make the image bounce up and down',\r\n  requiresAnimation: true,\r\n  params: [\r\n    intParam({\r\n      name: 'Bounce Height',\r\n      description: 'Positive number',\r\n      defaultValue: (image) =>\r\n        image ? Math.floor(image.dimensions[1] / 10) : 10,\r\n      min: 0,\r\n    }),\r\n    bezierParam({\r\n      name: 'Easing',\r\n      defaultValue: miscUtil.LINEAR_BEZIER,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress, parameters: [height, easing] }) => {\r\n      const b = miscUtil.bezierCurve(easing, true)(animationProgress);\r\n      return {\r\n        yOffset: Math.round(height * b),\r\n      };\r\n    },\r\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\r\n      getSrcPixel([x, y + yOffset])\r\n  ),\r\n});\r\n","import { concat, drop, pipe, reverse } from 'remeda';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const bounceAnimation = buildEffect({\r\n  name: 'Bounce Animation',\r\n  group: 'Animation',\r\n  description: 'When the animation finishes, it will be replayed in reverse',\r\n  secondaryDescription: 'This doubles the number of animation frames.',\r\n  requiresAnimation: true,\r\n  params: [],\r\n  fn: ({ image }) => ({\r\n    dimensions: image.dimensions,\r\n    frames: concat(\r\n      image.frames,\r\n      pipe(image.frames, drop(1), reverse(), drop(1))\r\n    ),\r\n  }),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const circle = buildEffect({\r\n  name: 'Circle',\r\n  group: 'Transform',\r\n  description: 'Make the image move in a circular pattern',\r\n  requiresAnimation: true,\r\n  params: [\r\n    intParam({\r\n      name: 'Radius',\r\n      description: 'Positive number',\r\n      defaultValue: (image) =>\r\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\r\n      min: 0,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress, parameters: [radius] }) => ({\r\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\r\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\r\n    }),\r\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\r\n      getSrcPixel([x + xOffset, y + yOffset])\r\n  ),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { bezierParam, sliderParam } from '~/params';\r\nimport { miscUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const changingFocus = buildEffect({\r\n  name: 'Changing Focus',\r\n  group: 'Image',\r\n  description: 'Changes the focus of the image over time',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Max Blur',\r\n      defaultValue: 50,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n    bezierParam({\r\n      name: 'Curve',\r\n      defaultValue: [\r\n        [0.25, 0.75],\r\n        [0.75, 0.25],\r\n      ],\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [amount, curve] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) => {\r\n          const progress = frameIndex / (frameCount - 1);\r\n          const blur = Math.round(\r\n            miscUtil.bezierCurve(curve, true)(progress) * (amount / 10)\r\n          );\r\n          return canvasUtil.applyFilter(canvasData, { blur });\r\n        },\r\n      })\r\n    ),\r\n});\r\n","import { range } from 'remeda';\r\nimport { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, variableLengthParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst NUM_DEFAULT_COLORS = 6;\r\nconst DEFAULT_COLORS = range(0, NUM_DEFAULT_COLORS).map((v) =>\r\n  colorUtil.setBrightness(\r\n    colorUtil.fromHexColor('#98651B'),\r\n    (1 - v / NUM_DEFAULT_COLORS) * 100\r\n  )\r\n);\r\n\r\nexport const colorPalette = buildEffect({\r\n  name: 'Color Palette',\r\n  group: 'Colors',\r\n  description: 'Change all colors in the image to a set palette.',\r\n  secondaryDescription:\r\n    'For instance, the lightest colors in the source image will ' +\r\n    'be replaced by the first color, and the darkest colors in the source image will be ' +\r\n    'replaced by the last color, etc',\r\n  params: [\r\n    variableLengthParam({\r\n      name: 'Palette',\r\n      newParamText: 'New Color',\r\n      defaultValue: DEFAULT_COLORS,\r\n      createNewParam: () =>\r\n        colorPickerParam({\r\n          name: 'Color',\r\n          defaultValue: DEFAULT_COLORS[0],\r\n        }),\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(({ coord, getSrcPixel, parameters: [palette] }) => {\r\n    const src = getSrcPixel(coord);\r\n    if (colorUtil.isTransparent(src)) {\r\n      return src;\r\n    }\r\n\r\n    const gray = 255 - colorUtil.getAveragePixelValue(src);\r\n    const paletteIndex = Math.floor((gray / 256) * palette.length);\r\n    return palette[paletteIndex];\r\n  }),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, sliderParam, variableLengthParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst DEFAULT_COLORS = [\r\n  '#FF8D8B',\r\n  '#FED689',\r\n  '#88FF89',\r\n  '#87FFFF',\r\n  '#8BB5FE',\r\n  '#D78CFF',\r\n  '#FF8CFF',\r\n  '#FF68F7',\r\n  '#FE6CB7',\r\n  '#FF6968',\r\n].map(colorUtil.fromHexColor);\r\n\r\nexport const colors = buildEffect({\r\n  name: 'Colors',\r\n  group: 'Colors',\r\n  description: 'Make the image flash different colors of your choosing',\r\n  secondaryDescription: 'Increase the brightness to increase the effect',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Brightness Increase',\r\n      defaultValue: 0,\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n    }),\r\n    variableLengthParam({\r\n      name: 'Colors',\r\n      newParamText: 'New Color',\r\n      defaultValue: DEFAULT_COLORS,\r\n      createNewParam: () =>\r\n        colorPickerParam({\r\n          name: 'Color',\r\n          defaultValue: DEFAULT_COLORS[0],\r\n        }),\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress, parameters: [brightnessIncrease, colors] }) => ({\r\n      brightnessIncrease,\r\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\r\n    }),\r\n    ({ computed: { brightnessIncrease, chosenColor }, coord, getSrcPixel }) => {\r\n      const srcPixel = getSrcPixel(coord);\r\n\r\n      if (colorUtil.isTransparent(srcPixel)) {\r\n        return [0, 0, 0, 0];\r\n      }\r\n\r\n      const brightnessAdjusted =\r\n        brightnessIncrease > 0\r\n          ? colorUtil.adjustBrightness(srcPixel, brightnessIncrease)\r\n          : srcPixel;\r\n      const gray = colorUtil.getAveragePixelValue(brightnessAdjusted);\r\n\r\n      return [\r\n        (gray * chosenColor[0]) / 255,\r\n        (gray * chosenColor[1]) / 255,\r\n        (gray * chosenColor[2]) / 255,\r\n        255,\r\n      ];\r\n    }\r\n  ),\r\n});\r\n","import { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, sliderParam, variableLengthParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst DEFAULT_COLORS = [\r\n  '#FF8D8B',\r\n  '#FED689',\r\n  '#88FF89',\r\n  '#87FFFF',\r\n  '#8BB5FE',\r\n  '#D78CFF',\r\n  '#FF8CFF',\r\n  '#FF68F7',\r\n  '#FE6CB7',\r\n  '#FF6968',\r\n].map(colorUtil.fromHexColor);\r\n\r\nexport const colorsBackground = buildEffect({\r\n  name: 'Colors Background',\r\n  group: 'Colors',\r\n  description:\r\n    'Transparent pixels will flash different colors of your choosing',\r\n  params: [\r\n    variableLengthParam({\r\n      name: 'Colors',\r\n      newParamText: 'New Color',\r\n      defaultValue: DEFAULT_COLORS,\r\n      createNewParam: () =>\r\n        colorPickerParam({\r\n          name: 'Color',\r\n          defaultValue: DEFAULT_COLORS[0],\r\n        }),\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [colors, opacity] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const bgColor = colors[Math.floor(animationProgress * colors.length)];\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background: imageUtil.mapCoords(image.dimensions, () => bgColor),\r\n        foreground,\r\n      });\r\n    }),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { floatParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const doubleVision = buildEffect({\r\n  name: 'Double Vision',\r\n  group: 'Misc',\r\n  description: 'See double',\r\n  requiresAnimation: true,\r\n  params: [\r\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress, parameters: [amplitude] }) => ({\r\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\r\n    }),\r\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\r\n      const dir = x % 2 === 0 ? -1 : 1;\r\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\r\n    }\r\n  ),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, sliderParam, intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const dropShadow = buildEffect({\r\n  name: 'Drop Shadow',\r\n  group: 'Misc',\r\n  description: 'Adds a drop shadow effect to the image',\r\n  params: [\r\n    intParam({\r\n      name: 'Offset X',\r\n      defaultValue: 10,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      defaultValue: 10,\r\n    }),\r\n    sliderParam({\r\n      name: 'Blur Radius',\r\n      min: 0,\r\n      max: 20,\r\n      step: 1,\r\n      defaultValue: 0,\r\n    }),\r\n    colorPickerParam({\r\n      name: 'Shadow Color',\r\n      defaultValue: [0, 0, 0, 0],\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [offsetX, offsetY, blurRadius, color] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, {\r\n            dropShadow: {\r\n              offsetX,\r\n              offsetY,\r\n              blurRadius,\r\n              color,\r\n            },\r\n          }),\r\n      })\r\n    ),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const dualHue = buildEffect({\r\n  name: 'Dual Hue',\r\n  group: 'Colors',\r\n  description:\r\n    'The colors of the image will transition from one color to another',\r\n  params: [\r\n    colorPickerParam({\r\n      name: 'Color 1',\r\n      defaultValue: [255, 0, 0, 1],\r\n    }),\r\n    colorPickerParam({\r\n      name: 'Color 2',\r\n      defaultValue: [0, 255, 0, 1],\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({ coord, getSrcPixel, parameters: [color1, color2] }) => {\r\n      const src = getSrcPixel(coord);\r\n      if (colorUtil.isTransparent(src)) {\r\n        return src;\r\n      }\r\n\r\n      const amount = colorUtil.getAveragePixelValue(src) / 256;\r\n      return colorUtil.linearInterpolation({ c1: color1, c2: color2, amount });\r\n    }\r\n  ),\r\n});\r\n","import { imageUtil, miscUtil } from '~/domain/utils';\r\nimport { bezierParam, intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const expand = buildEffect({\r\n  name: 'Expand',\r\n  group: 'Transform',\r\n  description: 'Make the image grow and shrink',\r\n  requiresAnimation: true,\r\n  params: [\r\n    intParam({\r\n      name: 'Radius',\r\n      description: 'Positive number',\r\n      defaultValue: (image) =>\r\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\r\n      min: 0,\r\n    }),\r\n    bezierParam({\r\n      name: 'Easing',\r\n      defaultValue: miscUtil.LINEAR_BEZIER,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({\r\n      dimensions: [width, height],\r\n      animationProgress,\r\n      parameters: [radius, easing],\r\n    }) => ({\r\n      dist: miscUtil.bezierCurve(easing, true)(animationProgress) * radius,\r\n      centerX: width / 2,\r\n      centerY: height / 2,\r\n    }),\r\n    ({\r\n      computed: { centerX, centerY, dist },\r\n      dimensions: [width, height],\r\n      coord: [x, y],\r\n      getSrcPixel,\r\n    }) => {\r\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\r\n      const xRatio = (x - centerX) / width;\r\n      const yRatio = (y - centerY) / height;\r\n\r\n      const xOffset = Math.floor(dist * xRatio);\r\n      const yOffset = Math.round(dist * yRatio);\r\n      return getSrcPixel([x - xOffset, y - yOffset]);\r\n    }\r\n  ),\r\n});\r\n","import { BezierTuple } from '~/domain/types';\r\nimport { canvasUtil, imageUtil, miscUtil } from '~/domain/utils';\r\nimport { bezierParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const fade = buildEffect({\r\n  name: 'Fade',\r\n  group: 'Misc',\r\n  description: 'Fades the image in or out',\r\n  requiresAnimation: true,\r\n  params: [\r\n    bezierParam({\r\n      name: 'Curve',\r\n      defaultValue: [\r\n        [0.25, 0.75],\r\n        [0.75, 0.25],\r\n      ],\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [curve] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, {\r\n            opacity: getOpacityAmount({\r\n              frameCount,\r\n              frameIndex,\r\n              curve,\r\n            }),\r\n          }),\r\n      })\r\n    ),\r\n});\r\n\r\nconst getOpacityAmount = ({\r\n  frameIndex,\r\n  frameCount,\r\n  curve,\r\n}: {\r\n  frameIndex: number;\r\n  frameCount: number;\r\n  curve: BezierTuple;\r\n}): number => {\r\n  const progress = frameIndex / (frameCount - 1);\r\n\r\n  return Math.round(miscUtil.bezierCurve(curve, true)(progress) * 100);\r\n};\r\n","import type { Color, Coord, Image } from '~/domain/types';\r\nimport { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\n// TODO\r\nexport const fill = buildEffect({\r\n  disabled: true,\r\n  group: 'Image',\r\n  name: 'Fill Transparent',\r\n  description:\r\n    'Makes transparent all pixels of similar color surrounding a point',\r\n  params: [\r\n    colorPickerParam({\r\n      name: 'Color to Make Transparent',\r\n      defaultValue: [0, 0, 0, 255],\r\n    }),\r\n    sliderParam({\r\n      name: 'Tolerance',\r\n      defaultValue: 10,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image: oldImage, parameters: [colorToReplace, tolerance] }) => {\r\n    const image = imageUtil.duplicateImage(oldImage);\r\n\r\n    for (\r\n      let frameIndex = 0;\r\n      frameIndex < image.frames.length;\r\n      frameIndex += 1\r\n    ) {\r\n      floodFill({\r\n        image,\r\n        frameIndex,\r\n        colorToReplace,\r\n        newColor: colorUtil.TRANSPARENT_COLOR,\r\n        tolerance,\r\n      });\r\n    }\r\n\r\n    return image;\r\n  },\r\n});\r\n\r\n// Mutates the given image/frameIndex\r\nconst floodFill = ({\r\n  image,\r\n  frameIndex,\r\n  colorToReplace,\r\n  newColor,\r\n  tolerance,\r\n}: {\r\n  image: Image;\r\n  frameIndex: number;\r\n  colorToReplace: Color;\r\n  tolerance: number;\r\n  newColor: Color;\r\n}) => {\r\n  const visited = (() => {\r\n    const set = new Set<string>();\r\n    return {\r\n      add: ([x, y]: Coord) => {\r\n        set.add(`${x}-${y}`);\r\n      },\r\n      has: ([x, y]: Coord) => set.has(`${x}-${y}`),\r\n    };\r\n  })();\r\n  const stack: Coord[] = [[0, image.dimensions[1] - 1]]; // Bottom right pixel\r\n  const push = (coord: Coord) => {\r\n    if (!visited.has(coord)) {\r\n      visited.add(coord);\r\n      stack.push(coord);\r\n    }\r\n  };\r\n\r\n  while (stack.length > 0) {\r\n    const coord = stack.pop()!;\r\n    const [x, y] = coord;\r\n    if (\r\n      x < 0 ||\r\n      x >= image.dimensions[0] ||\r\n      y < 0 ||\r\n      y >= image.dimensions[1]\r\n    ) {\r\n      // Out of bounds\r\n      continue;\r\n    }\r\n\r\n    const currColor = imageUtil.getPixelFromSource(\r\n      image.dimensions,\r\n      image.frames[frameIndex],\r\n      coord\r\n    );\r\n    if (colorUtil.colorDiff(currColor, colorToReplace) * 100 > tolerance) {\r\n      continue;\r\n    }\r\n\r\n    imageUtil.setPixel({\r\n      image,\r\n      frameIndex,\r\n      color: newColor,\r\n      coord: coord,\r\n    });\r\n\r\n    push([x + 1, y]);\r\n    push([x - 1, y]);\r\n    push([x, y + y]);\r\n    push([x, y - 1]);\r\n  }\r\n};\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\n// Probably still needs work -- the inner pixels get all funky still\r\nexport const fisheye = buildEffect({\r\n  name: 'Fisheye',\r\n  group: 'Misc',\r\n  description: 'Make the image grow and shrink in a distorted fashion',\r\n  requiresAnimation: true,\r\n  params: [\r\n    intParam({\r\n      name: 'Radius',\r\n      description: 'Positive Number',\r\n      defaultValue: (image) =>\r\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\r\n      min: 0,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({\r\n      animationProgress,\r\n      dimensions: [width, height],\r\n      parameters: [radius],\r\n    }) => {\r\n      const expanding = animationProgress < 0.5;\r\n      return {\r\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\r\n        centerX: width / 2,\r\n        centerY: height / 2,\r\n      };\r\n    },\r\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\r\n      const angle = Math.atan2(centerY - y, centerX - x);\r\n\r\n      const xOffset = Math.round(dist * Math.cos(angle));\r\n      const yOffset = Math.round(dist * Math.sin(angle));\r\n      return getSrcPixel([x + xOffset, y + yOffset]);\r\n    }\r\n  ),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst MAX_GRID_SIZE = 64;\r\n\r\nexport const grid = buildEffect({\r\n  name: 'Grid',\r\n  group: 'Misc',\r\n  description: 'Removes the color from all pixels not aligned with a grid',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Grid Size',\r\n      description: 'The length of each square in the grid',\r\n      defaultValue: 24,\r\n      min: 2,\r\n      max: MAX_GRID_SIZE,\r\n      step: 2,\r\n    }),\r\n    sliderParam({\r\n      name: 'Grid Angle',\r\n      defaultValue: 45,\r\n      min: 0,\r\n      max: 90,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\r\n      const p = getSrcPixel(coord);\r\n      const [x, y] = coord;\r\n\r\n      let isOnGrid = false;\r\n      if (gridAngle % 90 === 0) {\r\n        // Vertical/Horizonal lines\r\n        isOnGrid = x % gridSize === 0 || y % gridSize === 0;\r\n      } else {\r\n        // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\r\n        // Larger threshold = thicker lines.\r\n        const threshold =\r\n          ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\r\n\r\n        const onGrid = (angleDegrees: number) => {\r\n          const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\r\n          return Math.abs(Math.round(n) - n) < threshold;\r\n        };\r\n\r\n        isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\r\n      }\r\n\r\n      return isOnGrid ? p : colorUtil.adjustSaturation(p, -100);\r\n    }\r\n  ),\r\n});\r\n\r\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { huePickerParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const hueChange = buildEffect({\r\n  name: 'Hue Change',\r\n  group: 'Colors',\r\n  description: 'Change the hue of each pixel towards some other color',\r\n  params: [\r\n    huePickerParam({\r\n      name: 'Hue',\r\n      defaultValue: 180,\r\n    }),\r\n    sliderParam({\r\n      name: 'Amount',\r\n      description: 'How strong the effect is.',\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 75,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\r\n      colorUtil.shiftTowardsHue(getSrcPixel(coord), newHue, amount)\r\n  ),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const hueShift = buildEffect({\r\n  name: 'Hue Shift',\r\n  group: 'Colors',\r\n  description: 'Shift the hue of each pixel in the image by some amount',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Amount',\r\n      description: 'How much to shift the hue of each pixel',\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 50,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [amount] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, {\r\n            hueRotate: amount * 3.6,\r\n          }),\r\n      })\r\n    ),\r\n});\r\n","import { colorUtil, imageUtil, miscUtil } from '~/domain/utils';\r\nimport { huePickerParam, bezierParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const hueShiftPulse = buildEffect({\r\n  name: 'Hue Shift Pulse',\r\n  group: 'Colors',\r\n  description: 'Shift the hue to the given value in a pulsating manner',\r\n  requiresAnimation: true,\r\n  params: [\r\n    huePickerParam({\r\n      name: 'Hue',\r\n      defaultValue: 180,\r\n    }),\r\n    bezierParam({\r\n      name: 'Easing',\r\n      defaultValue: [\r\n        [0.25, 0.75],\r\n        [0.75, 0.25],\r\n      ],\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({\r\n      coord,\r\n      getSrcPixel,\r\n      frameCount,\r\n      frameIndex,\r\n      parameters: [hue, easing],\r\n    }) => {\r\n      const amount = miscUtil.bezierCurve(\r\n        easing,\r\n        true\r\n      )(frameIndex / frameCount);\r\n      return colorUtil.shiftTowardsHue(getSrcPixel(coord), hue, amount * 360);\r\n    }\r\n  ),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const hueWave = buildEffect({\r\n  name: 'Hue Wave',\r\n  group: 'Colors',\r\n  description: 'Shifts the hue of pixels in the image in a wave motion',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Amplitude',\r\n      defaultValue: 20,\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      description: 'How strong the hue shift effect should be',\r\n    }),\r\n    sliderParam({\r\n      name: 'Period',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 20,\r\n      description: 'How many waves you want',\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress }) => ({\r\n      shift: -1 * animationProgress * 2 * Math.PI,\r\n    }),\r\n    ({\r\n      computed: { shift },\r\n      coord,\r\n      dimensions: [, height],\r\n      parameters: [amplitude, period],\r\n      getSrcPixel,\r\n    }) => {\r\n      const [, y] = coord;\r\n      const amount = Math.round(\r\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\r\n      );\r\n\r\n      return colorUtil.shiftHue(getSrcPixel(coord), (amount / 100) * 360);\r\n    }\r\n  ),\r\n});\r\n","import seedrandom from 'seedrandom';\r\nimport type { Color } from '~/domain/types';\r\nimport { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { textParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst lightningIntensities: Color[] = [\r\n  [0, 15, 40, 255], // dark color\r\n  [150, 150, 175, 255],\r\n  [180, 180, 205, 255],\r\n  [210, 210, 235, 255],\r\n];\r\n\r\nexport const lightning = buildEffect({\r\n  name: 'Lightning',\r\n  group: 'Misc',\r\n  description: 'Make the background look like a thunderstorm',\r\n  requiresAnimation: true,\r\n  params: [\r\n    textParam({\r\n      name: 'Random Seed',\r\n      description:\r\n        'Can be anything. Will determine the randomness of the lightning.',\r\n      defaultValue: 'lightning',\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [seed] }) => {\r\n    const random = seedrandom(seed);\r\n    return imageUtil.mapFrames(image, (data) => {\r\n      const i = random();\r\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\r\n\r\n      return imageUtil.mapCoords(image.dimensions, (coord) => {\r\n        const src = imageUtil.getPixelFromSource(image.dimensions, data, coord);\r\n\r\n        if (colorUtil.isTransparent(src)) {\r\n          return lightningIntensities[flashIntensity];\r\n        }\r\n\r\n        if (flashIntensity > 0) {\r\n          // We're flashing, so brighten up the image a little\r\n          const icf = 1.02 * flashIntensity;\r\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\r\n        }\r\n\r\n        // No lightning\r\n        return src;\r\n      });\r\n    });\r\n  },\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\nimport { radioParam } from '~/params';\r\n\r\nexport const mirror = buildEffect({\r\n  name: 'Mirror',\r\n  group: 'Image',\r\n  description: 'Mirrors the image',\r\n  params: [\r\n    radioParam({\r\n      name: 'Direction',\r\n      options: [\r\n        {\r\n          name: 'Horizontal',\r\n          value: 'horizontal',\r\n        },\r\n        {\r\n          name: 'Vertical',\r\n          value: 'vertical',\r\n        },\r\n      ],\r\n      defaultValue: 'horizontal',\r\n    } as const),\r\n  ] as const,\r\n  fn: ({ image, parameters: [direction] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyTransform(canvasData, {\r\n            horizontalScale: direction === 'horizontal' ? -1 : 1,\r\n            verticalScale: direction === 'vertical' ? -1 : 1,\r\n            horizontalTranslation:\r\n              direction === 'horizontal' ? image.dimensions[0] : 0,\r\n            verticalTranslation:\r\n              direction === 'vertical' ? image.dimensions[1] : 0,\r\n          }),\r\n      })\r\n    ),\r\n});\r\n","import * as convert from 'color-convert';\r\nimport { imageUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const nuke = buildEffect({\r\n  name: 'Nuke',\r\n  group: 'Misc',\r\n  description: 'Oh no...',\r\n  requiresAnimation: true,\r\n  params: [],\r\n  fn: imageUtil.mapImage(({ coord, getSrcPixel, animationProgress }) => {\r\n    const threshold = animationProgress * 100;\r\n    const [r, g, b, a] = getSrcPixel(coord);\r\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\r\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\r\n    return [newR, newG, newB, l > threshold ? a : 0];\r\n  }),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const opacity = buildEffect({\r\n  name: 'Opacity',\r\n  group: 'Image',\r\n  description: 'Sets the opacity of the image',\r\n  secondaryDescription:\r\n    'Because gifs do not support transparency, ' +\r\n    'the preview below will not reflect the transparency accurately. ' +\r\n    'It will apply to subsequent effects though.',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Amount',\r\n      defaultValue: 50,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [amount] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, { opacity: amount }),\r\n      })\r\n    ),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const party = buildEffect({\r\n  name: 'Party',\r\n  group: 'Party',\r\n  description: 'Shift the hue of the image over the course of the animation',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Shift Speed',\r\n      description: 'Controls how quickly it shifts through the various colors',\r\n      min: 1,\r\n      max: 12,\r\n      defaultValue: 1,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [speed] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) =>\r\n          canvasUtil.applyFilter(canvasData, {\r\n            hueRotate: (frameIndex / frameCount) * 360 * speed,\r\n          }),\r\n      })\r\n    ),\r\n});\r\n","import { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const partyBackground = buildEffect({\r\n  name: 'Party Background',\r\n  group: 'Party',\r\n  description:\r\n    'Smoothly cycles through background colors over the course of the animation',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Shift Speed',\r\n      description: 'Controls how quickly it shifts through the various colors',\r\n      min: 1,\r\n      max: 12,\r\n      defaultValue: 1,\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [shiftSpeed, opacity] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\r\n      const bgColor = colorUtil.colorFromHue(newH);\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background: imageUtil.mapCoords(image.dimensions, () => bgColor),\r\n        foreground,\r\n      });\r\n    }),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const partyHarder = buildEffect({\r\n  name: 'Party Harder',\r\n  group: 'Party',\r\n  description:\r\n    'Shift the hue of each individual pixel over the course of the animation',\r\n  requiresAnimation: true,\r\n  params: [],\r\n  fn: imageUtil.mapImage(({ coord, getSrcPixel, animationProgress }) =>\r\n    colorUtil.shiftHue(getSrcPixel(coord), animationProgress * 360)\r\n  ),\r\n});\r\n","import type { Color, Dimensions, FrameData } from '~/domain/types';\r\nimport { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const partyShadow = buildEffect({\r\n  name: 'Party Shadow',\r\n  group: 'Party',\r\n  description: 'Apply a party shadow effect',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Layers',\r\n      defaultValue: 4,\r\n      min: 1,\r\n      max: 30,\r\n    }),\r\n    sliderParam({\r\n      name: 'Blur Radius',\r\n      min: 0,\r\n      max: 30,\r\n      step: 1,\r\n      defaultValue: 2,\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      defaultValue: 10,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      defaultValue: 10,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [layers, blurRadius, offsetX, offsetY] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const colors: Color[] = [];\r\n      const startHue = animationProgress * 360;\r\n      const hueSize = 360 / layers;\r\n      for (let i = 0; i < layers; i += 1) {\r\n        colors.push(colorUtil.colorFromHue((startHue - hueSize * i) % 360));\r\n      }\r\n\r\n      return applyShadows({\r\n        frame,\r\n        colors,\r\n        blurRadius,\r\n        dimensions: image.dimensions,\r\n        offsetX,\r\n        offsetY,\r\n      });\r\n    }),\r\n});\r\n\r\nconst applyShadows = ({\r\n  frame,\r\n  dimensions,\r\n  colors,\r\n  offsetX,\r\n  offsetY,\r\n  blurRadius,\r\n}: {\r\n  frame: FrameData;\r\n  dimensions: Dimensions;\r\n  colors: Color[];\r\n  offsetX: number;\r\n  offsetY: number;\r\n  blurRadius: number;\r\n}): FrameData => {\r\n  const [color, ...rest] = colors;\r\n  const newFrame = canvasUtil.applyCanvasFromFrame({\r\n    dimensions,\r\n    frame,\r\n    preEffect: (canvasData) =>\r\n      canvasUtil.applyFilter(canvasData, {\r\n        dropShadow: {\r\n          offsetX,\r\n          offsetY,\r\n          blurRadius,\r\n          color,\r\n        },\r\n      }),\r\n  });\r\n\r\n  if (rest.length === 0) {\r\n    return newFrame;\r\n  } else {\r\n    // Apply it recursively but with more offset\r\n    return applyShadows({\r\n      frame: newFrame,\r\n      colors: rest,\r\n      dimensions,\r\n      blurRadius,\r\n      offsetX,\r\n      offsetY,\r\n    });\r\n  }\r\n};\r\n","import type { Coord } from '~/domain/types';\r\nimport { canvasUtil, colorUtil, miscUtil, imageUtil } from '~/domain/utils';\r\nimport {\r\n  colorPickerParam,\r\n  intParam,\r\n  sliderParam,\r\n  variableLengthParam,\r\n} from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst DEFAULT_COLORS = [\r\n  '#FF0000',\r\n  '#FF9600',\r\n  '#FFFF00',\r\n  '#00FF00',\r\n  '#00FF96',\r\n  '#00FFFF',\r\n  '#0000FF',\r\n  '#B400FF',\r\n].map(colorUtil.fromHexColor);\r\n\r\nexport const pinwheelColors = buildEffect({\r\n  name: 'Pinwheel Colors',\r\n  group: 'Party',\r\n  description: 'Create a background pinwheel of colors of your choosing',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each color is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    variableLengthParam({\r\n      name: 'Colors',\r\n      newParamText: 'New Color',\r\n      description: 'Colors for the pinwheel',\r\n      defaultValue: DEFAULT_COLORS,\r\n      createNewParam: () =>\r\n        colorPickerParam({\r\n          name: 'Color',\r\n          defaultValue: DEFAULT_COLORS[0],\r\n        }),\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({\r\n    image,\r\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\r\n  }) => {\r\n    const [width, height] = image.dimensions;\r\n\r\n    const ribbonCount = colors.length * groupCount;\r\n    const ribbonArcDegrees = Math.round(360 / ribbonCount);\r\n    // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\r\n    //  won't get a smooth transition.\r\n    // We'll cut off colors from the end of the list until we get an even multiple.\r\n    let colorsLength = colors.length;\r\n    while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\r\n      colorsLength -= 1;\r\n    }\r\n\r\n    const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\r\n\r\n    return imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n\r\n      const background = imageUtil.mapCoords(image.dimensions, (coord) => {\r\n        const pointAngle = miscUtil.calculateAngle(coord, center);\r\n\r\n        const colorIdx =\r\n          Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\r\n\r\n        // Increment colorIdx based on current frame progress\r\n        const idx =\r\n          (Math.floor(animationProgress * colorsLength) + colorIdx) %\r\n          colorsLength;\r\n        return colors[idx];\r\n      });\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background,\r\n        foreground,\r\n      });\r\n    });\r\n  },\r\n});\r\n","import type { Coord } from '~/domain/types';\r\nimport { colorUtil, miscUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const pinwheelRainbow = buildEffect({\r\n  name: 'Pinwheel Rainbow',\r\n  group: 'Party',\r\n  description: 'Make the image look like a pinwheel rainbow',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each rainbow is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    sliderParam({\r\n      name: 'Strength',\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 75,\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({\r\n      dimensions: [width, height],\r\n      parameters: [groupCount, amount, offsetX, offsetY],\r\n    }) => {\r\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\r\n      return { center };\r\n    },\r\n    ({\r\n      computed: { center },\r\n      coord,\r\n      animationProgress,\r\n      getSrcPixel,\r\n      parameters: [groupCount, strength],\r\n    }) => {\r\n      const srcPixel = getSrcPixel(coord);\r\n\r\n      const pointAngle = miscUtil.calculateAngle(coord, center);\r\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\r\n\r\n      return colorUtil.shiftTowardsHue(srcPixel, newH, strength);\r\n    }\r\n  ),\r\n});\r\n","import type { Coord } from '~/domain/types';\r\nimport { canvasUtil, colorUtil, miscUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const pinwheelRainbowBackground = buildEffect({\r\n  name: 'Pinwheel Rainbow Background',\r\n  group: 'Party',\r\n  description: 'Create a background pinwheel of rainbow colors',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each rainbow is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the pinwheel',\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const [width, height] = image.dimensions;\r\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\r\n\r\n      const background = imageUtil.mapCoords(image.dimensions, (coord) => {\r\n        const pointAngle = miscUtil.calculateAngle(coord, center);\r\n        const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\r\n        return colorUtil.colorFromHue(newH);\r\n      });\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background,\r\n        foreground,\r\n      });\r\n    }),\r\n});\r\n","import { range } from 'remeda';\r\nimport { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport {\r\n  colorPickerParam,\r\n  intParam,\r\n  sliderParam,\r\n  variableLengthParam,\r\n} from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst DEFAULT_COLORS = [\r\n  '#FF0000',\r\n  '#FF9600',\r\n  '#FFFF00',\r\n  '#00FF00',\r\n  '#00FF96',\r\n  '#00FFFF',\r\n  '#0000FF',\r\n  '#B400FF',\r\n].map(colorUtil.fromHexColor);\r\n\r\nexport const radianceColors = buildEffect({\r\n  name: 'Radiance Colors',\r\n  group: 'Party',\r\n  description: 'Radiate background colors of your choosing out in rings',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each color is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    variableLengthParam({\r\n      name: 'Colors',\r\n      newParamText: 'New Color',\r\n      description: 'The colors that make up each ring',\r\n      defaultValue: DEFAULT_COLORS,\r\n      createNewParam: () =>\r\n        colorPickerParam({\r\n          name: 'Color',\r\n          defaultValue: DEFAULT_COLORS[0],\r\n        }),\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({\r\n    image,\r\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\r\n  }) => {\r\n    return imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const [width, height] = image.dimensions;\r\n\r\n      const colorList = range(0, groupCount).flatMap(() => colors);\r\n      const centerX = width / 2;\r\n      const centerY = height / 2;\r\n\r\n      const background = imageUtil.mapCoords(image.dimensions, ([x, y]) => {\r\n        const xRelCenter = x - centerX - offsetX;\r\n        const yRelCenter = y - centerY + offsetY;\r\n\r\n        const maxDist = Math.sqrt(\r\n          (width / 2) * (width / 2) + (height / 2) * (height / 2)\r\n        );\r\n        const distFromCenter = Math.sqrt(\r\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\r\n        );\r\n\r\n        const colorIdx =\r\n          Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\r\n          colorList.length;\r\n\r\n        // Increment colorIdx based on current frame progress\r\n        const idx =\r\n          (Math.floor(animationProgress * colorList.length) + colorIdx) %\r\n          colorList.length;\r\n        return colorList[idx];\r\n      });\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background,\r\n        foreground,\r\n      });\r\n    });\r\n  },\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const radianceRainbow = buildEffect({\r\n  name: 'Radiance Rainbow',\r\n  group: 'Party',\r\n  description: 'Radiate rainbow colors out in rings',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each rainbow is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    sliderParam({\r\n      name: 'Strength',\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      defaultValue: 75,\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ dimensions: [width, height] }) => ({\r\n      centerX: width / 2,\r\n      centerY: height / 2,\r\n      maxDist: Math.sqrt(\r\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\r\n      ),\r\n    }),\r\n    ({\r\n      computed: { centerX, centerY, maxDist },\r\n      coord,\r\n      animationProgress,\r\n      parameters: [groupCount, strength, offsetX, offsetY],\r\n      getSrcPixel,\r\n    }) => {\r\n      const src = getSrcPixel(coord);\r\n\r\n      const [x, y] = coord;\r\n      const xRelCenter = x - centerX - offsetX;\r\n      const yRelCenter = y - centerY + offsetY;\r\n\r\n      const distFromCenter = Math.sqrt(\r\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\r\n      );\r\n\r\n      const newH =\r\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\r\n          360 * animationProgress) %\r\n        360;\r\n\r\n      return colorUtil.shiftTowardsHue(src, newH, strength);\r\n    }\r\n  ),\r\n});\r\n","import { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { intParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const radianceRainbowBackground = buildEffect({\r\n  name: 'Radiance Rainbow Background',\r\n  group: 'Party',\r\n  description: 'Radiate rainbow colors out in rings',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Group Count',\r\n      description: 'How many times each rainbow is repeated',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 24,\r\n    }),\r\n    intParam({\r\n      name: 'Offset X',\r\n      description: 'Change the horizontal center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Offset Y',\r\n      description: 'Change the vertical center of the radiance',\r\n      defaultValue: 0,\r\n    }),\r\n    sliderParam({\r\n      name: 'Foreground Opacity',\r\n      defaultValue: 100,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\r\n    imageUtil.mapFrames(image, (frame, frameIndex, frameCount) => {\r\n      const animationProgress = frameIndex / frameCount;\r\n      const [width, height] = image.dimensions;\r\n      const centerX = width / 2;\r\n      const centerY = height / 2;\r\n      const maxDist = Math.sqrt(\r\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\r\n      );\r\n\r\n      const background = imageUtil.mapCoords(image.dimensions, ([x, y]) => {\r\n        const xRelCenter = x - centerX - offsetX;\r\n        const yRelCenter = y - centerY + offsetY;\r\n\r\n        const distFromCenter = Math.sqrt(\r\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\r\n        );\r\n\r\n        const newH =\r\n          ((1 - distFromCenter / maxDist) * 360 * groupCount +\r\n            360 * animationProgress) %\r\n          360;\r\n\r\n        return colorUtil.colorFromHue(newH);\r\n      });\r\n\r\n      const foreground =\r\n        opacity === 100\r\n          ? frame\r\n          : canvasUtil.applyCanvasFromFrame({\r\n              dimensions: image.dimensions,\r\n              frame,\r\n              preEffect: (canvasData) =>\r\n                canvasUtil.applyFilter(canvasData, { opacity }),\r\n            });\r\n\r\n      return canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background,\r\n        foreground,\r\n      });\r\n    }),\r\n});\r\n","import { minBy, sortBy } from 'remeda';\r\nimport type { Color } from '~/domain/types';\r\nimport { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const reduceColorPalette = buildEffect({\r\n  name: 'Reduce Color Palette',\r\n  group: 'Colors',\r\n  description:\r\n    'Reduce the number of unique colors in the gif, to reduce the file size.',\r\n  secondaryDescription:\r\n    'This can be a slow operation depending on the number of final colors',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Percent Reduction',\r\n      description:\r\n        '0% will have no effect, 100% will result in just one unique color in the result',\r\n      defaultValue: 70,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ image, parameters: [percentReduction] }) => {\r\n      // Buid up a set of all unique colors.\r\n      // These will be our data points that we're going to group into to N clusters\r\n      const allColorsSet = new Set<string>();\r\n      imageUtil.mapFrames(image, (frame) =>\r\n        imageUtil.mapCoords(image.dimensions, (coord) => {\r\n          const px = imageUtil.getPixelFromSource(\r\n            image.dimensions,\r\n            frame,\r\n            coord\r\n          );\r\n          allColorsSet.add(colorUtil.toHexColor(px));\r\n          return colorUtil.TRANSPARENT_COLOR; // Not actually used, just makes TS happy\r\n        })\r\n      );\r\n\r\n      const allColors = Array.from(allColorsSet).map(colorUtil.fromHexColor);\r\n      const numColors = Math.max(\r\n        Math.floor((allColors.length * (100 - percentReduction)) / 100),\r\n        1\r\n      );\r\n\r\n      // Create a mapping of each unique color to the list of colors are the closest to it.\r\n      // We'll then pick the top N colors.\r\n      // Lastly, we'll replace every pixel with the color that it reduces to.\r\n\r\n      // colorMap[i].numClosestColors is the number of colors closest to allColors[i]\r\n      const colorMap: { color: Color; numClosestColors: number }[] =\r\n        allColors.map((c) => ({\r\n          color: c,\r\n          numClosestColors: 0,\r\n        }));\r\n\r\n      for (let i = 1; i < allColors.length; i += 1) {\r\n        let closestColorIdx = 0;\r\n        let closetsColorDist = colorUtil.colorDiff(\r\n          allColors[i],\r\n          allColors[closestColorIdx]\r\n        );\r\n        // Find the other color that is closest to this one\r\n        for (let k = 0; k < allColors.length; k += 1) {\r\n          if (k === i) {\r\n            // Don't check the distance between this color and itself\r\n            continue;\r\n          }\r\n          const dist = colorUtil.colorDiff(allColors[k], allColors[i]);\r\n          if (dist < closetsColorDist) {\r\n            closestColorIdx = k;\r\n            closetsColorDist = dist;\r\n          }\r\n        }\r\n        colorMap[closestColorIdx].numClosestColors += 1;\r\n      }\r\n\r\n      const colorPalette = sortBy(colorMap, [(c) => c.numClosestColors, 'desc'])\r\n        .slice(0, numColors)\r\n        .map(({ color }) => color);\r\n\r\n      return { colorPalette };\r\n    },\r\n    ({ coord, getSrcPixel, computed: { colorPalette } }) => {\r\n      const px = getSrcPixel(coord);\r\n      // Find the color in the palette this one is closest to\r\n      const closestColor = minBy(colorPalette, (top) =>\r\n        colorUtil.colorDiff(top, px)\r\n      )!;\r\n      return closestColor;\r\n    }\r\n  ),\r\n});\r\n","import { range } from 'remeda';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const repeatAnimation = buildEffect({\r\n  name: 'Repeat Animation',\r\n  group: 'Animation',\r\n  description: 'Repeats the current animation some number of times',\r\n  secondaryDescription: 'This can greatly increase the final file size!',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Number of Repeats',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 50,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [numRepeats] }) => ({\r\n    dimensions: image.dimensions,\r\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\r\n      (i) => image.frames[i % image.frames.length]\r\n    ),\r\n  }),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { checkboxParam, intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const resizeImage = buildEffect({\r\n  name: 'Resize Image',\r\n  group: 'Image',\r\n  description: 'Change the absolute dimensions of the image.',\r\n  params: [\r\n    intParam({\r\n      name: 'Width',\r\n      description:\r\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\r\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\r\n      min: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Height',\r\n      description:\r\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\r\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\r\n      min: 0,\r\n    }),\r\n    checkboxParam({\r\n      name: 'Keep scale',\r\n      description:\r\n        'If checked, the image will be stretched to fit the new dimensions',\r\n      defaultValue: false,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight, keepScale] }) => {\r\n    const [oldWidth, oldHeight] = image.dimensions;\r\n    const newWidth =\r\n      resizeToWidth === 0\r\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\r\n        : resizeToWidth;\r\n    const newHeight =\r\n      resizeToHeight === 0\r\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\r\n        : resizeToHeight;\r\n    return imageUtil.resizeImage({\r\n      image,\r\n      newWidth,\r\n      newHeight,\r\n      keepScale,\r\n    });\r\n  },\r\n});\r\n","import { reverse } from 'remeda';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const reverseAnimation = buildEffect({\r\n  name: 'Reverse Animation',\r\n  group: 'Animation',\r\n  description: 'Reverses the animation',\r\n  requiresAnimation: true,\r\n  params: [],\r\n  fn: ({ image }) => ({\r\n    dimensions: image.dimensions,\r\n    frames: reverse(image.frames),\r\n  }),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const ripple = buildEffect({\r\n  name: 'Ripple',\r\n  group: 'Misc',\r\n  description: 'Create a ripple effect, like water',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Amplitude',\r\n      defaultValue: 20,\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      description: 'How strong the ripple effect should be',\r\n    }),\r\n    sliderParam({\r\n      name: 'Period',\r\n      defaultValue: 1,\r\n      min: 1,\r\n      max: 20,\r\n      description: 'How many ripples you want',\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress }) => ({\r\n      shift: animationProgress * 2 * Math.PI,\r\n    }),\r\n    ({\r\n      computed: { shift },\r\n      coord: [x, y],\r\n      dimensions: [, height],\r\n      parameters: [amplitude, period],\r\n      getSrcPixel,\r\n    }) => {\r\n      const offset = Math.round(\r\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\r\n      );\r\n\r\n      return getSrcPixel([x + offset, y]);\r\n    }\r\n  ),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const rotate = buildEffect({\r\n  name: 'Rotate',\r\n  group: 'Transform',\r\n  description: 'Rotates the image to a given angle',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Angle',\r\n      defaultValue: 0,\r\n      min: 0,\r\n      max: 360,\r\n      step: 5,\r\n      description:\r\n        'The angle in degrees. 0 degrees points to the right, 90 degrees points up.',\r\n    }),\r\n  ],\r\n  fn: ({ image, parameters: [angle] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) => canvasUtil.applyRotation(canvasData, angle),\r\n      })\r\n    ),\r\n});\r\n","import type { Coord } from '~/domain/types';\r\nimport { imageUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const roxbury = buildEffect({\r\n  name: 'Roxbury',\r\n  group: 'Misc',\r\n  description: \"Baby, don't hurt me\",\r\n  requiresAnimation: true,\r\n  params: [],\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ dimensions: [width, height], animationProgress }) => {\r\n      // 4 phases:\r\n      //  0 -> freeze\r\n      //  1 -> rotate clockwise\r\n      //  2 -> freeze\r\n      //  3 -> rotate counter-clockwise\r\n      const phase = Math.floor(animationProgress * 4);\r\n      const phaseIdx = (animationProgress - phase / 4) * 4;\r\n\r\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\r\n\r\n      const angle =\r\n        phase === 0\r\n          ? 0\r\n          : phase === 1\r\n          ? phaseIdx * maxAngle // Rotate clockwise\r\n          : phase === 2\r\n          ? maxAngle // Freeze!\r\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\r\n\r\n      return {\r\n        angle,\r\n        cos: Math.cos(-angle * 1.35),\r\n        sin: Math.sin(-angle * 1.35),\r\n        rotatePointX: width * 0.25,\r\n        rotatePointY: height * 0.7,\r\n      };\r\n    },\r\n    ({\r\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\r\n      coord: [x, y],\r\n      getSrcPixel,\r\n    }) => {\r\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\r\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\r\n\r\n      const newCoord: Coord = [\r\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\r\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\r\n      ];\r\n\r\n      return getSrcPixel(newCoord);\r\n    }\r\n  ),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const scaleImage = buildEffect({\r\n  name: 'Scale Image',\r\n  group: 'Image',\r\n  description: 'Scale the image without changing the dimensions',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Scale',\r\n      min: 0.1,\r\n      max: 3,\r\n      step: 0.1,\r\n      defaultValue: 1,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [scale] }) =>\r\n    imageUtil.scaleImage({\r\n      image,\r\n      horizontalScale: scale,\r\n      verticalScale: scale,\r\n    }),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const setAnimationLength = buildEffect({\r\n  name: 'Set Animation Length',\r\n  group: 'Animation',\r\n  groupOrder: 999, // First thing\r\n  description: 'Sets the length of the animation.',\r\n  params: [\r\n    sliderParam({\r\n      name: 'Number of Frames',\r\n      description: 'Set how many frames of animation there will be.',\r\n      defaultValue: (image) => {\r\n        return image ? image.frames.length : 1;\r\n      },\r\n      min: 1,\r\n      max: 60,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [frameCount] }) =>\r\n    imageUtil.changeFrameCount(image, frameCount),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { floatParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const shake = buildEffect({\r\n  name: 'Shake',\r\n  group: 'Misc',\r\n  description: 'Make the image shake left and right',\r\n  requiresAnimation: true,\r\n  params: [\r\n    floatParam({\r\n      name: 'Amplitude',\r\n      defaultValue: (image) =>\r\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\r\n      min: 0,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImageWithPrecompute(\r\n    ({ animationProgress, parameters: [amplitude] }) => ({\r\n      xOffset: Math.round(\r\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\r\n      ),\r\n    }),\r\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\r\n      getSrcPixel([x + xOffset, y])\r\n  ),\r\n});\r\n","import { range } from 'remeda';\r\nimport { imageUtil } from '~/domain/utils';\r\nimport { radioParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const slowAnimation = buildEffect({\r\n  name: 'Slow Animation',\r\n  group: 'Animation',\r\n  description: 'Attempts to slow the animation by adding intermediate frames',\r\n  secondaryDescription: 'This will make the final file size larger',\r\n  requiresAnimation: true,\r\n  params: [\r\n    radioParam<'basic' | 'smooth'>({\r\n      name: 'Interpolation Type',\r\n      options: [\r\n        { name: 'Basic', value: 'basic' },\r\n        { name: 'Smooth', value: 'smooth' },\r\n      ],\r\n      defaultValue: 'basic',\r\n      description:\r\n        'With basic interpolation, frames are simply duplicated. ' +\r\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\r\n    }),\r\n  ],\r\n  fn: ({ image, parameters: [type] }) => ({\r\n    dimensions: image.dimensions,\r\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\r\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\r\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\r\n\r\n      // Even numbered frames are just the original frames\r\n      if (i % 2 === 0) {\r\n        return image.frames[i / 2];\r\n      }\r\n\r\n      const ogFrameIdx = (i - 1) / 2;\r\n\r\n      if (type === 'basic') {\r\n        // Intermediate frame is simply the previous OG frame\r\n        return image.frames[ogFrameIdx];\r\n      }\r\n\r\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\r\n      return imageUtil.mapCoords(image.dimensions, (coord) => {\r\n        const [r1, g1, b1, a1] = imageUtil.getPixelFromSource(\r\n          image.dimensions,\r\n          image.frames[ogFrameIdx],\r\n          coord\r\n        );\r\n        const [r2, g2, b2, a2] = imageUtil.getPixelFromSource(\r\n          image.dimensions,\r\n          image.frames[ogFrameIdx + 1],\r\n          coord\r\n        );\r\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\r\n      });\r\n    }),\r\n  }),\r\n});\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { radioParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const spin = buildEffect({\r\n  name: 'Spin',\r\n  group: 'Transform',\r\n  description: 'Make the image rotate about the center point in an animation',\r\n  requiresAnimation: true,\r\n  params: [\r\n    radioParam<'clockwise' | 'counter'>({\r\n      name: 'Direction',\r\n      defaultValue: 'clockwise',\r\n      options: [\r\n        { name: 'Clockwise', value: 'clockwise' },\r\n        { name: 'Counter-Clockwise', value: 'counter' },\r\n      ],\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [direction] }) =>\r\n    imageUtil.mapFrames(image, (frame, idx, frameCount) => {\r\n      const angle =\r\n        (((direction === 'counter' ? 1 : -1) * idx) / frameCount) * 360;\r\n      return canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        preEffect: (canvasData) => canvasUtil.applyRotation(canvasData, angle),\r\n      });\r\n    }),\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { radioParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const staticc = buildEffect({\r\n  name: 'Static',\r\n  group: 'Misc',\r\n  description: 'Adds random static to each frame the image',\r\n  params: [\r\n    radioParam<'background' | 'foreground'>({\r\n      name: 'Type',\r\n      description: 'Whether to apply the party to the foreground or background',\r\n      defaultValue: 'background',\r\n      options: [\r\n        {\r\n          name: 'Background',\r\n          value: 'background',\r\n        },\r\n        {\r\n          name: 'Foreground',\r\n          value: 'foreground',\r\n        },\r\n      ],\r\n    }),\r\n    sliderParam({\r\n      name: 'Strength',\r\n      description: 'Higher number increases the amount of static pixels',\r\n      defaultValue: 25,\r\n      min: 5,\r\n      max: 100,\r\n      step: 5,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\r\n      const src = getSrcPixel(coord);\r\n\r\n      const isBackground = colorUtil.isTransparent(src);\r\n\r\n      if (type === 'foreground' ? isBackground : !isBackground) {\r\n        return src;\r\n      }\r\n\r\n      if (isBackground && type === 'background') {\r\n        const inverse = Math.ceil(random() * 100) < strength;\r\n        const grey = Math.ceil(random() * 255);\r\n\r\n        return inverse ? [grey, grey, grey, 255] : src;\r\n      }\r\n\r\n      const isStatic = Math.ceil(random() * 100) < strength;\r\n      const grey = Math.ceil(random() * 255);\r\n\r\n      return isStatic ? [grey, grey, grey, src[3]] : src;\r\n    }\r\n  ),\r\n});\r\n","import { canvasUtil, colorUtil, imageUtil } from '~/domain/utils';\r\nimport { colorPickerParam, dropdownParam, intParam, textParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nconst FONTS = [\r\n  'Arial',\r\n  'Verdana',\r\n  'Tahoma',\r\n  'Trebuchet MS',\r\n  'Times New Roman',\r\n  'Georgia',\r\n  'Garamond',\r\n  'Courier New',\r\n  'Brush Script MT',\r\n];\r\n\r\nexport const text = buildEffect({\r\n  name: 'Text',\r\n  group: 'Image',\r\n  description: 'Puts text on the image',\r\n  params: [\r\n    textParam({\r\n      name: 'Text',\r\n      description: 'The text to put on the image',\r\n      defaultValue: '',\r\n    }),\r\n    dropdownParam({\r\n      name: 'Font',\r\n      defaultValue: FONTS[0],\r\n      options: FONTS.map((font) => ({ name: font, value: font })),\r\n    }),\r\n    intParam({\r\n      name: 'X',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Y',\r\n      defaultValue: 0,\r\n    }),\r\n    intParam({\r\n      name: 'Size',\r\n      defaultValue: 12,\r\n      min: 8,\r\n    }),\r\n    colorPickerParam({\r\n      name: 'Color',\r\n      defaultValue: colorUtil.fromHexColor('#000000'),\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [text, font, x, y, fontSize, color] }) =>\r\n    imageUtil.mapFrames(image, (frame) =>\r\n      canvasUtil.applyCanvasFromFrame({\r\n        dimensions: image.dimensions,\r\n        frame,\r\n        postEffect: ({ ctx }) => {\r\n          ctx.font = `${fontSize}px ${font}`;\r\n          ctx.fillStyle = colorUtil.toHexColor(color);\r\n          ctx.fillText(text, x, y);\r\n        },\r\n      })\r\n    ),\r\n});\r\n","import { canvasUtil } from '~/domain/utils';\r\nimport { sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\nimport { FrameData } from '~/domain/types';\r\n\r\nexport const trails = buildEffect({\r\n  name: 'Trails',\r\n  group: 'Misc',\r\n  description: 'Adds a trail of previous animation frames',\r\n  requiresAnimation: true,\r\n  params: [\r\n    sliderParam({\r\n      name: 'Number of Trails',\r\n      description: 'How many previous frames to draw',\r\n      min: 1,\r\n      max: 10,\r\n      defaultValue: 3,\r\n    }),\r\n    sliderParam({\r\n      name: 'Trail Opacity',\r\n      description: 'Controls how transparent each trail is',\r\n      min: 1,\r\n      max: 100,\r\n      defaultValue: 50,\r\n    }),\r\n    sliderParam({\r\n      name: 'Trail Blur',\r\n      description: 'Blurs each the trails, can make things look smoother',\r\n      defaultValue: 0,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: ({ image, parameters: [numTrails, trailOpacity, blur] }) => {\r\n    const blurCoefficient =\r\n      (Math.max(image.dimensions[0], image.dimensions[1]) / 10000) * blur;\r\n\r\n    /*\r\n    // assume numTrails = 3, numFrames = 6\r\n    frames[0] = src[4]*25% > src[5]*25% > src[0]\r\n    frames[1] = src[5]*25% > src[0]*25% > src[1]\r\n    frames[2] = src[0]*25% > src[1]*25% > src[2]\r\n    frames[3] = src[1]*25% > src[2]*25% > src[3]\r\n    frames[4] = src[2]*25% > src[3]*25% > src[4]\r\n    frames[5] = src[3]*25% > src[4]*25% > src[5]\r\n    ...\r\n    */\r\n    const frames: FrameData[] = [];\r\n    for (let i = 0; i < image.frames.length; i += 1) {\r\n      const canvas = canvasUtil.createCanvas(image.dimensions);\r\n      for (let n = numTrails; n > 0; n -= 1) {\r\n        const idx = i - n + 1;\r\n        const frameIdx = idx >= 0 ? idx : image.frames.length + idx;\r\n\r\n        const frameToCopy = image.frames[frameIdx];\r\n        if (frameToCopy != null) {\r\n          canvasUtil.applyFilter(canvas, {\r\n            opacity: Math.floor((n / numTrails) * trailOpacity),\r\n            blur: Math.floor(n * blurCoefficient),\r\n          });\r\n          canvasUtil.drawImageOnCanvas({\r\n            ctx: canvas.ctx,\r\n            dimensions: image.dimensions,\r\n            frame: frameToCopy,\r\n          });\r\n        }\r\n      }\r\n      canvasUtil.applyFilter(canvas, {\r\n        opacity: 100,\r\n        blur: 0,\r\n      });\r\n      canvasUtil.drawImageOnCanvas({\r\n        ctx: canvas.ctx,\r\n        dimensions: image.dimensions,\r\n        frame: image.frames[i],\r\n      });\r\n      frames.push(canvasUtil.canvasToFrame(canvas));\r\n    }\r\n\r\n    return {\r\n      dimensions: image.dimensions,\r\n      frames,\r\n    };\r\n  },\r\n});\r\n","import { colorUtil, imageUtil } from '~/domain/utils';\r\nimport { checkboxParam, colorPickerParam, sliderParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const transparency = buildEffect({\r\n  name: 'Transparency',\r\n  group: 'Image',\r\n  description: 'Set certain pixels to be transparent',\r\n  params: [\r\n    checkboxParam({\r\n      name: 'Matches are Transparent',\r\n      description:\r\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\r\n      defaultValue: true,\r\n    }),\r\n    colorPickerParam({\r\n      name: 'Color',\r\n      defaultValue: colorUtil.fromHexColor('#000000'),\r\n    }),\r\n    sliderParam({\r\n      name: 'Tolerance',\r\n      description:\r\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\r\n      defaultValue: 10,\r\n      min: 0,\r\n      max: 100,\r\n    }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({\r\n      coord,\r\n      getSrcPixel,\r\n      parameters: [matchesTransparent, selectedColor, tolerance],\r\n    }) => {\r\n      const src = getSrcPixel(coord);\r\n\r\n      const withinTolerance =\r\n        colorUtil.colorDiff(src, selectedColor) * 100 <= tolerance;\r\n\r\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\r\n        return [src[0], src[1], src[2], 0];\r\n      }\r\n      return src;\r\n    }\r\n  ),\r\n});\r\n","import { imageUtil } from '~/domain/utils';\r\nimport { intParam } from '~/params';\r\nimport { buildEffect } from './utils';\r\n\r\nexport const transpose = buildEffect({\r\n  name: 'Transpose',\r\n  group: 'Image',\r\n  description: 'Move the image left or right, up or down',\r\n  params: [\r\n    intParam({ name: 'X', defaultValue: 0 }),\r\n    intParam({ name: 'Y', defaultValue: 0 }),\r\n  ] as const,\r\n  fn: imageUtil.mapImage(\r\n    ({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\r\n      getSrcPixel([x + transX, y + transY])\r\n  ),\r\n});\r\n","import { pipe, reject, sortBy } from 'remeda';\r\nimport type { ParamFunction, Effect, EffectGroup } from '~/domain/types';\r\nimport { miscUtil } from '~/domain/utils';\r\n\r\nimport { adjustImage } from './adjust-image';\r\nimport { backgroundColor } from './background-color';\r\nimport { backgroundImage } from './background-image';\r\nimport { blur } from './blur';\r\nimport { bounce } from './bounce';\r\nimport { bounceAnimation } from './bounce-animation';\r\nimport { circle } from './circle';\r\nimport { changingFocus } from './changing-focus';\r\nimport { colorPalette } from './color-palette';\r\nimport { colors } from './colors';\r\nimport { colorsBackground } from './colors-background';\r\nimport { doubleVision } from './double-vision';\r\nimport { dropShadow } from './drop-shadow';\r\nimport { dualHue } from './dual-hue';\r\nimport { expand } from './expand';\r\nimport { fade } from './fade';\r\nimport { fill } from './fill';\r\nimport { fisheye } from './fisheye';\r\nimport { grid } from './grid';\r\nimport { hueChange } from './hue-change';\r\nimport { hueShift } from './hue-shift';\r\nimport { hueShiftPulse } from './hue-shift-pulse';\r\nimport { hueWave } from './hue-wave';\r\nimport { lightning } from './lightning';\r\nimport { mirror } from './mirror';\r\nimport { nuke } from './nuke';\r\nimport { opacity } from './opacity';\r\nimport { party } from './party';\r\nimport { partyBackground } from './party-background';\r\nimport { partyHarder } from './party-harder';\r\nimport { partyShadow } from './party-shadow';\r\nimport { pinwheelColors } from './pinwheel-colors';\r\nimport { pinwheelRainbow } from './pinwheel-rainbow';\r\nimport { pinwheelRainbowBackground } from './pinwheel-rainbow-background';\r\nimport { radianceColors } from './radiance-colors';\r\nimport { radianceRainbow } from './radiance-rainbow';\r\nimport { radianceRainbowBackground } from './radiance-rainbow-background';\r\nimport { reduceColorPalette } from './reduce-color-palette';\r\nimport { repeatAnimation } from './repeat-animation';\r\nimport { resizeImage } from './resize-image';\r\nimport { reverseAnimation } from './reverse-animation';\r\nimport { ripple } from './ripple';\r\nimport { rotate } from './rotate';\r\nimport { roxbury } from './roxbury';\r\nimport { scaleImage } from './scale-image';\r\nimport { setAnimationLength } from './set-animation-length';\r\nimport { shake } from './shake';\r\nimport { slowAnimation } from './slow-animation';\r\nimport { spin } from './spin';\r\nimport { staticc } from './static';\r\nimport { text } from './text';\r\nimport { trails } from './trails';\r\nimport { transparency } from './transparency';\r\nimport { transpose } from './transpose';\r\n\r\n// This array dictates the order of the groups.\r\nconst GROUP_ORDERING: EffectGroup[] = [\r\n  'Animation',\r\n  'Image',\r\n  'Party',\r\n  'Transform',\r\n  'Colors',\r\n  'Misc',\r\n];\r\n\r\nexport const POSSIBLE_EFFECTS = pipe(\r\n  [\r\n    setAnimationLength,\r\n    adjustImage,\r\n    backgroundColor,\r\n    backgroundImage,\r\n    blur,\r\n    bounce,\r\n    bounceAnimation,\r\n    circle,\r\n    changingFocus,\r\n    colorPalette,\r\n    colors,\r\n    colorsBackground,\r\n    doubleVision,\r\n    dropShadow,\r\n    dualHue,\r\n    expand,\r\n    fade,\r\n    fill,\r\n    fisheye,\r\n    grid,\r\n    hueChange,\r\n    hueShift,\r\n    hueShiftPulse,\r\n    hueWave,\r\n    lightning,\r\n    mirror,\r\n    nuke,\r\n    opacity,\r\n    party,\r\n    partyBackground,\r\n    partyHarder,\r\n    partyShadow,\r\n    pinwheelColors,\r\n    pinwheelRainbow,\r\n    pinwheelRainbowBackground,\r\n    radianceColors,\r\n    radianceRainbow,\r\n    radianceRainbowBackground,\r\n    reduceColorPalette,\r\n    repeatAnimation,\r\n    resizeImage,\r\n    reverseAnimation,\r\n    ripple,\r\n    rotate,\r\n    roxbury,\r\n    scaleImage,\r\n    shake,\r\n    slowAnimation,\r\n    spin,\r\n    staticc,\r\n    text,\r\n    trails,\r\n    transparency,\r\n    transpose,\r\n  ],\r\n  // Each effect needs to be ordered according to the group for the dropdown to work correctly.\r\n  // After that, we order within the group order, and then in alphabetical order\r\n  sortBy(\r\n    (x) => GROUP_ORDERING.indexOf(x.group),\r\n    (x) => -1 * (x.groupOrder ?? 0),\r\n    (x) => x.name\r\n  ),\r\n  reject((x) => x.disabled)\r\n);\r\n\r\nexport const effectByName = (\r\n  name: string\r\n): Effect<readonly ParamFunction<any>[]> => {\r\n  const t = POSSIBLE_EFFECTS.find((t) => t.name === name);\r\n  miscUtil.assert(t, `Could not find matching effect: ${name}`);\r\n  return t as any as Effect<readonly ParamFunction<any>[]>;\r\n};\r\n","import { Stack, Typography } from '@material-ui/core';\r\nimport { Icon } from './Icon';\r\n\r\nconst TooltipInner: React.FC = () => (\r\n  <Stack spacing={1}>\r\n    <Typography>This resulting image contains partial transparency</Typography>\r\n    <Typography variant=\"caption\">\r\n      Gifs do not handle partial transparency, so a fake background has been\r\n      applied to the preview.\r\n    </Typography>\r\n    <Typography variant=\"caption\">\r\n      Be sure to add some effect after this that affects the \"background\", or\r\n      else anything that is partially transparent will be made either fully\r\n      transparent, or fully opaque.\r\n    </Typography>\r\n  </Stack>\r\n);\r\n\r\nexport const BackgroundPreviewTooltip: React.FC = () => {\r\n  return (\r\n    <Icon\r\n      name=\"info\"\r\n      color=\"secondary\"\r\n      tooltip={<TooltipInner />}\r\n      htmlTooltip\r\n    />\r\n  );\r\n};\r\n","import { canvasUtil, imageUtil } from '~/domain/utils';\r\nimport { buildEffect } from './utils';\r\n\r\n// NOTE: This is not intended as an end-user effect!\r\n// This is just to display behind a picture when there are partially-transparent pixels,\r\n//  as GIFs do not support partial transparency.\r\n\r\nconst COLORS = ['#111111', '#888888'];\r\n\r\nexport const fakeTransparency = buildEffect({\r\n  name: 'Fake Transparency',\r\n  group: 'Image',\r\n  description:\r\n    'This is just to display behind a picture when there are partially-transparent pixels,' +\r\n    ' as GIFs do not support partial transparency',\r\n  params: [] as const,\r\n  disabled: true,\r\n  fn: ({ image }) => {\r\n    const createBackground = () => {\r\n      const canvas = canvasUtil.createCanvas(image.dimensions);\r\n      const ctx = canvas.ctx;\r\n\r\n      const numBlocks = 10;\r\n      const blockWidth = image.dimensions[0] / numBlocks;\r\n      const blockHeight = image.dimensions[1] / numBlocks;\r\n      for (let i = 0; i < numBlocks; i += 1) {\r\n        for (let j = 0; j < numBlocks; j += 1) {\r\n          ctx.fillStyle = COLORS[(i + j) % 2];\r\n          ctx.fillRect(\r\n            i * blockWidth,\r\n            j * blockHeight,\r\n            (i + 1) * blockWidth,\r\n            (j + 1) * blockHeight\r\n          );\r\n        }\r\n      }\r\n      return canvas;\r\n    };\r\n\r\n    return imageUtil.mapFrames(image, (imageData) =>\r\n      canvasUtil.combineImages({\r\n        dimensions: image.dimensions,\r\n        background: createBackground(),\r\n        foreground: imageData,\r\n      })\r\n    );\r\n  },\r\n});\r\n","// @ts-ignore\r\nimport gifEncoder from 'gif-encoder';\r\nimport seedrandom from 'seedrandom';\r\nimport { effectByName } from '~/effects';\r\nimport { Color, Image, ImageEffectResult } from './types';\r\nimport { colorUtil, imageUtil, miscUtil } from '~/domain/utils';\r\nimport { fakeTransparency } from '~/effects/fake-transparency';\r\n\r\nexport interface RunArgs {\r\n  randomSeed: string;\r\n  image: Image;\r\n  effectInput: {\r\n    effectName: string;\r\n    params: any;\r\n  };\r\n  fps: number;\r\n}\r\n\r\n// Returns a list of gif data URLs, for each effect\r\nexport const runEffects = async ({\r\n  image,\r\n  effectInput,\r\n  randomSeed,\r\n  fps,\r\n}: RunArgs): Promise<ImageEffectResult> => {\r\n  const random = seedrandom(randomSeed);\r\n\r\n  const effect = effectByName(effectInput.effectName);\r\n  const result = await effect.fn({\r\n    image,\r\n    parameters: effectInput.params,\r\n    random,\r\n  });\r\n\r\n  const { transparentColor, hasPartialTransparency } = getTransparentColor(\r\n    result,\r\n    random\r\n  );\r\n\r\n  const gif = await createGif({\r\n    // Transform any of our transparent pixels to what our gif understands to be transparent\r\n    image: encodeTransparency(result, transparentColor),\r\n    transparentColor,\r\n    fps,\r\n  });\r\n\r\n  if (hasPartialTransparency) {\r\n    const resultWithBG = await fakeTransparency.fn({\r\n      image: result,\r\n      parameters: [],\r\n      random,\r\n    });\r\n\r\n    return {\r\n      gif,\r\n      image: result,\r\n      partiallyTransparent: true,\r\n      gifWithBackgroundColor: await createGif({\r\n        image: resultWithBG,\r\n        transparentColor: undefined,\r\n        fps,\r\n      }),\r\n    };\r\n  } else {\r\n    const resultWithBG =\r\n      transparentColor == null\r\n        ? undefined\r\n        : await fakeTransparency.fn({\r\n            image: result,\r\n            parameters: [],\r\n            random,\r\n          });\r\n\r\n    return {\r\n      gif,\r\n      image: result,\r\n      partiallyTransparent: false,\r\n      gifWithBackgroundColor:\r\n        resultWithBG == null\r\n          ? undefined\r\n          : await createGif({\r\n              image: resultWithBG,\r\n              transparentColor: undefined,\r\n              fps,\r\n            }),\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Each pixel in our image has an alpha channel, but gifs don't.\r\n * We transform each pixel that appears transparent to be a designated transparent color.\r\n */\r\nconst encodeTransparency = (\r\n  image: Image,\r\n  transparentColor: Color | undefined\r\n): Image => {\r\n  const newFrames = image.frames.map((frame) => {\r\n    const img = new Uint8ClampedArray(frame.length);\r\n    for (let i = 0; i < frame.length; i += 4) {\r\n      if (transparentColor && frame[i + 3] < 128) {\r\n        // Anything more than halfway transparent is considered transparent\r\n        img[i] = transparentColor[0];\r\n        img[i + 1] = transparentColor[1];\r\n        img[i + 2] = transparentColor[2];\r\n        img[i + 3] = 0;\r\n      } else {\r\n        img[i] = frame[i];\r\n        img[i + 1] = frame[i + 1];\r\n        img[i + 2] = frame[i + 2];\r\n        img[i + 3] = 0; // Gifs don't do transparency, I dunno why they take in an alpha value...\r\n      }\r\n    }\r\n    return img;\r\n  });\r\n\r\n  return {\r\n    dimensions: image.dimensions,\r\n    frames: newFrames,\r\n  };\r\n};\r\n\r\nconst createGif = async ({\r\n  image,\r\n  transparentColor,\r\n  fps,\r\n}: {\r\n  image: Image;\r\n  transparentColor: Color | undefined;\r\n  fps: number;\r\n}): Promise<string> =>\r\n  new Promise<string>((resolve) => {\r\n    const [width, height] = image.dimensions;\r\n    const gif = new gifEncoder(width, height);\r\n\r\n    gif.setFrameRate(fps);\r\n    gif.setRepeat(0); // Loop indefinitely\r\n\r\n    // gif.setQuality(10);\r\n    gif.writeHeader();\r\n\r\n    if (transparentColor) {\r\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\r\n      const hexColor = colorUtil.toHexColor(transparentColor).slice(1);\r\n      gif.setTransparent(`0x${hexColor}`);\r\n    }\r\n\r\n    let data: any[] = [];\r\n    gif.on('data', (chunk: any) => {\r\n      data.push(chunk);\r\n    });\r\n    gif.on('end', async () => {\r\n      const blob = new Blob(data, { type: 'image/gif' });\r\n      const dataUrl = await miscUtil.blobOrFileToDataUrl(blob);\r\n      resolve(dataUrl);\r\n    });\r\n\r\n    image.frames.forEach((f) => {\r\n      gif.addFrame(f);\r\n    });\r\n\r\n    gif.finish();\r\n  });\r\n\r\nconst getTransparentColor = (\r\n  image: Image,\r\n  random: seedrandom.prng\r\n):\r\n  | {\r\n      hasPartialTransparency: true;\r\n      transparentColor: Color;\r\n    }\r\n  | {\r\n      hasPartialTransparency: false;\r\n      transparentColor: Color | undefined;\r\n    } => {\r\n  let hasTransparent = false;\r\n  const seenPixels = new Set<string>();\r\n  const [width, height] = image.dimensions;\r\n  let hasPartialTransparency = false;\r\n  let attempt = colorUtil.toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\r\n  image.frames.forEach((frame) => {\r\n    for (let y = 0; y < height; y += 1) {\r\n      for (let x = 0; x < width; x += 1) {\r\n        const px = imageUtil.getPixelFromSource(image.dimensions, frame, [\r\n          x,\r\n          y,\r\n        ]);\r\n        if (colorUtil.isPartiallyTransparent(px)) {\r\n          hasPartialTransparency = true;\r\n        }\r\n        if (colorUtil.isTransparent(px)) {\r\n          hasTransparent = true;\r\n        } else {\r\n          const hex = colorUtil.toHexColor(px);\r\n          seenPixels.add(hex);\r\n          if (hex === attempt) {\r\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\r\n            attempt = findRandomColorNotInSet(random, seenPixels);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n  return {\r\n    transparentColor: hasTransparent\r\n      ? colorUtil.fromHexColor(attempt)\r\n      : undefined,\r\n    hasPartialTransparency,\r\n  };\r\n};\r\n\r\nconst findRandomColorNotInSet = (\r\n  random: seedrandom.prng,\r\n  set: Set<string>,\r\n  attempts = 0\r\n): string => {\r\n  const col = colorUtil.toHexColor(colorUtil.randomColor(random));\r\n  if (attempts > 2000) {\r\n    // Just give up in order to prevent a stack overflow or something...\r\n    return col;\r\n  }\r\n  return set.has(col)\r\n    ? findRandomColorNotInSet(random, set, attempts + 1)\r\n    : col;\r\n};\r\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/effect.worker.7983678a.worker.js\");\n}\n","import { RunArgs } from './run';\r\n// @ts-ignore\r\nimport RunEffectWorker from './effect.worker';\r\nimport { AsyncRunMessage, ImageEffectResult } from './types';\r\n\r\ninterface Computation {\r\n  resolve: (result: ImageEffectResult) => void;\r\n  reject: (err: any) => void;\r\n}\r\n\r\n// The order of computations is not guaranteed, so add each computation to a map\r\nconst computationMap = new Map<string, Computation>();\r\n\r\nconst handleError = (computationId: string) => (error: any) => {\r\n  const computation = computationMap.get(computationId);\r\n  if (!computation) {\r\n    return;\r\n  }\r\n  computation.reject(error);\r\n  computationMap.delete(computationId);\r\n};\r\n\r\nconst handleSuccess = (computationId: string, result: ImageEffectResult) => {\r\n  const computation = computationMap.get(computationId);\r\n  if (!computation) {\r\n    return;\r\n  }\r\n  computation.resolve(result);\r\n  computationMap.delete(computationId);\r\n};\r\n\r\nexport const runEffectsAsync = (args: RunArgs) =>\r\n  new Promise<ImageEffectResult>((resolve, reject) => {\r\n    const worker = new RunEffectWorker();\r\n\r\n    const computationId = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;\r\n    computationMap.set(computationId, {\r\n      resolve,\r\n      reject,\r\n    });\r\n\r\n    worker.addEventListener('error', handleError(computationId));\r\n    worker.addEventListener('messageerror', handleError(computationId));\r\n\r\n    worker.onmessage = (message: { data: AsyncRunMessage }) => {\r\n      // See effect.worker.ts for what messages look like\r\n      const data = message.data;\r\n      if (data.status === 'complete') {\r\n        handleSuccess(computationId, data.result);\r\n      }\r\n    };\r\n\r\n    worker.postMessage(args);\r\n  });\r\n","import { runEffects } from './run';\r\nimport { runEffectsAsync } from './runAsync';\r\nimport { AppState, Image, ImageEffectResult } from './types';\r\nimport { ENV, debugLog, IS_MOBILE } from './env';\r\nimport { miscUtil } from './utils';\r\n\r\n// OffscreenCanvas isn't supported by mobile browsers, so mobile will also run synchronously,\r\n//  which will force us to use regular canvas and not OffscreenCanvas.\r\n// Also, we can't get web workers working with the dev build, so always use the synchronous\r\n//  version if not a prod build.\r\nexport const computeGif =\r\n  IS_MOBILE || ENV === 'DEV' ? runEffects : runEffectsAsync;\r\n\r\nexport const computeGifsForState = async ({\r\n  state,\r\n  startEffectIndex,\r\n  onCompute,\r\n}: {\r\n  state: AppState;\r\n  startEffectIndex: number;\r\n  onCompute: (image: ImageEffectResult, idx: number) => void;\r\n}): Promise<void> => {\r\n  miscUtil.assert(\r\n    state.baseImage,\r\n    'No source image, this button should be disabled!'\r\n  );\r\n\r\n  let image: Image;\r\n  if (startEffectIndex === 0) {\r\n    image = state.baseImage.image;\r\n  } else {\r\n    const prevEffectState = state.effects[startEffectIndex - 1].state;\r\n    miscUtil.assert(\r\n      prevEffectState.status === 'done',\r\n      'We should not be starting with this effect if the previous is not done computing'\r\n    );\r\n    image = prevEffectState.image.image;\r\n  }\r\n\r\n  for (let i = startEffectIndex; i < state.effects.length; i += 1) {\r\n    const effect = state.effects[i];\r\n\r\n    const result = await computeGif({\r\n      randomSeed: state.baseImage.gif,\r\n      image,\r\n      effectInput: {\r\n        effectName: effect.effectName,\r\n        params: effect.paramsValues,\r\n      },\r\n      fps: state.fps,\r\n    });\r\n\r\n    image = result.image;\r\n\r\n    onCompute(result, i);\r\n  }\r\n};\r\n\r\n/** Get the index of the first effect that differs from curr to prev state */\r\nexport const getEffectsDiff = ({\r\n  currState,\r\n  prevState,\r\n}: {\r\n  currState: AppState;\r\n  prevState: AppState;\r\n}): { diff: true; index: number } | { diff: false } => {\r\n  if (\r\n    currState.fps !== prevState.fps ||\r\n    currState.baseImage !== prevState.baseImage\r\n  ) {\r\n    debugLog('FPS or base image is different');\r\n    return { diff: true, index: 0 };\r\n  }\r\n\r\n  const currEffects = currState.effects;\r\n  const prevEffects = prevState.effects;\r\n\r\n  // Find the first newEffect that is different from prevEffects\r\n  for (let i = 0; i < currEffects.length; i += 1) {\r\n    const currE = currEffects[i];\r\n    const prevE = prevEffects[i];\r\n    if (!prevE) {\r\n      debugLog('No prevE, index ', i);\r\n      return { diff: true, index: i };\r\n    }\r\n\r\n    if (prevE.state.status !== 'done') {\r\n      debugLog('PrevE not done ', i);\r\n      return { diff: true, index: i };\r\n    }\r\n\r\n    if (currE.effectName !== prevE.effectName) {\r\n      debugLog('Different effect name ', i);\r\n      return { diff: true, index: i };\r\n    }\r\n\r\n    // Compare the param values\r\n    for (let ei = 0; ei < currE.paramsValues.length; ei += 1) {\r\n      const currEParam = currE.paramsValues[ei];\r\n      const prevEP = prevE.paramsValues[ei];\r\n      if (JSON.stringify(currEParam) !== JSON.stringify(prevEP)) {\r\n        debugLog('Param different', i, ei);\r\n        return { diff: true, index: i };\r\n      }\r\n    }\r\n  }\r\n\r\n  debugLog('No diff');\r\n  return { diff: false };\r\n};\r\n","import React from 'react';\r\nimport { debugLog } from '~/domain/env';\r\nimport { computeGif } from '~/domain/computeGifs';\r\nimport type { ImageEffectResult } from '~/domain/types';\r\nimport { RunArgs } from '~/domain/run';\r\n\r\nconst getRunId = () => Math.floor(Math.random() * 100000);\r\n\r\ninterface ContextProps {\r\n  latestRunIdRef: React.MutableRefObject<number>;\r\n}\r\n\r\nconst ProcessorQueueContext = React.createContext<ContextProps>({\r\n  latestRunIdRef: null as any, // Will be set immediately in the provider\r\n});\r\n\r\nexport const ProcessorQueueProvider: React.FC = ({ children }) => {\r\n  const latestRunIdRef = React.useRef(0);\r\n\r\n  return (\r\n    <ProcessorQueueContext.Provider value={{ latestRunIdRef }}>\r\n      {children}\r\n    </ProcessorQueueContext.Provider>\r\n  );\r\n};\r\n\r\n/**\r\n * Computes an asynchronous, calling the given callback when finished.\r\n *\r\n * If a compute is called while an existing one is in progress, then the\r\n *  result for the previous compute will be thrown away. The callback will\r\n *  only be called a single time. Think of it like a debounce.\r\n */\r\nexport function useProcessingQueue({\r\n  onComplete,\r\n  onError,\r\n}: {\r\n  onComplete: (results: ImageEffectResult) => void;\r\n  onError?: (error: Error) => void;\r\n}) {\r\n  const { latestRunIdRef } = React.useContext(ProcessorQueueContext);\r\n\r\n  const onFinish = React.useCallback(\r\n    (runId: number, results: ImageEffectResult) => {\r\n      debugLog('Finished', { runId, latestRunIdRef });\r\n      if (runId === latestRunIdRef.current) {\r\n        onComplete(results);\r\n      } else {\r\n        // Throw away this result -- it's been superceded by another compute\r\n        debugLog('Throwing away an old compute');\r\n      }\r\n    },\r\n    [onComplete, latestRunIdRef]\r\n  );\r\n\r\n  return React.useCallback(\r\n    (args: RunArgs): void => {\r\n      const runId = getRunId();\r\n      debugLog('Computing: ', { runId, args });\r\n      latestRunIdRef.current = runId;\r\n      computeGif(args)\r\n        .then((results) => onFinish(runId, results))\r\n        .catch(onError);\r\n    },\r\n    [onError, onFinish, latestRunIdRef]\r\n  );\r\n}\r\n","import { Stack, Typography } from '@material-ui/core';\r\nimport { Icon } from './Icon';\r\n\r\nconst TooltipInner: React.FC = () => (\r\n  <Stack spacing={1}>\r\n    <Typography>This is a static image</Typography>\r\n    <Typography variant=\"caption\">\r\n      This effect requires an animation in order to have any effect.\r\n    </Typography>\r\n    <Typography variant=\"caption\">\r\n      Be sure to add a \"Set Animation Length\" effect before this, so there are\r\n      multiple animation frames.\r\n    </Typography>\r\n  </Stack>\r\n);\r\n\r\nexport const RequiresAnimationTooltip: React.FC = () => {\r\n  return (\r\n    <Icon\r\n      name=\"warning\"\r\n      color=\"warning\"\r\n      tooltip={<TooltipInner />}\r\n      htmlTooltip\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\nimport {\r\n  Autocomplete,\r\n  Button,\r\n  CircularProgress,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  Divider,\r\n  FormControl,\r\n  Stack,\r\n  styled,\r\n  TextField,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport type {\r\n  ParamFunction,\r\n  Effect,\r\n  EffectInput,\r\n  ImageEffectResult,\r\n} from '~/domain/types';\r\nimport { miscUtil } from '~/domain/utils';\r\nimport { debugLog } from '~/domain/env';\r\nimport { Gif } from './Gif';\r\nimport { BackgroundPreviewTooltip } from './BackgroundPreviewTooltip';\r\nimport { useProcessingQueue } from '~/domain/useProcessingQueue';\r\nimport { RequiresAnimationTooltip } from './RequiresAnimationTooltip';\r\n\r\nconst GroupHeader = styled('div')(({ theme }) => ({\r\n  position: 'sticky',\r\n  top: '-8px',\r\n  padding: '4px 10px',\r\n  backgroundColor: theme.palette.primary.contrastText,\r\n}));\r\n\r\nconst GroupItems = styled('ul')({\r\n  padding: 0,\r\n});\r\n\r\ninterface Props {\r\n  open: boolean;\r\n  initialImage: ImageEffectResult | undefined;\r\n  currentEffect: EffectInput | undefined;\r\n  possibleEffects: Effect<any>[];\r\n  currFps: number;\r\n  currRandomSeed: string;\r\n  onChangeEffect: (\r\n    effect: EffectInput,\r\n    computedImage: ImageEffectResult | undefined\r\n  ) => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nexport const ImageEffectDialog: React.FC<Props> = ({\r\n  open,\r\n  initialImage,\r\n  currentEffect,\r\n  possibleEffects,\r\n  currFps,\r\n  currRandomSeed,\r\n  onChangeEffect,\r\n  onCancel,\r\n}) => {\r\n  const [image, setImage] = React.useState<\r\n    { computing: true } | { computing: false; results: ImageEffectResult }\r\n  >({ computing: true });\r\n\r\n  const onImageChange = useProcessingQueue({\r\n    onComplete: (results) => {\r\n      setImage({ computing: false, results });\r\n    },\r\n  });\r\n\r\n  const [initialLoaded, setInitialLoaded] = React.useState(false);\r\n\r\n  const [editingEffect, setEditingEffect] = React.useState<\r\n    EffectInput | undefined\r\n  >(undefined);\r\n\r\n  const [dirty, setDirty] = React.useState(false);\r\n\r\n  React.useEffect(() => {\r\n    if (currentEffect) {\r\n      setEditingEffect({\r\n        effect: currentEffect.effect,\r\n        params: [...currentEffect.params], // Make a defensive copy so we can edit the params\r\n      });\r\n    }\r\n  }, [currentEffect]);\r\n\r\n  React.useEffect(() => {\r\n    // Reset state to default values on close\r\n    if (!open) {\r\n      setInitialLoaded(false);\r\n      setEditingEffect(undefined);\r\n      setImage({ computing: true });\r\n    }\r\n  }, [open]);\r\n\r\n  React.useEffect(() => {\r\n    // Set initial loaded image once we have it\r\n    if (!initialImage) {\r\n      return;\r\n    }\r\n\r\n    if (!initialLoaded) {\r\n      debugLog('Initial loading');\r\n      // The initial loading of the original effect\r\n      setImage({\r\n        computing: false,\r\n        results: initialImage,\r\n      });\r\n      setInitialLoaded(true);\r\n      return;\r\n    }\r\n\r\n    // Just used for setting the initial image, so just change it when the initial image does.\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [initialImage]);\r\n\r\n  React.useEffect(() => {\r\n    if (!initialImage || !editingEffect) {\r\n      return;\r\n    }\r\n\r\n    setImage({ computing: true });\r\n    onImageChange({\r\n      fps: currFps,\r\n      randomSeed: currRandomSeed,\r\n      image: initialImage.image,\r\n      effectInput: {\r\n        effectName: editingEffect.effect.name,\r\n        params: editingEffect.params,\r\n      },\r\n    });\r\n\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [initialImage, editingEffect, currFps, currRandomSeed]);\r\n\r\n  const closeDialog = ({ save }: { save: boolean }) => {\r\n    if (!save || !editingEffect) {\r\n      onCancel();\r\n      return;\r\n    }\r\n\r\n    onChangeEffect(editingEffect, image.computing ? undefined : image.results);\r\n    setDirty(false);\r\n  };\r\n\r\n  const effect = editingEffect?.effect ?? undefined;\r\n\r\n  return (\r\n    <Dialog fullWidth maxWidth=\"sm\" open={open}>\r\n      {editingEffect && effect && (\r\n        <>\r\n          <DialogTitle>\r\n            <Stack direction=\"row\" spacing={4} marginTop={2}>\r\n              <FormControl fullWidth>\r\n                <Autocomplete\r\n                  disableClearable\r\n                  value={editingEffect.effect}\r\n                  options={possibleEffects}\r\n                  groupBy={(e) => e.group}\r\n                  onChange={(_event, newEffect) => {\r\n                    // Reset all the params when you select a new effect\r\n                    setEditingEffect({\r\n                      effect: newEffect,\r\n                      params: newEffect.params.map((p: any) =>\r\n                        p.defaultValue(initialImage?.image ?? undefined)\r\n                      ),\r\n                    });\r\n                    setDirty(true);\r\n                  }}\r\n                  getOptionLabel={(option) => option.name}\r\n                  renderGroup={(params) => (\r\n                    <li key={params.key}>\r\n                      <GroupHeader>\r\n                        <Typography variant=\"subtitle1\">\r\n                          {params.group}\r\n                        </Typography>\r\n                        <Divider />\r\n                      </GroupHeader>\r\n                      <GroupItems>{params.children}</GroupItems>\r\n                    </li>\r\n                  )}\r\n                  renderOption={(props, effect) => (\r\n                    <li {...props}>\r\n                      <Stack marginLeft={2} marginRight={2}>\r\n                        <Typography variant=\"body2\">{effect.name}</Typography>\r\n                        <Typography variant=\"caption\" marginLeft={2}>\r\n                          {effect.description}\r\n                        </Typography>\r\n                      </Stack>\r\n                    </li>\r\n                  )}\r\n                  renderInput={(params) => (\r\n                    <TextField {...params} label=\"Effect\" />\r\n                  )}\r\n                />\r\n              </FormControl>\r\n            </Stack>\r\n          </DialogTitle>\r\n          <DialogContent>\r\n            <Stack divider={<Divider />} spacing={2}>\r\n              <Stack direction=\"row\" spacing={4}>\r\n                <Typography variant=\"body2\">\r\n                  {effect.description}\r\n                  <div>\r\n                    {effect.secondaryDescription && (\r\n                      <Typography variant=\"caption\" marginLeft={2}>\r\n                        {effect.secondaryDescription}\r\n                      </Typography>\r\n                    )}\r\n                  </div>\r\n                </Typography>\r\n                {effect.requiresAnimation &&\r\n                !image.computing &&\r\n                image.results.image.frames.length <= 1 ? (\r\n                  <RequiresAnimationTooltip />\r\n                ) : null}\r\n              </Stack>\r\n\r\n              {effect.params.map(\r\n                // Create elements for each of the parameters for the selectect effect.\r\n                // Each of these would get an onChange event so we know when the user has\r\n                //  selected a value.\r\n                (param: ParamFunction<any>, idx: number) => {\r\n                  const ele = param.fn({\r\n                    value: editingEffect.params[idx],\r\n                    onChange: (v) => {\r\n                      setDirty(true);\r\n                      setEditingEffect({\r\n                        ...editingEffect,\r\n                        params: miscUtil.replaceIndex(\r\n                          editingEffect.params,\r\n                          idx,\r\n                          () => v\r\n                        ),\r\n                      });\r\n                    },\r\n                  });\r\n                  return (\r\n                    <React.Fragment\r\n                      key={`${editingEffect.effect.name}-${param.name}`}\r\n                    >\r\n                      {ele}\r\n                    </React.Fragment>\r\n                  );\r\n                }\r\n              )}\r\n              <Stack sx={{ height: 300 }}>\r\n                {image.computing ? (\r\n                  <CircularProgress size={100} />\r\n                ) : (\r\n                  <>\r\n                    <Gif\r\n                      src={\r\n                        image.results.gifWithBackgroundColor ??\r\n                        image.results.gif\r\n                      }\r\n                      alt={`effect-${editingEffect.effect.name}`}\r\n                      dimensions={image.results.image.dimensions}\r\n                    />\r\n                    {image.results.partiallyTransparent ? (\r\n                      <BackgroundPreviewTooltip />\r\n                    ) : null}\r\n                  </>\r\n                )}\r\n              </Stack>\r\n            </Stack>\r\n          </DialogContent>\r\n          <DialogActions>\r\n            <Button\r\n              variant=\"outlined\"\r\n              autoFocus\r\n              onClick={() => {\r\n                closeDialog({ save: false });\r\n              }}\r\n            >\r\n              Cancel\r\n            </Button>\r\n            <Button\r\n              variant=\"contained\"\r\n              autoFocus\r\n              disabled={!dirty}\r\n              onClick={() => {\r\n                closeDialog({ save: true });\r\n              }}\r\n            >\r\n              Save and Close\r\n            </Button>\r\n          </DialogActions>\r\n        </>\r\n      )}\r\n    </Dialog>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport {\r\n  CircularProgress,\r\n  Stack,\r\n  Typography,\r\n  Divider,\r\n  Checkbox,\r\n} from '@material-ui/core';\r\nimport { AppStateEffect, ImageEffectResult } from '~/domain/types';\r\nimport { Gif } from './Gif';\r\nimport { CanvasElement } from '~/domain/utils';\r\nimport { drawImageOnCanvas, applyTransform } from '~/domain/utils/canvas';\r\nimport { BackgroundPreviewTooltip } from './BackgroundPreviewTooltip';\r\n\r\nconst MAX_SIZE = 128;\r\n\r\ninterface InnerProps {\r\n  result: ImageEffectResult;\r\n  effectName: string;\r\n}\r\n\r\nconst Inner: React.FC<InnerProps> = ({ result, effectName }) => {\r\n  const image = result.image;\r\n  const { frames, dimensions } = image;\r\n  const [width, height] = dimensions;\r\n\r\n  const [showTransparency, setShowTransparency] = React.useState(true);\r\n\r\n  const { eleWidth, eleHeight, hScale, vScale } = React.useMemo(() => {\r\n    const aspectRatio = height / width;\r\n\r\n    let eleWidth = MAX_SIZE;\r\n    let eleHeight = MAX_SIZE;\r\n\r\n    if (width > height) {\r\n      // If width is bigger, then keep the width at MAX and scale the height down\r\n      eleHeight = Math.floor(aspectRatio * MAX_SIZE);\r\n    } else {\r\n      // Else scale the width down\r\n      eleWidth = Math.floor(aspectRatio * MAX_SIZE);\r\n    }\r\n\r\n    return {\r\n      eleWidth,\r\n      eleHeight,\r\n      hScale: eleWidth / width,\r\n      vScale: eleHeight / height,\r\n    };\r\n  }, [height, width]);\r\n\r\n  const renderedFrames = React.useMemo(\r\n    () =>\r\n      frames.map((frame, idx) => (\r\n        <Stack\r\n          alignItems=\"center\"\r\n          key={`${result.gif.substring(0, 16)}-${idx}`}\r\n        >\r\n          <Typography variant=\"caption\">Frame {idx + 1}</Typography>\r\n          <CanvasElement\r\n            key={idx}\r\n            width={eleWidth}\r\n            height={eleHeight}\r\n            onCanvasMount={(canvasData) => {\r\n              applyTransform(canvasData, {\r\n                horizontalScale: hScale,\r\n                verticalScale: vScale,\r\n              });\r\n              drawImageOnCanvas({ ctx: canvasData.ctx, dimensions, frame });\r\n            }}\r\n          />\r\n        </Stack>\r\n      )),\r\n    [dimensions, eleHeight, eleWidth, frames, hScale, result.gif, vScale]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <Stack alignItems=\"center\">\r\n        <Typography variant=\"body1\">Full Gif</Typography>\r\n\r\n        {result.partiallyTransparent ? (\r\n          <>\r\n            <Gif\r\n              src={result.gifWithBackgroundColor}\r\n              dimensions={dimensions}\r\n              alt={effectName}\r\n            />\r\n            <BackgroundPreviewTooltip />\r\n          </>\r\n        ) : (\r\n          <Stack spacing={1} pb={2}>\r\n            <Gif\r\n              src={\r\n                showTransparency && result.gifWithBackgroundColor\r\n                  ? result.gifWithBackgroundColor\r\n                  : result.gif\r\n              }\r\n              dimensions={dimensions}\r\n              alt={effectName}\r\n            />\r\n            {result.gifWithBackgroundColor != null && (\r\n              <Stack direction=\"row\">\r\n                <Typography variant=\"caption\">Show Transparency</Typography>\r\n                <Checkbox\r\n                  checked={showTransparency}\r\n                  onChange={(e) => setShowTransparency(e.target.checked)}\r\n                />\r\n              </Stack>\r\n            )}\r\n          </Stack>\r\n        )}\r\n      </Stack>\r\n      <Divider orientation=\"vertical\" />\r\n      {renderedFrames}\r\n    </>\r\n  );\r\n};\r\n\r\ninterface ImageRowProps {\r\n  appStateEffect: AppStateEffect;\r\n}\r\n\r\nexport const ImageRow: React.FC<ImageRowProps> = ({ appStateEffect }) => {\r\n  if (appStateEffect.state.status !== 'done') {\r\n    return <CircularProgress />;\r\n  }\r\n\r\n  return (\r\n    <Inner\r\n      effectName={appStateEffect.effectName}\r\n      result={appStateEffect.state.image}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\nimport {\r\n  Box,\r\n  Button,\r\n  Divider,\r\n  Stack,\r\n  Typography,\r\n  Paper,\r\n} from '@material-ui/core';\r\nimport { saveAs } from 'file-saver';\r\n\r\nimport { IS_MOBILE } from '~/domain/env';\r\nimport type {\r\n  ParamFunction,\r\n  Effect,\r\n  AppStateEffect,\r\n  Image,\r\n  AppState,\r\n  ImageEffectResult,\r\n  EffectInput,\r\n} from '~/domain/types';\r\nimport { miscUtil } from '~/domain/utils';\r\nimport { effectByName } from '~/effects';\r\nimport { Gif } from './Gif';\r\nimport { Icon, ClickableIcon } from './Icon';\r\nimport { ImageEffectDialog } from './ImageEffectDialog';\r\nimport { ImageRow } from './ImageRow';\r\nimport { RequiresAnimationTooltip } from './RequiresAnimationTooltip';\r\n\r\ntype EffectEditDialogState =\r\n  | { open: false }\r\n  | { open: true; idx: number; isNew: boolean };\r\n\r\ninterface EffectListProps {\r\n  appState: AppState;\r\n  possibleEffects: Effect<any>[];\r\n  onEffectsChange: (t: AppStateEffect[]) => void;\r\n}\r\n\r\nconst effectKey = (t: AppStateEffect, idx: number): string =>\r\n  `${t.effectName}-${idx}-${\r\n    t.state.status === 'done' ? t.state.image.gif.substring(0, 16) : 'pending'\r\n  }`;\r\n\r\ninterface ImageEffectProps {\r\n  effect: AppStateEffect;\r\n  index: number;\r\n  currentEffects: AppStateEffect[];\r\n  setEffectEditDialogState: (state: EffectEditDialogState) => void;\r\n  onEffectsChange: EffectListProps['onEffectsChange'];\r\n  newDefaultEffect: (index: number) => AppStateEffect;\r\n}\r\n\r\nexport const ImageEffect: React.FC<ImageEffectProps> = ({\r\n  effect,\r\n  index,\r\n  currentEffects,\r\n  setEffectEditDialogState,\r\n  onEffectsChange,\r\n  newDefaultEffect,\r\n}) => {\r\n  const onEdit = React.useCallback(() => {\r\n    setEffectEditDialogState({\r\n      open: true,\r\n      idx: index,\r\n      isNew: false,\r\n    });\r\n  }, [index, setEffectEditDialogState]);\r\n\r\n  const onDelete = React.useCallback(() => {\r\n    onEffectsChange(miscUtil.removeIndex(currentEffects, index));\r\n  }, [currentEffects, index, onEffectsChange]);\r\n\r\n  const onAddAfter = React.useCallback(() => {\r\n    const newIdx = index + 1;\r\n    onEffectsChange(\r\n      miscUtil.insertInto(currentEffects, newIdx, newDefaultEffect(index))\r\n    );\r\n    setTimeout(\r\n      () =>\r\n        setEffectEditDialogState({\r\n          open: true,\r\n          idx: newIdx,\r\n          isNew: true,\r\n        }),\r\n      2\r\n    );\r\n  }, [\r\n    currentEffects,\r\n    index,\r\n    newDefaultEffect,\r\n    onEffectsChange,\r\n    setEffectEditDialogState,\r\n  ]);\r\n\r\n  const requiresAnimation = React.useMemo(() => {\r\n    if (effect.state.status !== 'done') {\r\n      return null;\r\n    }\r\n\r\n    const e = effectByName(effect.effectName);\r\n    if (e.requiresAnimation && effect.state.image.image.frames.length <= 1) {\r\n      return <RequiresAnimationTooltip />;\r\n    }\r\n\r\n    return null;\r\n  }, [effect]);\r\n\r\n  return (\r\n    <Stack>\r\n      <Paper style={{ padding: 8 }} elevation={4}>\r\n        <Stack alignItems=\"center\" spacing={2}>\r\n          <Stack direction=\"row\" spacing={2}>\r\n            <Typography variant=\"h6\">\r\n              #{index + 1}: {effect.effectName}\r\n            </Typography>\r\n            {requiresAnimation}\r\n          </Stack>\r\n          <Stack\r\n            direction=\"row\"\r\n            maxWidth={IS_MOBILE ? '300px' : 'md'}\r\n            spacing={2}\r\n            sx={{ overflowX: 'auto' }}\r\n          >\r\n            <Stack spacing={2} justifyContent=\"center\">\r\n              <ClickableIcon label=\"Edit\" name=\"settings\" onClick={onEdit} />\r\n              <ClickableIcon label=\"Delete\" name=\"delete\" onClick={onDelete} />\r\n            </Stack>\r\n            <ImageRow appStateEffect={effect} />\r\n          </Stack>\r\n        </Stack>\r\n      </Paper>\r\n      <Divider sx={{ py: 4 }}>\r\n        <Button onClick={onAddAfter} startIcon={<Icon name=\"add\" />}>\r\n          {index < currentEffects.length - 1\r\n            ? 'Insert Effect Here'\r\n            : 'Add New Effect'}\r\n        </Button>\r\n      </Divider>\r\n    </Stack>\r\n  );\r\n};\r\n\r\nexport const ImageEffectList: React.FC<EffectListProps> = ({\r\n  appState,\r\n  possibleEffects,\r\n  onEffectsChange,\r\n}) => {\r\n  const currentEffects = appState.effects;\r\n  const [effectEditDialogState, setEffectEditDialogState] =\r\n    React.useState<EffectEditDialogState>({ open: false });\r\n\r\n  const [baseImage, setBaseImage] = React.useState<\r\n    ImageEffectResult | undefined\r\n  >();\r\n\r\n  React.useEffect(() => {\r\n    if (!appState.baseImage || baseImage?.gif === appState.baseImage.gif) {\r\n      return;\r\n    }\r\n\r\n    setBaseImage(baseImage);\r\n  }, [appState, baseImage]);\r\n\r\n  /** The first image to show when the edit dialog is opened */\r\n  const dialogInitialImage = React.useMemo(():\r\n    | ImageEffectResult\r\n    | undefined => {\r\n    if (!effectEditDialogState.open) {\r\n      return undefined;\r\n    }\r\n\r\n    const prevEffect = currentEffects[effectEditDialogState.idx - 1];\r\n    if (prevEffect) {\r\n      return prevEffect.state.status === 'done'\r\n        ? prevEffect.state.image\r\n        : undefined;\r\n    }\r\n\r\n    return appState.baseImage;\r\n  }, [appState, currentEffects, effectEditDialogState]);\r\n\r\n  const currentEffect = React.useMemo((): EffectInput | undefined => {\r\n    if (!effectEditDialogState.open) {\r\n      return undefined;\r\n    }\r\n\r\n    const e = currentEffects[effectEditDialogState.idx];\r\n    return {\r\n      effect: effectByName(e.effectName),\r\n      params: e.paramsValues,\r\n    };\r\n  }, [effectEditDialogState, currentEffects]);\r\n\r\n  const newDefaultEffect = React.useCallback(\r\n    (tIdx: number): AppStateEffect => ({\r\n      effectName: possibleEffects[0].name,\r\n      paramsValues: possibleEffects[0].params.map((p: ParamFunction<any>) => {\r\n        let image: Image | undefined = undefined;\r\n        if (tIdx === 0) {\r\n          image = appState.baseImage?.image;\r\n        } else {\r\n          const previousEffect = currentEffects[tIdx];\r\n          if (previousEffect?.state.status === 'done') {\r\n            image = previousEffect.state.image.image;\r\n          }\r\n        }\r\n\r\n        return p.defaultValue(image);\r\n      }),\r\n      state: { status: 'init' },\r\n    }),\r\n    [appState, currentEffects, possibleEffects]\r\n  );\r\n\r\n  // const onMoveBefore = (idx: number) => {\r\n  //   onEffectsChange(\r\n  //     currentEffects.map((nextT, newIdx) => {\r\n  //       if (newIdx === idx - 1) {\r\n  //         // This is the next item in the list\r\n  //         return currentEffects[newIdx + 1];\r\n  //       } else if (idx === newIdx) {\r\n  //         // This is the previous item\r\n  //         return currentEffects[idx - 1];\r\n  //       } else {\r\n  //         return nextT;\r\n  //       }\r\n  //     })\r\n  //   );\r\n  // };\r\n\r\n  // const onMoveAfter = (idx: number) => {\r\n  //   onEffectsChange(\r\n  //     currentEffects.map((nextT, newIdx) => {\r\n  //       if (newIdx === idx + 1) {\r\n  //         // This is the previous item in the list\r\n  //         return currentEffects[newIdx - 1];\r\n  //       } else if (idx === newIdx) {\r\n  //         // This is the next item\r\n  //         return currentEffects[idx + 1];\r\n  //       } else {\r\n  //         return nextT;\r\n  //       }\r\n  //     })\r\n  //   );\r\n  // };\r\n\r\n  const onAddNew = React.useCallback(() => {\r\n    onEffectsChange(\r\n      miscUtil.insertInto(currentEffects, 0, newDefaultEffect(0))\r\n    );\r\n    setTimeout(\r\n      () =>\r\n        setEffectEditDialogState({\r\n          open: true,\r\n          idx: 0,\r\n          isNew: true,\r\n        }),\r\n      2\r\n    );\r\n  }, [currentEffects, newDefaultEffect, onEffectsChange]);\r\n\r\n  const finalGif = React.useMemo((): string | undefined => {\r\n    const lastEffect = currentEffects[currentEffects.length - 1];\r\n    if (!lastEffect) {\r\n      return undefined;\r\n    }\r\n\r\n    if (lastEffect.state.status !== 'done') {\r\n      return undefined;\r\n    }\r\n\r\n    return lastEffect.state.image.gif;\r\n  }, [currentEffects]);\r\n\r\n  const dialogOnChangeEffect = React.useCallback(\r\n    (\r\n      newEffect: EffectInput,\r\n      computedImage: ImageEffectResult | undefined\r\n    ): void => {\r\n      if (!effectEditDialogState.open) {\r\n        return;\r\n      }\r\n\r\n      onEffectsChange(\r\n        miscUtil.replaceIndex(\r\n          currentEffects,\r\n          effectEditDialogState.idx,\r\n          () => ({\r\n            effectName: newEffect.effect.name,\r\n            paramsValues: newEffect.params,\r\n            state: computedImage\r\n              ? { status: 'done', image: computedImage }\r\n              : { status: 'init' },\r\n          })\r\n        )\r\n      );\r\n      setEffectEditDialogState({ open: false });\r\n    },\r\n    [currentEffects, effectEditDialogState, onEffectsChange]\r\n  );\r\n\r\n  const dialogOnCancel = React.useCallback(() => {\r\n    if (effectEditDialogState.open && effectEditDialogState.isNew) {\r\n      // They pressed cancel on a new effect, so just remove the one we added.\r\n      onEffectsChange(\r\n        miscUtil.removeIndex(currentEffects, effectEditDialogState.idx)\r\n      );\r\n    }\r\n    setEffectEditDialogState({ open: false });\r\n  }, [currentEffects, effectEditDialogState, onEffectsChange]);\r\n\r\n  const onSaveGif = React.useCallback(() => {\r\n    if (finalGif != null) {\r\n      saveAs(finalGif, appState.fname || 'image.gif');\r\n    }\r\n  }, [finalGif, appState]);\r\n\r\n  // Hide this effect index, as it's a new effect\r\n  const hiddenIdx = React.useMemo(() => {\r\n    if (!effectEditDialogState.open) {\r\n      return Number.MAX_SAFE_INTEGER;\r\n    }\r\n\r\n    return effectEditDialogState.isNew\r\n      ? effectEditDialogState.idx\r\n      : Number.MAX_SAFE_INTEGER;\r\n  }, [effectEditDialogState]);\r\n\r\n  return (\r\n    <Stack>\r\n      <ImageEffectDialog\r\n        open={effectEditDialogState.open}\r\n        possibleEffects={possibleEffects}\r\n        onChangeEffect={dialogOnChangeEffect}\r\n        onCancel={dialogOnCancel}\r\n        initialImage={dialogInitialImage}\r\n        currentEffect={currentEffect}\r\n        currFps={appState.fps}\r\n        currRandomSeed=\"partymoji\"\r\n      />\r\n      <Box>\r\n        <Divider sx={{ pb: 4 }}>\r\n          <Button startIcon={<Icon name=\"add\" />} onClick={onAddNew} name=\"add\">\r\n            Insert First Effect\r\n          </Button>\r\n        </Divider>\r\n        {currentEffects.map(\r\n          (t, tIdx) =>\r\n            tIdx !== hiddenIdx && (\r\n              <ImageEffect\r\n                key={effectKey(t, tIdx)}\r\n                index={tIdx}\r\n                currentEffects={currentEffects}\r\n                effect={t}\r\n                setEffectEditDialogState={setEffectEditDialogState}\r\n                onEffectsChange={onEffectsChange}\r\n                newDefaultEffect={newDefaultEffect}\r\n              />\r\n            )\r\n        )}\r\n      </Box>\r\n      {finalGif != null && (\r\n        <Paper style={{ padding: 8 }} elevation={4}>\r\n          <Stack alignItems=\"center\" spacing={2}>\r\n            <Typography variant=\"h6\">Final Result</Typography>\r\n            <Gif src={finalGif} alt={appState.fname || 'image.gif'} />\r\n            <Button\r\n              variant=\"contained\"\r\n              onClick={onSaveGif}\r\n              startIcon={<Icon name=\"save_alt\" />}\r\n            >\r\n              Save Gif\r\n            </Button>\r\n          </Stack>\r\n        </Paper>\r\n      )}\r\n    </Stack>\r\n  );\r\n};\r\n","import type { AppState, ImageEffectResult } from '~/domain/types';\r\nimport { miscUtil, imageImportUtil, imageUtil } from '~/domain/utils';\r\n\r\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\r\n\r\ninterface SerializedAppState {\r\n  baseImage: string | undefined;\r\n  effects: {\r\n    effectName: string;\r\n    paramsValues: any[];\r\n    state: { status: 'init' };\r\n  }[];\r\n  version: number;\r\n  fname?: string | undefined;\r\n  fps: number;\r\n}\r\n\r\nexport const getStoredAppState = async (): Promise<AppState | undefined> => {\r\n  try {\r\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\r\n    if (stored) {\r\n      const savedState = JSON.parse(stored);\r\n      if (Array.isArray(savedState.effects)) {\r\n        const state = savedState as SerializedAppState;\r\n        // Need to re-hydrate the baseImage's image data, as we don't save that to local storage\r\n        let hydratedBaseImage: ImageEffectResult | undefined = undefined;\r\n        let imageFps = 20;\r\n        if (typeof state.baseImage === 'string') {\r\n          if (state.baseImage.startsWith('data:image/gif')) {\r\n            const blob = miscUtil.dataURItoBlob(state.baseImage);\r\n            const f = new File([blob], state.fname!); // Can't have a baseImage without a filename\r\n            const { image, fps } = await imageImportUtil.readImage(f);\r\n            hydratedBaseImage = {\r\n              gif: state.baseImage,\r\n              gifWithBackgroundColor: state.baseImage,\r\n              image,\r\n              partiallyTransparent: false,\r\n            };\r\n            imageFps = fps;\r\n          } else {\r\n            // Non-gif\r\n            const { image } = await imageImportUtil.readImage(\r\n              savedState.baseImage\r\n            );\r\n            hydratedBaseImage = {\r\n              gif: state.baseImage,\r\n              gifWithBackgroundColor: state.baseImage,\r\n              image,\r\n              partiallyTransparent: imageUtil.isPartiallyTransparent(image),\r\n            };\r\n          }\r\n        }\r\n        return {\r\n          ...state,\r\n          baseImage: hydratedBaseImage,\r\n          fps: imageFps,\r\n        };\r\n      }\r\n    }\r\n  } catch (err) {\r\n    // @ts-ignore\r\n    console.error('Error loading state from local storage', err.stack || err);\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nexport const saveAppState = (state: AppState) => {\r\n  try {\r\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, serializeAppState(state));\r\n  } catch (err) {\r\n    // @ts-ignore\r\n    console.error('Error saving state to local storage', err.stack || err);\r\n  }\r\n};\r\n\r\nexport const clearAppState = () => {\r\n  try {\r\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\r\n  } catch (err) {\r\n    // @ts-ignore\r\n    console.error('Error clearing state from local storage', err.stack || err);\r\n  }\r\n};\r\n\r\nconst serializeAppState = (state: AppState): string => {\r\n  const toStore: SerializedAppState = {\r\n    ...state,\r\n    // Do not save the frame data -- it's big and can be re-hydrated on load.\r\n    baseImage: state.baseImage?.gif,\r\n    effects: state.effects.map((t): SerializedAppState['effects'][0] => ({\r\n      ...t,\r\n      // Remove the computed image for the state before storing.\r\n      // Like the base image frame data, it can be recreated when the app first loads.\r\n      state: { status: 'init' },\r\n    })),\r\n  };\r\n  return JSON.stringify(toStore);\r\n};\r\n","import React from 'react';\r\nimport { Alert, AlertColor, Snackbar } from '@material-ui/core';\r\n\r\nexport type AlertValue = { message: string; severity: AlertColor } | null;\r\n\r\ninterface AlertContext {\r\n  alert: AlertValue;\r\n  setAlert: (alert: AlertValue) => void;\r\n}\r\n\r\nexport const alertContext = React.createContext<AlertContext>({\r\n  alert: null,\r\n  setAlert: () => {\r\n    throw new Error('Context not initialized');\r\n  },\r\n});\r\n\r\nexport const AlertProvider: React.FC = ({ children }) => {\r\n  const [alertValue, setAlertValue] = React.useState<AlertValue>(null);\r\n\r\n  return (\r\n    <alertContext.Provider\r\n      value={{ alert: alertValue, setAlert: setAlertValue }}\r\n    >\r\n      {children}\r\n    </alertContext.Provider>\r\n  );\r\n};\r\n\r\nexport const AlertSnackbar: React.FC = () => {\r\n  const { alert, setAlert } = React.useContext(alertContext);\r\n  return (\r\n    <Snackbar open={alert != null}>\r\n      {alert == null ? undefined : (\r\n        <Alert severity={alert.severity} onClose={() => setAlert(null)}>\r\n          {alert.message}\r\n        </Alert>\r\n      )}\r\n    </Snackbar>\r\n  );\r\n};\r\n\r\nexport const useSetAlert = () => {\r\n  const { setAlert } = React.useContext(alertContext);\r\n  return setAlert;\r\n};\r\n","import React from 'react';\r\nimport {\r\n  Button,\r\n  Container,\r\n  Divider,\r\n  Paper,\r\n  Stack,\r\n  Typography,\r\n} from '@material-ui/core';\r\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\r\n\r\nimport { Help } from '~/components/Help';\r\nimport { ImagePicker } from '~/components/ImagePicker';\r\nimport { ImageEffectList } from '~/components/ImageEffectList';\r\nimport { Icon } from '~/components/Icon';\r\n\r\nimport { computeGifsForState, getEffectsDiff } from '~/domain/computeGifs';\r\nimport type { AppState, AppStateEffect } from '~/domain/types';\r\nimport { miscUtil } from '~/domain/utils';\r\nimport { ENV, debugLog, IS_MOBILE } from '~/domain/env';\r\n\r\nimport * as localStorage from '~/localStorage';\r\nimport { sliderParam } from '~/params/sliderParam';\r\nimport { POSSIBLE_EFFECTS } from '~/effects';\r\nimport { AlertProvider, AlertSnackbar, useSetAlert } from '~/AlertContext';\r\nimport { ProcessorQueueProvider } from '~/domain/useProcessingQueue';\r\n\r\n// Number of millis to wait after a change before recomputing the gif\r\nconst COMPUTE_DEBOUNCE_MILLIS = 1000;\r\n\r\n// Increase this by 1 when there's a breaking change to the app state.\r\n// Don't change this unless we have to!\r\nconst CURRENT_APP_STATE_VERSION = 7;\r\n\r\nconst DEFAULT_FPS = 20;\r\nconst fpsParam = sliderParam({\r\n  name: 'Final Gif Frames per Second',\r\n  defaultValue: DEFAULT_FPS,\r\n  min: 1,\r\n  max: 60,\r\n});\r\n\r\nconst DEFAULT_STATE: AppState = {\r\n  version: CURRENT_APP_STATE_VERSION,\r\n  effects: [],\r\n  baseImage: undefined,\r\n  fps: DEFAULT_FPS,\r\n};\r\n\r\nconst Inner: React.FC = () => {\r\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\r\n  const [doCompute, setDoCompute] = React.useState<\r\n    { compute: true; startIndex: number } | { compute: false }\r\n  >({ compute: false });\r\n  const [computeTimer, setComputeTimer] = React.useState<null | NodeJS.Timeout>(\r\n    null\r\n  );\r\n\r\n  const setAlert = useSetAlert();\r\n\r\n  React.useEffect(() => {\r\n    if (IS_MOBILE) {\r\n      setAlert({\r\n        severity: 'warning',\r\n        message:\r\n          'This app is not well optimized for mobile. Your experience may not be great.',\r\n      });\r\n    }\r\n  }, [setAlert]);\r\n\r\n  React.useEffect(() => {\r\n    (async () => {\r\n      // If we have local storage state on startup, then reload that\r\n      const stored = await localStorage.getStoredAppState();\r\n      if (stored) {\r\n        if (stored.version === CURRENT_APP_STATE_VERSION) {\r\n          setStateRaw(stored);\r\n          setDoCompute({ compute: true, startIndex: 0 });\r\n        } else {\r\n          // TODO Might be nice to tell the user we erased their previous stuff\r\n          localStorage.clearAppState();\r\n        }\r\n      }\r\n    })();\r\n  }, []);\r\n\r\n  const setState = React.useCallback(\r\n    (\r\n      fn: (oldState: AppState) => AppState,\r\n      { compute }: { compute: 'no' | 'now' | 'later' }\r\n    ) => {\r\n      setStateRaw((oldState) => {\r\n        const newState = fn(oldState);\r\n        localStorage.saveAppState(newState);\r\n\r\n        if (ENV === 'DEV') {\r\n          (window as any).STATE = newState;\r\n        }\r\n\r\n        if (compute !== 'no' && newState.baseImage != null) {\r\n          // Compute the gif some time from now.\r\n          // Other changes within this time should push the compute time back\r\n          if (computeTimer) {\r\n            clearTimeout(computeTimer);\r\n            setComputeTimer(null);\r\n          }\r\n\r\n          const effectsDiff = getEffectsDiff({\r\n            prevState: oldState,\r\n            currState: newState,\r\n          });\r\n\r\n          if (effectsDiff.diff) {\r\n            if (compute === 'now') {\r\n              setDoCompute({ compute: true, startIndex: effectsDiff.index });\r\n            } else {\r\n              setDoCompute({ compute: false });\r\n              setComputeTimer(\r\n                setTimeout(() => {\r\n                  setComputeTimer(null);\r\n                  setDoCompute({\r\n                    compute: true,\r\n                    startIndex: effectsDiff.index,\r\n                  });\r\n                }, COMPUTE_DEBOUNCE_MILLIS)\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        return newState;\r\n      });\r\n    },\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    []\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    debugLog('UseEffect, doCompute', doCompute);\r\n    if (doCompute.compute === false) {\r\n      return;\r\n    }\r\n\r\n    // TODO What happens if new changes come in while we're already computing?\r\n    // Need to throw away previous results and calculate new ones.\r\n    setDoCompute({ compute: false });\r\n    (async () => {\r\n      setState(\r\n        (prevState) => ({\r\n          ...prevState,\r\n          effects: prevState.effects.map((t, i): AppStateEffect => {\r\n            if (i < doCompute.startIndex) {\r\n              return t;\r\n            } else {\r\n              return {\r\n                ...t,\r\n                state: { status: 'computing' },\r\n              };\r\n            }\r\n          }),\r\n        }),\r\n        { compute: 'no' }\r\n      );\r\n      // TODO error handling\r\n      await computeGifsForState({\r\n        state,\r\n        onCompute: (image, computeIdx) => {\r\n          setState(\r\n            (prevState) => ({\r\n              ...prevState,\r\n              effects: miscUtil.replaceIndex(\r\n                prevState.effects,\r\n                computeIdx,\r\n                (t): AppStateEffect => ({\r\n                  ...t,\r\n                  state: { status: 'done', image },\r\n                })\r\n              ),\r\n            }),\r\n            { compute: 'no' }\r\n          );\r\n        },\r\n        startEffectIndex: doCompute.startIndex,\r\n      });\r\n    })();\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [doCompute]);\r\n\r\n  return (\r\n    <>\r\n      <ScopedCssBaseline />\r\n      <Container maxWidth={IS_MOBILE ? 'sm' : 'md'}>\r\n        <Stack\r\n          spacing={4}\r\n          justifyContent=\"space-evenly\"\r\n          alignItems=\"center\"\r\n          width={IS_MOBILE ? 'sm' : undefined}\r\n          divider={<Divider />}\r\n        >\r\n          <Typography variant=\"h2\" pt={4}>\r\n            Partymoji\r\n          </Typography>\r\n          <Stack spacing={4} divider={<Divider />}>\r\n            <Section>\r\n              <Help />\r\n            </Section>\r\n            <Section>\r\n              <Stack spacing={1} alignItems=\"center\">\r\n                <Typography variant=\"h5\">Source Image</Typography>\r\n                <ImagePicker\r\n                  name=\"Upload a source image\"\r\n                  currentImage={state.baseImage}\r\n                  onChange={(baseImage, fname, fps) => {\r\n                    if (IS_MOBILE) {\r\n                      const [width, height] = baseImage.image.dimensions;\r\n                      if (width > 512 || height > 512) {\r\n                        setAlert({\r\n                          severity: 'error',\r\n                          message:\r\n                            'The image you chose is too large to work well on mobile.',\r\n                        });\r\n\r\n                        return;\r\n                      }\r\n                    }\r\n\r\n                    setState(\r\n                      (prevState) => ({\r\n                        ...prevState,\r\n                        baseImage,\r\n                        fname,\r\n                        fps,\r\n                      }),\r\n                      { compute: 'now' }\r\n                    );\r\n                  }}\r\n                />\r\n                {fpsParam.fn({\r\n                  value: state.fps,\r\n                  onChange: (fps) =>\r\n                    setState(\r\n                      (prevState) => ({\r\n                        ...prevState,\r\n                        fps,\r\n                      }),\r\n                      { compute: 'later' }\r\n                    ),\r\n                })}\r\n              </Stack>\r\n            </Section>\r\n            {state.baseImage != null && (\r\n              <>\r\n                <Section>\r\n                  <ImageEffectList\r\n                    appState={state}\r\n                    possibleEffects={POSSIBLE_EFFECTS}\r\n                    onEffectsChange={(effects) =>\r\n                      setState(\r\n                        (prevState) => ({\r\n                          ...prevState,\r\n                          effects,\r\n                        }),\r\n                        { compute: 'now' }\r\n                      )\r\n                    }\r\n                  />\r\n                </Section>\r\n                <Section>\r\n                  <Stack spacing={3}>\r\n                    <Typography variant=\"h5\">Clear Effects</Typography>\r\n                    <Typography variant=\"body1\">\r\n                      <Icon name=\"warning\" color=\"warning\" /> Clicking this\r\n                      button will clear all effects for the image\r\n                    </Typography>\r\n                    <Button\r\n                      startIcon={<Icon name=\"clear\" />}\r\n                      sx={{ maxWidth: '300px' }}\r\n                      variant=\"contained\"\r\n                      color=\"warning\"\r\n                      onClick={() => {\r\n                        const newState: AppState = {\r\n                          ...DEFAULT_STATE,\r\n                          baseImage: state.baseImage,\r\n                        };\r\n                        setStateRaw(newState);\r\n                        localStorage.saveAppState(newState);\r\n                      }}\r\n                    >\r\n                      Clear Effects\r\n                    </Button>\r\n                  </Stack>\r\n                </Section>\r\n              </>\r\n            )}\r\n            <a\r\n              href=\"https://github.com/MikeyBurkman/partymoji\"\r\n              target=\"_blank\"\r\n              rel=\"noreferrer\"\r\n            >\r\n              <img\r\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\r\n                width={64}\r\n                height={64}\r\n                alt=\"Github Link\"\r\n              ></img>\r\n            </a>\r\n          </Stack>\r\n        </Stack>\r\n      </Container>\r\n\r\n      <Stack pt={8}>\r\n        <AlertSnackbar />\r\n      </Stack>\r\n    </>\r\n  );\r\n};\r\n\r\nconst Section: React.FC = ({ children }) => (\r\n  <Paper style={{ padding: 16, maxWidth: IS_MOBILE ? '300px' : undefined }}>\r\n    {children}\r\n  </Paper>\r\n);\r\n\r\n// Icons at https://fonts.google.com/icons?selected=Material+Icons\r\n\r\nexport const App: React.FC = () => {\r\n  return (\r\n    <ProcessorQueueProvider>\r\n      <AlertProvider>\r\n        <Inner />\r\n      </AlertProvider>\r\n    </ProcessorQueueProvider>\r\n  );\r\n};\r\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\r\nimport React, { ErrorInfo } from 'react';\r\n\r\ninterface Props {\r\n  onClearLocalStorage: () => void;\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean;\r\n}\r\n\r\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\r\n  public state: State = {\r\n    hasError: false,\r\n  };\r\n\r\n  static getDerivedStateFromError(error: Error): State {\r\n    console.error(error);\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\r\n    console.error('Uncaught error:', error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <Stack spacing={1}>\r\n          <Typography variant=\"h2\">Oh no!</Typography>\r\n          <Typography variant=\"body1\">\r\n            There seems to have been an issue\r\n          </Typography>\r\n          <Typography variant=\"body2\">\r\n            If refreshing the page doesn't fix things, click the below button to\r\n            clear local storage\r\n          </Typography>\r\n          <Button\r\n            variant=\"contained\"\r\n            sx={{ maxWidth: '300px' }}\r\n            endIcon={<Icon>priority_high</Icon>}\r\n            startIcon={<Icon>priority_high</Icon>}\r\n            onClick={this.props.onClearLocalStorage}\r\n          >\r\n            Clear storage and reload\r\n          </Button>\r\n        </Stack>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n","import { createTheme, ThemeProvider } from '@material-ui/core';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { App } from './App';\r\nimport { TopLevelErrorBoundary } from '~/components/TopLevelErrorBoundary';\r\nimport * as localStorage from '~/localStorage';\r\n\r\nconst theme = createTheme({\r\n  typography: {\r\n    fontFamily: 'Raleway, Arial',\r\n  },\r\n});\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <ThemeProvider theme={theme}>\r\n      <TopLevelErrorBoundary\r\n        onClearLocalStorage={() => {\r\n          localStorage.clearAppState();\r\n          window.location.reload();\r\n        }}\r\n      >\r\n        <App />\r\n      </TopLevelErrorBoundary>\r\n    </ThemeProvider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}