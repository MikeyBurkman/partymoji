{"version":3,"sources":["domain/types.ts","domain/utils.ts","domain/transforms/background-party.ts","components/Dropdown.tsx","params/dropdownParam.tsx","domain/run.ts","components/ImagePicker.tsx","domain/transforms/background-image.ts","params/textParam.tsx","params/imagePickerParam.tsx","params/floatParam.tsx","domain/transforms/bounce.ts","domain/transforms/circle.ts","domain/transforms/expand.ts","domain/transforms/fisheye.ts","params/intParam.tsx","domain/transforms/frame-count.ts","domain/transforms/grayscale.ts","domain/transforms/lightning.ts","domain/transforms/party.ts","domain/transforms/resize.ts","domain/transforms/resize-background.ts","domain/transforms/ripple.ts","domain/transforms/rotate.ts","domain/transforms/roxbury.ts","domain/transforms/shake.ts","components/Expandable.tsx","params/colorPickerParam.tsx","domain/transforms/solid-background.ts","domain/transforms/index.ts","domain/transforms/static.ts","domain/transforms/transparency.ts","domain/transforms/transpose.ts","components/ComputeBox.tsx","components/ImageTransform.tsx","components/ImageTransformList.tsx","App.tsx","index.tsx"],"names":["buildTransform","args","name","params","fn","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","getAveragePixelValue","round","clampColor","a","clamp","n","max","min","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","map","frame","data","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","getSrcPixel","writePixel","color","resizeImage","newWidth","newHeight","xRatio","yRatio","newDimensions","srcX","srcY","PARTY_COLORS","backgroundParty","srcPixel","partyColorIdx","Dropdown","selected","options","onChange","React","useState","hidden","setHidden","close","useCallback","document","removeEventListener","title","find","value","className","aria-haspopup","onClick","e","preventDefault","setTimeout","addEventListener","aria-hidden","role","style","visibility","maxHeight","overflowY","href","cn","DropdownParam","maxWidth","valid","dropdownParam","defaultValue","undefined","runTransforms","inputDataUrl","transformList","fps","seedrandom","readImage","originalImage","images","reduce","transformInput","result","transform","push","Promise","all","newImage","transparentColor","getTransparentColor","encodeTransparency","f","createGif","img","i","resolve","gif","gifEncoder","setFrameRate","setRepeat","hexColor","slice","setTransparent","writeHeader","on","chunk","dataUrl","URL","createObjectURL","Blob","type","forEach","addFrame","finish","res","rej","getPixels","err","getPixelResults","from","shape","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","ImagePicker","currentImageUrl","accept","event","files","Array","target","file","readFile","baseImage","src","alt","reader","FileReader","onload","readAsDataURL","backgroundImage","imagePickerParam","otherImage","otherImageSrc","FloatParam","parse","val","setVal","invalidText","setInvalidText","onBlur","reason","floatParam","parseFloat","isNaN","bounce","sin","PI","circle","radius","cos","expand","dist","centerX","centerY","fisheye","expanding","angle","atan2","IntParam","intParam","times","currentFrames","_","grayscale","gray","TextParam","lightningIntensities","lightning","flashIntensity","icf","party","partyColor","resize","resizeBackground","xPadding","yPadding","ripple","amplitude","period","shift","offset","rotate","sign","xRelCenter","yRelCenter","amount","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","newCoord","shake","shakeSpeed","Expandable","mainEle","children","collapsed","setCollapsed","ColorBox","backgroundColor","ColorPickerParam","console","log","disableAlpha","presetColors","onChangeComplete","colorPickerParam","POSSIBLE_TRANSFORMS","p","strength","ceil","tolerance","diff0","diff1","diff2","sqrt","transX","transY","fpsParam","ComputeBox","isDirty","computeDisabled","baseImageUrl","transforms","onComputed","loading","results","state","setState","fpsChanged","setFpsChanged","setFps","buttonDisabled","disabled","transformInputs","t","paramsValues","gifs","ImageTransform","selectedTransform","possibleTransforms","onSelect","onRemove","onMoveLeft","onMoveRight","padding","newTransformName","paramValues","param","ele","v","ImageTransformList","currentTransforms","onTransformsChange","overflowX","tIdx","filter","nextT","newIdx","nextTIdx","computedImage","display","App","dirty","computeBtnDisbled","some","every","paddingTop","rel","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.72b37082.chunk.js","sourcesContent":["import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\nexport type Frame = {\n  data: ImageData;\n};\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: Frame[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface TransformFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport type ParamValue<T> = { valid: true; value: T } | { valid: false };\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: ParamValue<T>;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nexport type ParamFunction<T> = {\n  name: string;\n  defaultValue: ParamValue<T>;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type TransformFn<Params> = (opts: TransformFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Transform<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}\n\nexport interface TransformWithParams<T extends readonly ParamFunction<any>[]> {\n  transform: Transform<T>;\n  paramsValues: ParamValue<T>[];\n}\n\nexport interface TransformInput<T extends ParamFunction<any>[]> {\n  transform: Transform<T>;\n  params: T;\n}\n\nexport const buildTransform = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}): Transform<T> => ({\n  name: args.name,\n  params: args.params,\n  fn: args.fn,\n});\n","import seedrandom from 'seedrandom';\nimport { AssertionError } from 'assert';\n\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  ImageData,\n  Image,\n  Random,\n  TransformFn,\n  TransformFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => {\n  const clamp = (n: number) => Math.max(Math.min(n, 255), 0);\n\n  return [clamp(r), clamp(g), clamp(b), clamp(a)];\n};\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return [0, 0, 0, 0]; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => {\n  const frames = image.frames.map((frame, idx) => ({\n    data: cb(frame.data, idx, image.frames.length),\n  }));\n  return {\n    dimensions: image.dimensions,\n    frames,\n  };\n};\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/** Create a new array [0, 1, 2, ...N-1] */\nexport const repeat = (times: number): number[] =>\n  [...new Array(times)].map((_, i) => i);\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\nexport const writePixel = (args: {\n  image: ImageData;\n  dimensions: Dimensions;\n  coord: Coord;\n  color: Color;\n}): void => {\n  const idx = getImageIndex(args.dimensions, args.coord[0], args.coord[1]);\n  args.image[idx] = args.color[0];\n  args.image[idx + 1] = args.color[1];\n  args.image[idx + 2] = args.color[2];\n  args.image[idx + 3] = args.color[3];\n};\n\nexport const resizeImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newDimensions: Dimensions = [newWidth, newHeight];\n\n  const newFrames = image.frames.map((frame) => {\n    const transformedImageData = new Uint8Array(newWidth * newHeight * 4);\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const pixel = getPixelFromSource(image.dimensions, frame.data, [\n          srcX,\n          srcY,\n        ]);\n        writePixel({\n          color: pixel,\n          coord: [x, y],\n          dimensions: newDimensions,\n          image: transformedImageData,\n        });\n      }\n    }\n    return {\n      data: transformedImageData,\n    };\n  });\n\n  return {\n    frames: newFrames,\n    dimensions: [newWidth, newHeight],\n  };\n};\n","import { buildTransform, Color } from '../types';\nimport { mapImage, isTransparent } from '../utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const backgroundParty = buildTransform({\n  name: 'Background Party',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    // Make the transparent parts colorful\n    if (isTransparent(srcPixel)) {\n      const partyColorIdx = Math.floor(\n        (frameIndex / frameCount) * PARTY_COLORS.length\n      );\n      return PARTY_COLORS[partyColorIdx];\n    }\n\n    return srcPixel;\n  }),\n});\n","import React from 'react';\nimport cn from 'classnames';\n\ninterface DropdownProps {\n  selected: any;\n  options: readonly { name: string; value: any }[];\n  onChange: (value: any) => void;\n}\n\nexport const Dropdown: React.FC<DropdownProps> = ({\n  selected,\n  options,\n  onChange,\n}) => {\n  const [hidden, setHidden] = React.useState(true);\n  const close = React.useCallback(() => {\n    document.removeEventListener('click', close);\n    setHidden(true);\n  }, []);\n  const title = options.find((x) => x.value === selected)?.name ?? '';\n  return (\n    <div className=\"dropdown is-active\">\n      <div className=\"dropdown-trigger\">\n        <button\n          className=\"button\"\n          aria-haspopup=\"true\"\n          onClick={(e) => {\n            e.preventDefault();\n            if (hidden) {\n              setHidden(false);\n              setTimeout(() => document.addEventListener('click', close), 0);\n            } else {\n              close();\n            }\n          }}\n        >\n          <span>{title}</span>\n          <span className=\"icon is-small\">\n            <i className=\"fas fa-angle-down\" aria-hidden=\"true\"></i>\n          </span>\n        </button>\n      </div>\n      <div\n        className=\"dropdown-menu\"\n        role=\"menu\"\n        style={{ visibility: hidden ? 'hidden' : 'visible' }}\n      >\n        <div\n          className=\"dropdown-content\"\n          style={{ maxHeight: '16em', overflowY: 'auto' }}\n        >\n          {options.map(({ name, value }) => (\n            // eslint-disable-next-line jsx-a11y/anchor-is-valid\n            <a\n              key={value}\n              href=\"#\"\n              className={cn('dropdown-item', {\n                'is-active': selected === value,\n              })}\n              onClick={(e) => {\n                e.preventDefault();\n                close();\n                onChange(value);\n              }}\n            >\n              {name}\n            </a>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Dropdown } from '../components/Dropdown';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: any }[];\n  value?: any;\n  onChange: (v: ParamValue<any>) => void;\n}> = ({ name, options, value, onChange }) => {\n  return (\n    <div className=\"field\" style={{ maxWidth: '12em' }}>\n      <label className=\"label\">{name}</label>\n      <div className=\"control\">\n        <Dropdown\n          onChange={(value) => onChange({ valid: true, value })}\n          selected={value}\n          options={options}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport function dropdownParam<T>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  defaultValue?: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          options={args.options}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\n\nimport { Color, TransformInput, Image, Dimensions, ImageData } from './types';\nimport {\n  toHexColor,\n  getPixelFromSource,\n  randomColor,\n  fromHexColor,\n  isTransparent,\n} from './utils';\n\n// Returns a list of gif data URLs, for each transform\nexport const runTransforms = async (\n  inputDataUrl: string,\n  transformList: TransformInput<any>[],\n  fps: number\n): Promise<string[]> => {\n  const random = seedrandom(inputDataUrl);\n\n  const originalImage = await readImage(inputDataUrl);\n\n  const images: Image[] = [];\n  transformList.reduce((image, transformInput) => {\n    const result = transformInput.transform.fn({\n      image,\n      parameters: transformInput.params,\n      random,\n    });\n    images.push(result);\n    return result;\n  }, originalImage);\n\n  return await Promise.all(\n    images.map(async (newImage) => {\n      const transparentColor = getTransparentColor(newImage, random);\n\n      // Transform any of our transparent pixels to what our gif understands to be transparent\n      const image = encodeTransparency(\n        newImage.frames.map((f) => f.data),\n        transparentColor\n      );\n\n      return await createGif(newImage.dimensions, image, transparentColor, fps);\n    })\n  );\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  frames: ImageData[],\n  transparentColor: Color | undefined\n): ImageData[] => {\n  const image = frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = transparentColor[3];\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 255; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return image;\n};\n\nconst createGif = async (\n  dimensions: Dimensions,\n  frames: ImageData[],\n  transparentColor: Color | undefined,\n  fps: number\n): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, getPixelResults: { shape: Dimensions; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        } else {\n          return res({\n            frames: [\n              {\n                data: Uint8Array.from(getPixelResults.data),\n              },\n            ],\n            dimensions: [getPixelResults.shape[0], getPixelResults.shape[1]],\n          });\n        }\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame.data, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  width,\n  height,\n  onChange,\n}) => (\n  <>\n    <div className=\"file block\">\n      <label className=\"file-label\">\n        <input\n          className=\"file-input\"\n          type=\"file\"\n          accept=\"image/png,image/jpg\"\n          name=\"source-png\"\n          onChange={async (event) => {\n            const files = Array.from(event.target.files ?? []);\n            const file = files[0];\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }}\n        />\n        <span className=\"file-cta\">\n          <span className=\"file-icon\">\n            <i className=\"fas fa-upload\"></i>\n          </span>\n          <span className=\"file-label\">{name}</span>\n        </span>\n      </label>\n    </div>\n    {currentImageUrl && (\n      <img\n        width={width}\n        height={height}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import { dropdownParam } from '../../params/dropdownParam';\nimport { imagePickerParam } from '../../params/imagePickerParam';\nimport { buildTransform } from '../types';\nimport {\n  isTransparent,\n  getPixelFromSource,\n  mapFrames,\n  mapCoords,\n  resizeImage,\n} from '../utils';\n\nexport const backgroundImage = buildTransform({\n  name: 'Background Image',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    dropdownParam({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ] as const,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const otherImage = resizeImage({\n      image: parameters[0].image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n    });\n    const type = parameters[1];\n\n    return mapFrames(image, (data) => {\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n        const otherImageSrc = getPixelFromSource(\n          otherImage.dimensions,\n          otherImage.frames[0].data,\n          coord\n        );\n\n        if (type === 'background') {\n          // Only print the other image if the src image is transparent here\n          return isTransparent(src) ? otherImageSrc : src;\n        } else {\n          return isTransparent(otherImageSrc) ? src : otherImageSrc;\n        }\n      });\n    });\n  },\n});\n","import React from 'react';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value?: string;\n  onChange: (v: ParamValue<string>) => void;\n}> = ({ name, value, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <div className=\"field\" style={{ maxWidth: '12em' }}>\n      <label className=\"label\">{name}</label>\n      <div className=\"control has-icons-left has-icons-right\">\n        <input\n          type=\"text\"\n          value={val}\n          name={name}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() =>\n            onChange(value ? { valid: true, value } : { valid: false })\n          }\n        />\n      </div>\n    </div>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  defaultValue?: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      onChange={params.onChange}\n      value={params.value.valid ? params.value.value : undefined}\n    />\n  ),\n});\n","import React from 'react';\nimport { readImage } from '../domain/run';\n\nimport { ParamFunction, Image } from '../domain/types';\nimport { ImagePicker } from '../components/ImagePicker';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<{ dataUrl: string; image: Image }> {\n  return {\n    name,\n    defaultValue: { valid: false },\n    fn: (params) => (\n      <div className=\"field\" style={{ maxWidth: '12em' }}>\n        <label className=\"label\">{name}</label>\n        <div className=\"control has-icons-left has-icons-right\">\n          <ImagePicker\n            currentImageUrl={\n              params.value.valid ? params.value.value.dataUrl : undefined\n            }\n            width={64}\n            height={64}\n            onChange={async (dataUrl) => {\n              const image = await readImage(dataUrl);\n              params.onChange({ valid: true, value: { dataUrl, image } });\n            }}\n          />\n        </div>\n      </div>\n    ),\n  };\n}\n","import React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value?: number;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <div className=\"field\" style={{ maxWidth: '12em' }}>\n      <label className=\"label\">{name}</label>\n      <div className=\"control has-icons-left has-icons-right\">\n        <input\n          className=\"input\"\n          type=\"text\"\n          defaultValue={value}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n          onBlur={onBlur}\n        />\n      </div>\n      {invalidText && <p className=\"help is-danger\">{invalidText}</p>}\n    </div>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const bounce = buildTransform({\n  name: 'Bounce',\n  params: [\n    floatParam({\n      name: 'Bounce Speed',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [x, y] = coord;\n    const yOffset =\n      y +\n      Math.round(\n        parameters[0] * Math.sin((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([x, yOffset]);\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const circle = buildTransform({\n  name: 'Circle',\n  params: [\n    floatParam({\n      name: 'Radius',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [radius] = parameters;\n    const [x, y] = coord;\n    const xOffset = Math.round(\n      radius * Math.sin(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    const yOffset = Math.round(\n      radius * Math.cos(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    return getSrcPixel([x + xOffset, y + yOffset]);\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const expand = buildTransform({\n  name: 'Expand',\n  params: [\n    floatParam({\n      name: 'Radius',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const dist = Math.cos(idx * 2 * Math.PI) * parameters[0];\n\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const [width, height] = dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildTransform({\n  name: 'Fisheye',\n  params: [floatParam({ name: 'radius', defaultValue: 10, min: 0 })],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const expanding = idx < 0.5;\n      const [width, height] = dimensions;\n      const dist = (expanding ? idx : 1 - idx) * parameters[0];\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import React from 'react';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value?: number;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <div className=\"field\" style={{ maxWidth: '12em' }}>\n      <label className=\"label\">{name}</label>\n      <div className=\"control has-icons-left has-icons-right\">\n        <input\n          className=\"input\"\n          type=\"text\"\n          defaultValue={value}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n          onBlur={onBlur}\n        />\n      </div>\n      {invalidText && <p className=\"help is-danger\">{invalidText}</p>}\n    </div>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n)) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { Frame, buildTransform } from '../types';\nimport { repeat } from '../utils';\nimport { intParam } from '../../params/intParam';\n\nexport const frameCount = buildTransform({\n  name: 'Frame Count',\n  params: [\n    intParam({\n      name: 'Number of Frames',\n      defaultValue: 10,\n      min: 1,\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [frameCount] = parameters;\n\n    const currentFrames = image.frames;\n\n    // Resulting image will contain frameCount frames.\n    // If the original image had less than that, then we'll copy the last frame until we have enough.\n    // If the original has more frames, then we'll discard the last ones.\n    const frames = repeat(frameCount).map(\n      (i): Frame => ({\n        data: currentFrames[i]\n          ? currentFrames[i].data\n          : currentFrames[currentFrames.length - 1].data,\n      })\n    );\n\n    return {\n      dimensions: image.dimensions,\n      frames,\n    };\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent, getAveragePixelValue } from '../utils';\n\nexport const grayscale = buildTransform({\n  name: 'Grayscale',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [gray, gray, gray, 255];\n  }),\n});\n","import { buildTransform } from '../types';\nimport seedrandom from 'seedrandom';\n\nimport { Color } from '../types';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n  isTransparent,\n} from '../utils';\nimport { textParam } from '../../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildTransform({\n  name: 'Lightning',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      defaultValue: 'lightning',\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const random = seedrandom(parameters[0]);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildTransform, Color } from '../types';\nimport { isTransparent, getAveragePixelValue, mapImage } from '../utils';\n\nconst PARTY_COLORS: Color[] = [\n  [255, 141, 139, 255],\n  [254, 214, 137, 255],\n  [136, 255, 137, 255],\n  [135, 255, 255, 255],\n  [139, 181, 254, 255],\n  [215, 140, 255, 255],\n  [255, 140, 255, 255],\n  [255, 104, 247, 255],\n  [254, 108, 183, 255],\n  [255, 105, 104, 255],\n];\n\nexport const party = buildTransform({\n  name: 'Party',\n  params: [],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const partyColorIdx = Math.floor(\n      (frameIndex / frameCount) * PARTY_COLORS.length\n    );\n    const partyColor = PARTY_COLORS[partyColorIdx];\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [\n      (gray * partyColor[0]) / 255,\n      (gray * partyColor[1]) / 255,\n      (gray * partyColor[2]) / 255,\n      255,\n    ];\n  }),\n});\n","import { buildTransform } from '../types';\nimport { resizeImage } from '../utils';\nimport { intParam } from '../../params/intParam';\n\nexport const resize = buildTransform({\n  name: 'Resize',\n  params: [\n    intParam({\n      name: 'Width',\n      defaultValue: 128,\n      min: 1,\n    }),\n    intParam({\n      name: 'Height',\n      defaultValue: 128,\n      min: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const [newWidth, newHeight] = parameters;\n    return resizeImage({\n      image,\n      newWidth,\n      newHeight,\n    });\n  },\n});\n","import { buildTransform, Color, Dimensions } from '../types';\nimport { assert, getPixelFromSource, writePixel } from '../utils';\nimport { intParam } from '../../params/intParam';\n\nexport const resizeBackground = buildTransform({\n  name: 'Resize Background',\n  params: [\n    intParam({ name: 'Width', defaultValue: 128, min: 0 }),\n    intParam({ name: 'Height', defaultValue: 128, min: 0 }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [width, height] = image.dimensions;\n    const [newWidth, newHeight] = parameters;\n    assert(\n      newWidth >= width,\n      'New width for resize-background needs to be greater than or equal to the original'\n    );\n    assert(\n      newHeight >= height,\n      'New height for resize-background needs to be greater than or equal to the original'\n    );\n\n    const newDimensions: Dimensions = [newWidth, newHeight];\n\n    const xPadding = (newWidth - width) / 2;\n    const yPadding = (newHeight - height) / 2;\n\n    const newFrames = image.frames.map((frame) => {\n      const transformedImageData = new Uint8Array(newWidth * newHeight * 4);\n      for (let y = 0; y < newHeight; y += 1) {\n        for (let x = 0; x < newWidth; x += 1) {\n          const pixel: Color =\n            x > xPadding &&\n            x < newWidth - xPadding &&\n            y > yPadding &&\n            y < newHeight - yPadding\n              ? getPixelFromSource(image.dimensions, frame.data, [\n                  x - xPadding,\n                  y - yPadding,\n                ])\n              : [0, 0, 0, 0];\n          writePixel({\n            color: pixel,\n            coord: [x, y],\n            dimensions: newDimensions,\n            image: transformedImageData,\n          });\n        }\n      }\n      return {\n        data: transformedImageData,\n      };\n    });\n\n    return {\n      frames: newFrames,\n      dimensions: newDimensions,\n    };\n  },\n});\n","import { buildTransform } from '../types';\nimport { mapFrames, mapCoords, getPixelFromSource } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const ripple = buildTransform({\n  name: 'Ripple',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: 10,\n    }),\n    floatParam({\n      name: 'Period',\n      defaultValue: 2,\n      min: 0,\n    }),\n  ],\n  fn: ({ image, parameters }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const [amplitude, period] = parameters;\n\n      const height = image.dimensions[1];\n      const shift = (frameIndex / frameCount) * 2 * Math.PI;\n      return mapCoords(image.dimensions, ([x, y]) => {\n        const offset = Math.round(\n          amplitude * Math.sin((y / height) * period * Math.PI + shift)\n        );\n\n        return getPixelFromSource(image.dimensions, data, [x + offset, y]);\n      });\n    }),\n});\n","import { mapImage } from '../utils';\nimport { buildTransform, Coord } from '../types';\nimport { dropdownParam } from '../../params/dropdownParam';\n\nexport const rotate = buildTransform({\n  name: 'Rotate',\n  params: [\n    dropdownParam({\n      name: 'Direction',\n      defaultValue: -1,\n      options: [\n        { name: 'Clockwise', value: -1 },\n        { name: 'Counter-Clockwise', value: 1 },\n      ],\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const [sign] = parameters;\n      const centerX = dimensions[0] / 2;\n      const centerY = dimensions[1] / 2;\n      const [x, y] = coord;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const amount = (frameIndex / frameCount) * (sign || 1);\n      const cos = Math.cos(2 * Math.PI * amount);\n      const sin = Math.sin(2 * Math.PI * amount);\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { mapFrames, mapCoords, getPixelFromSource } from '../utils';\nimport { buildTransform, Coord } from '../types';\n\nexport const roxbury = buildTransform({\n  name: 'Roxbury',\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const idx = frameIndex / frameCount;\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(idx * 4);\n      const phaseIdx = (idx - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      const cos = Math.cos(-angle * 1.35);\n      const sin = Math.sin(-angle * 1.35);\n\n      const rotatePointX = image.dimensions[0] * 0.25;\n      const rotatePointY = image.dimensions[1] * 0.7;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const [x, y] = coord;\n        const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n        const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n        const newCoord: Coord = [\n          Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n          Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n        ];\n\n        return getPixelFromSource(image.dimensions, data, newCoord);\n      });\n    }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const shake = buildTransform({\n  name: 'Shake',\n  params: [floatParam({ name: 'Shake Speed', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [shakeSpeed] = parameters;\n    const [x, y] = coord;\n    const xOffset =\n      x +\n      Math.round(\n        shakeSpeed * Math.cos((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([xOffset, y]);\n  }),\n});\n","import React from 'react';\nimport cn from 'classnames';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <div>\n      <div\n        className=\"is-clickable columns\"\n        onClick={() => setCollapsed(!collapsed)}\n      >\n        <div className=\"column is-four-fifths\">{mainEle}</div>\n        <span className=\"icon column\">\n          <i\n            className={cn(\n              'fas',\n              collapsed ? 'fa-chevron-up' : 'fa-chevron-down'\n            )}\n          ></i>\n        </span>\n      </div>\n      {!collapsed && <div>{children}</div>}\n    </div>\n  );\n};\n","import React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\n\nimport { ParamValue, ParamFunction, Color } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value?: Color;\n  onChange: (v: ParamValue<Color>) => void;\n}> = ({ name, value, onChange }) => {\n  console.log('value', value);\n  return (\n    <Expandable\n      mainEle={\n        <div className=\"columns\">\n          <label className=\"label column is-four-fifths\">{name}</label>\n          <span className=\"column\">{value && <ColorBox color={value} />}</span>\n        </div>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={value ? toHexColor(value) : undefined}\n        onChangeComplete={(c) =>\n          onChange({ valid: true, value: fromHexColor(c.hex) })\n        }\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue?: Color;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent, fromHexColor } from '../utils';\nimport { colorPickerParam } from '../../params/colorPickerParam';\n\nexport const solidBackground = buildTransform({\n  name: 'Solid Background',\n  params: [\n    colorPickerParam({\n      name: 'Background Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color] = parameters;\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","import { backgroundParty } from './background-party';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { circle } from './circle';\nimport { expand } from './expand';\nimport { fisheye } from './fisheye';\nimport { frameCount } from './frame-count';\nimport { grayscale } from './grayscale';\nimport { lightning } from './lightning';\nimport { party } from './party';\nimport { resize } from './resize';\nimport { resizeBackground } from './resize-background';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { solidBackground } from './solid-background';\nimport { staticc } from './static';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nexport const POSSIBLE_TRANSFORMS = [\n  frameCount,\n  backgroundParty,\n  backgroundImage,\n  bounce,\n  circle,\n  expand,\n  fisheye,\n  grayscale,\n  lightning,\n  party,\n  resize,\n  resizeBackground,\n  ripple,\n  rotate,\n  roxbury,\n  shake,\n  solidBackground,\n  staticc,\n  transparency,\n  transpose,\n];\n","import { buildTransform } from '../types';\nimport { mapImage, isTransparent } from '../utils';\nimport { floatParam } from '../../params/floatParam';\n\nexport const staticc = buildTransform({\n  name: 'Static',\n  params: [floatParam({ name: 'Strength', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      return [0, 0, 0, 0];\n    }\n\n    const inverse = Math.ceil(random() * strength) > 1;\n\n    return inverse ? [255 - src[0], 255 - src[1], 255 - src[2], src[3]] : src;\n  }),\n});\n","import { buildTransform } from '../types';\nimport { fromHexColor, mapImage } from '../utils';\nimport { colorPickerParam } from '../../params/colorPickerParam';\nimport { intParam } from '../../params/intParam';\n\nexport const transparency = buildTransform({\n  name: 'Transparent Color',\n  params: [\n    colorPickerParam({\n      name: 'Transparent Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    intParam({\n      name: 'Tolerance',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color, tolerance] = parameters;\n    const p = getSrcPixel(coord);\n    const diff0 = p[0] - color[0];\n    const diff1 = p[1] - color[1];\n    const diff2 = p[2] - color[2];\n    const diff = Math.sqrt(diff0 * diff0 + diff1 * diff1 + diff2 * diff2);\n    if ((diff / 255) * 100 <= tolerance) {\n      return [p[0], p[1], p[2], 0];\n    }\n    return p;\n  }),\n});\n","import { buildTransform } from '../types';\nimport { mapImage } from '../utils';\nimport { intParam } from '../../params/intParam';\n\nexport const transpose = buildTransform({\n  name: 'Transpose',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [transX, transY] = parameters;\n    const [x, y] = coord;\n\n    return getSrcPixel([x + transX, y + transY]);\n  }),\n});\n","import React from 'react';\nimport cn from 'classnames';\nimport { assert } from '../domain/utils';\nimport { runTransforms } from '../domain/run';\nimport { TransformInput, TransformWithParams } from '../domain/types';\nimport { intParam } from '../params/intParam';\n\ninterface ComputeBoxProps {\n  isDirty: boolean;\n  computeDisabled: boolean;\n  baseImageUrl?: string;\n  transforms: TransformWithParams<any>[];\n  onComputed: () => void;\n}\n\ntype ComputeState = { loading: false; results: string[] } | { loading: true };\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = intParam({\n  name: 'Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 0,\n});\n\nexport const ComputeBox: React.FC<ComputeBoxProps> = ({\n  isDirty,\n  computeDisabled,\n  baseImageUrl,\n  transforms,\n  onComputed,\n}) => {\n  const [state, setState] = React.useState<ComputeState>({\n    loading: false,\n    results: [],\n  });\n  const [fpsChanged, setFpsChanged] = React.useState(false);\n  const [fps, setFps] = React.useState(DEFAULT_FPS);\n\n  const buttonDisabled = computeDisabled && !fpsChanged;\n\n  return (\n    <div className=\"box\">\n      <h3 className=\"title\">Create Gif</h3>\n      <div className=\"block\">\n        {fpsParam.fn({\n          value: { valid: true, value: fps },\n          onChange: (x) => {\n            if (x.valid) {\n              setFps(x.value);\n              setFpsChanged(true);\n            }\n          },\n        })}\n      </div>\n      <div className=\"block\">\n        <button\n          className={cn('button', 'block', { 'is-loading': state.loading })}\n          disabled={buttonDisabled}\n          onClick={async () => {\n            const transformInputs = transforms.map(\n              (t): TransformInput<any> => ({\n                transform: t.transform,\n                params: t.paramsValues.map((p) => {\n                  assert(p.valid);\n                  return p.value;\n                }),\n              })\n            );\n            setState({ loading: true });\n            setTimeout(async () => {\n              assert(\n                baseImageUrl,\n                'No source image, this button should be disabled!'\n              );\n              const gifs = await runTransforms(\n                baseImageUrl,\n                transformInputs,\n                fps\n              );\n              setState({\n                loading: false,\n                results: gifs,\n              });\n              setFpsChanged(false);\n              onComputed();\n            });\n          }}\n        >\n          <span>Compute</span>{' '}\n          {(isDirty || fpsChanged) && (\n            <span className=\"icon is-small\">\n              <i className=\"fas fa-exclamation-circle\" aria-hidden=\"true\"></i>\n            </span>\n          )}\n        </button>\n      </div>\n      <div className=\"block\">\n        <div className=\"columns\">\n          {!state.loading &&\n            state.results.map((gif, idx) => (\n              <div className=\"column\">\n                <div>{transforms[idx].transform.name}</div>\n                <img\n                  src={gif}\n                  alt={`gif-${transforms[idx].transform.name}`}\n                ></img>\n              </div>\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Dropdown } from './Dropdown';\n\nimport { ParamFunction, ParamValue, Transform } from '../domain/types';\n\ninterface SelectedTransform {\n  transform: Transform<any>;\n  paramValues: ParamValue<any>[];\n}\n\ninterface ImageTransformProps {\n  selectedTransform: SelectedTransform;\n  possibleTransforms: Transform<any>[];\n  onSelect: (selected: SelectedTransform) => void;\n  onRemove: () => void;\n  onMoveLeft?: () => void;\n  onMoveRight?: () => void;\n}\n\nexport const ImageTransform: React.FC<ImageTransformProps> = ({\n  selectedTransform,\n  possibleTransforms,\n  onSelect,\n  onRemove,\n  onMoveLeft,\n  onMoveRight,\n}) => {\n  return (\n    <div className=\"card\" style={{ padding: '0.75rem', maxWidth: '20rem' }}>\n      <div className=\"card-header-title\">\n        <div className=\"columns is-desktop\">\n          <div className=\"column\">\n            <Dropdown\n              selected={selectedTransform.transform.name}\n              options={possibleTransforms.map((t) => ({\n                name: t.name,\n                value: t.name,\n              }))}\n              onChange={(newTransformName) => {\n                const t = possibleTransforms.find(\n                  (t) => t.name === newTransformName\n                )!;\n                // Reset all the params when you select a new transform\n                onSelect({\n                  transform: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n            />\n          </div>\n          <div className=\"column columns\">\n            {onMoveLeft && (\n              <div className=\"icon column is-clickable\" onClick={onMoveLeft}>\n                <i className=\"fas fa-arrow-left\" aria-hidden=\"true\"></i>\n              </div>\n            )}\n            {onMoveRight && (\n              <div className=\"icon column is-clickable\" onClick={onMoveRight}>\n                <i className=\"fas fa-arrow-right\" aria-hidden=\"true\"></i>\n              </div>\n            )}\n            <div className=\"icon column is-clickable\" onClick={onRemove}>\n              <i className=\"fas fa-trash\" aria-hidden=\"true\"></i>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"card-content\">\n        {selectedTransform.transform.params.map(\n          // Create elements for each of the parameters for the selectect transform.\n          // Each of these would get an onChange event so we know when the user has\n          //  selected a value.\n          (param: ParamFunction<any>, idx: number) => {\n            const ele = param.fn({\n              value: selectedTransform.paramValues[idx],\n              onChange: (v) => {\n                console.log('changing to ', v);\n                onSelect({\n                  ...selectedTransform,\n                  paramValues: selectedTransform.paramValues.map((x, i) => {\n                    if (i === idx) {\n                      return v;\n                    }\n                    return x;\n                  }),\n                });\n              },\n            });\n            return <div key={param.name}>{ele}</div>;\n          }\n        )}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { ParamFunction, Transform, TransformWithParams } from '../domain/types';\nimport { ImageTransform } from './ImageTransform';\n\ninterface TransformListProps {\n  currentTransforms: TransformWithParams<any>[];\n  possibleTransforms: Transform<any>[];\n  onTransformsChange: (t: TransformWithParams<any>[]) => void;\n}\n\nexport const ImageTransformList: React.FC<TransformListProps> = ({\n  currentTransforms,\n  possibleTransforms,\n  onTransformsChange,\n}) => (\n  <div className=\"box\" style={{ overflowY: 'clip', overflowX: 'scroll' }}>\n    <h3 className=\"title\">Image Transforms</h3>\n    <div className=\"block\">\n      <button\n        className=\"button\"\n        onClick={() =>\n          onTransformsChange([\n            ...currentTransforms,\n            {\n              transform: possibleTransforms[0],\n              paramsValues: possibleTransforms[0].params.map(\n                (p: ParamFunction<any>) => p.defaultValue\n              ),\n            },\n          ])\n        }\n      >\n        New Transform\n      </button>\n    </div>\n    <div className=\"columns\">\n      {currentTransforms.map((t, tIdx) => (\n        <div className=\"column\">\n          <ImageTransform\n            possibleTransforms={possibleTransforms}\n            selectedTransform={{\n              transform: t.transform,\n              paramValues: t.paramsValues,\n            }}\n            onRemove={() =>\n              onTransformsChange(\n                currentTransforms.filter((nextT, newIdx) => newIdx !== tIdx)\n              )\n            }\n            onMoveLeft={\n              tIdx > 0\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx - 1) {\n                          // This is the next item in the list\n                          return currentTransforms[newIdx + 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the previous item\n                          return currentTransforms[tIdx - 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onMoveRight={\n              tIdx < currentTransforms.length - 1\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx + 1) {\n                          // This is the previous item in the list\n                          return currentTransforms[newIdx - 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the next item\n                          return currentTransforms[tIdx + 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onSelect={(selected) =>\n              onTransformsChange(\n                currentTransforms.map((nextT, nextTIdx) => {\n                  if (tIdx === nextTIdx) {\n                    // This is the one we just changed\n                    return {\n                      transform: selected.transform,\n                      paramsValues: selected.paramValues,\n                      computedImage: undefined,\n                    };\n                  }\n                  // Reset all the images if we changed anything\n                  return {\n                    transform: nextT.transform,\n                    paramsValues: nextT.paramsValues,\n                    computedImage: undefined,\n                  };\n                })\n              )\n            }\n          />\n        </div>\n      ))}\n      <div className=\"box\" style={{ display: 'none' }}>\n        {/* Placeholder, because the last box has no bottom padding */}\n      </div>\n    </div>\n  </div>\n);\n","import React from 'react';\n\nimport { POSSIBLE_TRANSFORMS } from './domain/transforms';\nimport { ParamFunction, ParamValue, Transform } from './domain/types';\nimport { ComputeBox } from './components/ComputeBox';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageTransformList } from './components/ImageTransformList';\n\nconst DEBUG = false;\n\ntype AppState = {\n  baseImage?: string;\n  transforms: {\n    transform: Transform<any>;\n    paramsValues: ParamValue<any>[];\n    computedImage?: string;\n  }[];\n  dirty: boolean;\n};\n\nexport const App: React.FC = () => {\n  const [state, setState] = React.useState<AppState>({\n    dirty: false,\n    transforms: [],\n    baseImage: undefined,\n  });\n\n  if (DEBUG) {\n    (window as any).STATE = state;\n  }\n\n  const computeBtnDisbled =\n    !state.baseImage ||\n    state.transforms.length === 0 ||\n    !state.dirty ||\n    state.transforms.some((t) => {\n      const params = t.transform.params as ParamFunction<any>[];\n      return (\n        params.length > 0 && t.paramsValues.every((p, i) => p.valid === false)\n      );\n    });\n\n  return (\n    <section>\n      <div className=\"container\">\n        <h1 className=\"title\" style={{ paddingTop: '16px' }}>\n          Partymoji\n        </h1>\n        <div>\n          <div className=\"box\">\n            <h3 className=\"title\">Source Image</h3>\n            <ImagePicker\n              name=\"Choose a source image\"\n              currentImageUrl={state.baseImage}\n              onChange={(baseImage) => {\n                setState({\n                  ...state,\n                  baseImage,\n                  dirty: true,\n                });\n              }}\n            />\n          </div>\n          <ImageTransformList\n            currentTransforms={state.transforms}\n            possibleTransforms={POSSIBLE_TRANSFORMS}\n            onTransformsChange={(transforms) =>\n              setState({\n                ...state,\n                dirty: true,\n                transforms,\n              })\n            }\n          />\n          <ComputeBox\n            isDirty={state.dirty}\n            baseImageUrl={state.baseImage}\n            computeDisabled={computeBtnDisbled}\n            transforms={state.transforms}\n            onComputed={() =>\n              setState({\n                ...state,\n                dirty: false,\n              })\n            }\n          />\n          {DEBUG && (\n            <div>\n              <code>{JSON.stringify(state, null, 2)}</code>\n            </div>\n          )}\n          <a\n            href=\"https://github.com/MikeyBurkman/partymoji\"\n            target=\"_blank\"\n            rel=\"noreferrer\"\n          >\n            <img\n              src=\"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png\"\n              width={64}\n              height={64}\n              alt=\"Github Link\"\n            ></img>\n          </a>\n        </div>\n      </div>\n    </section>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}