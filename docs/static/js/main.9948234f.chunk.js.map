{"version":3,"sources":["domain/types.ts","domain/utils.ts","components/HelpTooltip.tsx","params/sliderParam.tsx","params/intParam.tsx","transforms/adjust-image.ts","components/Expandable.tsx","params/colorPickerParam.tsx","transforms/background-color.ts","params/dropdownParam.tsx","domain/run.ts","components/ImagePicker.tsx","transforms/background-image.ts","params/imagePickerParam.tsx","transforms/bounce.ts","transforms/circle.ts","params/variableLengthParam.tsx","transforms/colors.ts","transforms/colors-background.ts","params/floatParam.tsx","transforms/double-vision.ts","transforms/expand.ts","transforms/fisheye.ts","params/huePickerParam.tsx","transforms/hue-shift.ts","params/textParam.tsx","transforms/lightning.ts","transforms/nuke.ts","transforms/party.ts","transforms/party-background.ts","transforms/pinwheel.ts","transforms/pinwheel-party.ts","transforms/radiance.ts","transforms/index.ts","transforms/radiance-party.ts","transforms/resize-image.ts","transforms/ripple.ts","transforms/rotate.ts","transforms/roxbury.ts","transforms/shake.ts","transforms/static.ts","transforms/static-background.ts","transforms/transparent-color.ts","transforms/transpose.ts","components/ComputeBox.tsx","components/ImageTransform.tsx","components/ImageTransformList.tsx","components/ImportExport.tsx","components/TopLevelErrorBoundary.tsx","App.tsx","index.tsx"],"names":["buildTransform","args","name","params","description","fn","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","clamp","n","min","max","clampColor","a","TRANSPARENT_COLOR","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","map","frame","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","getSrcPixel","scaleImage","newWidth","newHeight","xRatio","yRatio","newImage","createNewImage","srcX","srcY","color","getPixel","setPixel","resizeImage","sourceWidth","sourceHeight","xPadding","round","yPadding","range","weightedValue","percent","v1","v2","shiftHue","hue","amount","convert","hsl","l","rgb","newR","newG","newB","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","colorFromeHue","HelpTooltip","Tooltip","title","Icon","fontSize","SliderParam","value","step","onChange","Stack","spacing","direction","Typography","variant","sx","paddingLeft","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","e","valid","sliderParam","defaultValue","undefined","IntParam","parse","React","useState","val","setVal","invalidText","setInvalidText","FormControl","TextField","error","onBlur","reason","target","FormHelperText","intParam","isNaN","adjustImage","brightness","contrast","saturation","hasFrameCount","hasScaleChange","isBiggerImage","averageValue","calculateAverageValue","currImage","setFrameCount","currColor","adjustBrightness","adjustContrast","adjustSaturation","currentFrames","i","totalLight","totalSamples","f","src","h","newLight","rawAmount","newSat","abs","Expandable","mainEle","children","collapsed","setCollapsed","ClickAwayListener","onClickAway","Box","Button","onClick","style","textTransform","Collapse","in","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","p","DropdownParam","options","Select","autoWidth","event","t","MenuItem","dropdownParam","runTransforms","transformList","inputDataUrl","fps","onImageFinished","seedrandom","readImage","originalImage","results","currentImage","transformInput","result","transform","transparentColor","getTransparentColor","encodeTransparency","createGif","gif","push","img","Promise","resolve","gifEncoder","setFrameRate","setRepeat","hexColor","slice","setTransparent","writeHeader","data","on","chunk","dataUrl","URL","createObjectURL","Blob","type","forEach","addFrame","finish","res","rej","getPixels","err","shape","from","numFrames","sliceSize","subarray","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","set","attempts","col","has","ImagePicker","currentImageUrl","startIcon","maxWidth","component","hidden","accept","files","Array","file","readFile","baseImage","maxHeight","alt","reader","FileReader","onload","readAsDataURL","backgroundImage","imagePickerParam","otherImage","frameProgress","otherImageFrame","otherImageSrc","bounce","sin","circle","radius","cos","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","oldP","IconButton","newParams","filter","variableLengthParam","colors","srcPixel","chosenColor","gray","getAveragePixelValue","colorsBackground","FloatParam","floatParam","parseFloat","doubleVision","amplitude","dir","expand","dist","centerX","centerY","fisheye","expanding","angle","HuePickerParam","hueShift","newHue","TextParam","lightningIntensities","lightning","textParam","flashIntensity","icf","nuke","threshold","party","shiftSpeed","adjust","newH","partyBackground","DEFAULT_COLORS","pinwheel","offsetX","offsetY","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","center","pointAngle","colorIdx","pinwheelParty","isBackground","POSSIBLE_TRANSFORMS","colorList","flatMap","maxDist","sqrt","distFromCenter","resizeImageUtil","period","shift","offset","sign","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","newCoord","strength","isStatic","ceil","grey","inverse","tolerance","diff0","diff1","diff2","transX","transY","sort","transformByName","find","fpsParam","ComputeBox","computeDisabled","appState","onFpsChange","onComputed","loading","computeTime","computeState","setComputeState","progress","setProgress","endIcon","dirty","disabled","transformInputs","transforms","transformName","paramsValues","setTimeout","start","Date","now","currIdx","console","stack","CircularProgress","LinearProgress","Divider","Grid","container","padding","columns","xs","sm","md","item","ImageTransform","selectedTransform","possibleTransforms","index","onSelect","onRemove","onMoveLeft","onMoveRight","elevation","fullWidth","Autocomplete","disableClearable","newTransformName","paramValues","renderInput","label","divider","Fragment","ImageTransformList","currentTransforms","onTransformsChange","rowSpacing","tIdx","nextT","newIdx","selected","nextTIdx","computedImage","ImportExport","state","onImport","info","setInfo","isInvalid","setInvalid","showInfo","text","showError","output","lz","JSON","stringify","navigator","clipboard","writeText","readText","clipboardContents","isArray","Alert","severity","TopLevelErrorBoundary","hasError","errorInfo","this","props","onClearLocalStorage","Component","DEBUG","LOCAL_STORAGE_KEY","DEFAULT_STATE","App","setStateRaw","useEffect","stored","window","localStorage","getItem","savedState","setState","newState","setItem","computeBtnDisbled","some","every","removeItem","location","reload","ScopedCssBaseline","Container","justifyContent","pt","href","rel","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9948234f.chunk.js","sourcesContent":["import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: ImageData[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface TransformFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport type ParamValue<T> = { valid: true; value: T } | { valid: false };\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: ParamValue<T>;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nexport type ParamFunction<T> = {\n  name: string;\n  defaultValue: ParamValue<T>;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type TransformFn<Params> = (opts: TransformFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Transform<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}\n\nexport interface TransformWithParams<T extends readonly ParamFunction<any>[]> {\n  transformName: string;\n  paramsValues: ParamValue<T>[];\n}\n\nexport interface TransformInput<T extends ParamFunction<any>[]> {\n  transform: Transform<T>;\n  params: T;\n}\n\nexport const buildTransform = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n}): Transform<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  fn: args.fn,\n});\n\nexport interface AppState {\n  baseImage?: string;\n  transforms: {\n    transformName: string;\n    paramsValues: ParamValue<any>[];\n    computedImage?: string;\n  }[];\n  fps: number;\n  dirty: boolean;\n}\n","import seedrandom from 'seedrandom';\nimport { AssertionError } from 'assert';\nimport { range } from 'remeda';\nimport * as convert from 'color-convert';\n\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  ImageData,\n  Image,\n  Random,\n  TransformFn,\n  TransformFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our transformation functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Change the dimensions of the image, scaling it to make it fit the new dimensions\n */\nexport const scaleImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const color = getPixel({\n          image,\n          frameIndex,\n          coord: [srcX, srcY],\n        });\n        setPixel({\n          image: newImage,\n          frameIndex,\n          color,\n          coord: [x, y],\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\n/**\n * Will change the image dimensions without altering the scale.\n * If the new dimensions are larger, the image will be centered.\n * If the new dimensions are smaller, it'll be cropped\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const [sourceWidth, sourceHeight] = image.dimensions;\n\n  const xPadding = Math.round((newWidth - sourceWidth) / 2);\n  const yPadding = Math.round((newHeight - sourceHeight) / 2);\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        const color: Color =\n          x > xPadding &&\n          x < newWidth - xPadding &&\n          y > yPadding &&\n          y < newHeight - yPadding\n            ? getPixel({\n                image,\n                frameIndex,\n                coord: [x - xPadding, y - yPadding],\n              })\n            : TRANSPARENT_COLOR;\n        setPixel({\n          image: newImage,\n          frameIndex,\n          coord: [x, y],\n          color,\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8Array(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Shifts the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Returns the angle in degrees (0 to 360) betwee the two coordinates\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromeHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n","import React from 'react';\nimport { Tooltip, Icon } from '@material-ui/core';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\n\nimport { ParamValue, ParamFunction } from '../domain/types';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={value}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) =>\n            onChange({ valid: true, value: value as number })\n          }\n        />\n        <Typography variant=\"body2\">{value}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue:\n      args.defaultValue !== undefined\n        ? { valid: true, value: args.defaultValue }\n        : { valid: false },\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { range } from 'remeda';\n\nimport { buildTransform, Color, Image } from '../domain/types';\nimport {\n  clampColor,\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n  scaleImage,\n  weightedValue,\n} from '../domain/utils';\nimport * as convert from 'color-convert';\nimport { sliderParam } from '../params/sliderParam';\nimport { intParam } from '../params/intParam';\n\nexport const adjustImage = buildTransform({\n  name: 'Adjust Image',\n  description: 'Leave a parameter at 0 if you want to not change it',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description:\n        'Set how many frames of animation there will be. Leave at 0 to not change the current frame count.',\n      defaultValue: 0,\n      min: 0,\n      max: 60,\n    }),\n    intParam({\n      name: 'Width',\n      description: 'Leave at 0 to not change the image',\n      defaultValue: 0,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description: 'Leave at 0 to not change the image',\n      defaultValue: 0,\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const [frameCount, newWidth, newHeight, brightness, contrast, saturation] =\n      parameters;\n\n    const hasFrameCount = frameCount !== 0;\n\n    const hasScaleChange = newWidth > 0 && newHeight > 0;\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage =\n      newWidth * newHeight > image.dimensions[0] * image.dimensions[1];\n\n    const averageValue = contrast !== 0 ? calculateAverageValue(image) : 0;\n\n    let currImage = image;\n\n    if (hasFrameCount && frameCount < image.frames.length) {\n      // Reducing the number of frames, so do that first so we have fewer pixels to change\n      currImage = setFrameCount(currImage, frameCount);\n    }\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = scaleImage({ image: currImage, newWidth, newHeight });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      mapCoords(currImage.dimensions, (coord) => {\n        let currColor = getPixelFromSource(\n          currImage.dimensions,\n          imageData,\n          coord\n        );\n\n        if (brightness !== 0) {\n          currColor = adjustBrightness(currColor, brightness);\n        }\n\n        if (contrast !== 0) {\n          currColor = adjustContrast(currColor, averageValue, contrast);\n        }\n\n        if (saturation !== 0) {\n          currColor = adjustSaturation(currColor, saturation);\n        }\n\n        return currColor;\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = scaleImage({ image: currImage, newWidth, newHeight });\n    }\n\n    // Finally change the number of frames if we're adding frames\n    if (hasFrameCount && frameCount > image.frames.length) {\n      currImage = setFrameCount(currImage, frameCount);\n    }\n\n    return currImage;\n  },\n});\n\nconst setFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had less than that, then we'll copy the last frame until we have enough.\n  // If the original has more frames, then we'll discard the last ones.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) =>\n      currentFrames[i]\n        ? currentFrames[i]\n        : currentFrames[currentFrames.length - 1]\n    ),\n  };\n};\n\nconst calculateAverageValue = (image: Image): number => {\n  const [width, height] = image.dimensions;\n\n  // Find average value of all pixels\n  let totalLight = 0;\n  let totalSamples = 0;\n  for (let f = 0; f < image.frames.length; f += 1) {\n    for (let x = 0; x < width; x += 1) {\n      for (let y = 0; y < height; y += 1) {\n        const src = getPixelFromSource(image.dimensions, image.frames[f], [\n          x,\n          y,\n        ]);\n        if (!isTransparent(src)) {\n          const [r, g, b] = src;\n          const [, , l] = convert.rgb.hsl(r, g, b);\n          totalLight += l;\n          totalSamples += 1;\n        }\n      }\n    }\n  }\n  return totalLight / totalSamples;\n};\n\n// Amount = -100 to 100\nconst adjustContrast = (\n  color: Color,\n  averageValue: number,\n  amount: number\n): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const diff = l - averageValue;\n  const newLight = l + diff * (amount / 100);\n  const [newR, newG, newB] = convert.hsl.rgb([h, s, newLight]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nconst adjustBrightness = (color: Color, amount: number): Color => {\n  const rawAmount = (amount / 100) * 255;\n  return clampColor([\n    color[0] + rawAmount,\n    color[1] + rawAmount,\n    color[2] + rawAmount,\n    color[3],\n  ]);\n};\n\n// Amount = -100 to 100\nconst adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n","import React from 'react';\nimport {\n  Collapse,\n  Icon,\n  Box,\n  Button,\n  ClickAwayListener,\n  Stack,\n} from '@material-ui/core';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Box>\n        <Button\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ textTransform: 'none', color: 'black' }}\n        >\n          <Stack direction=\"row\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'expand_less' : 'expand_more'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Box>\n    </ClickAwayListener>\n  );\n};\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\n\nimport { ParamValue, ParamFunction, Color } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value?: Color;\n  description?: string;\n  onChange: (v: ParamValue<Color>) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={value ? toHexColor(value) : undefined}\n        onChangeComplete={(c) =>\n          onChange({ valid: true, value: fromHexColor(c.hex) })\n        }\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue?: Color;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent, fromHexColor } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\n\nexport const backgroundColor = buildTransform({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color] = parameters;\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","import {\n  FormControl,\n  Select,\n  MenuItem,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: any }[];\n  value?: any;\n  description?: string;\n  onChange: (v: ParamValue<any>) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <Select\n          autoWidth\n          value={value}\n          onChange={(event) =>\n            onChange({ valid: true, value: event.target.value })\n          }\n        >\n          {options.map((t) => (\n            <MenuItem key={t.value} value={t.value}>\n              {t.name}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function dropdownParam<T>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue?: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          options={args.options}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\n\nimport { Color, TransformInput, Image, Dimensions, ImageData } from './types';\nimport {\n  toHexColor,\n  getPixelFromSource,\n  randomColor,\n  fromHexColor,\n  isTransparent,\n} from './utils';\n\ninterface RunArgs {\n  inputDataUrl: string;\n  transformList: TransformInput<any>[];\n  fps: number;\n  onImageFinished: () => void;\n}\n\ninterface ImageResult {\n  gif: string;\n  width: number;\n  height: number;\n}\n\n// Returns a list of gif data URLs, for each transform\nexport const runTransforms = async ({\n  transformList,\n  inputDataUrl,\n  fps,\n  onImageFinished,\n}: RunArgs): Promise<ImageResult[]> => {\n  const random = seedrandom(inputDataUrl);\n\n  const originalImage = await readImage(inputDataUrl);\n\n  const results: ImageResult[] = [];\n  let currentImage = originalImage;\n\n  for (const transformInput of transformList) {\n    const result = transformInput.transform.fn({\n      image: currentImage,\n      parameters: transformInput.params,\n      random,\n    });\n\n    const transparentColor = getTransparentColor(result, random);\n\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    const image = encodeTransparency(result.frames, transparentColor);\n\n    const gif = await createGif(\n      result.dimensions,\n      image,\n      transparentColor,\n      fps\n    );\n\n    onImageFinished();\n\n    currentImage = result;\n    results.push({\n      gif,\n      width: result.dimensions[0],\n      height: result.dimensions[1],\n    });\n  }\n\n  return results;\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  frames: ImageData[],\n  transparentColor: Color | undefined\n): ImageData[] => {\n  const image = frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = transparentColor[3];\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 255; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return image;\n};\n\nconst createGif = async (\n  dimensions: Dimensions,\n  frames: ImageData[],\n  transparentColor: Color | undefined,\n  fps: number\n): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          // Single frame\n          return res({\n            frames: [Uint8Array.from(results.data)],\n            dimensions: [results.shape[0], results.shape[1]],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8Array[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          frames.push(\n            results.data.subarray(i * sliceSize, (i + 1) * sliceSize)\n          );\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import { Button, Icon, Stack } from '@material-ui/core';\nimport React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  onChange,\n}) => (\n  <Stack spacing={4}>\n    <Button\n      startIcon={<Icon>image</Icon>}\n      sx={{ maxWidth: '300px' }}\n      variant=\"contained\"\n      component=\"label\"\n    >\n      {name}\n      <input\n        type=\"file\"\n        hidden\n        accept=\"image/png,image/jpg,image/gif\"\n        name=\"source-png\"\n        onChange={async (event) => {\n          const files = Array.from(event.target.files ?? []);\n          const file = files[0];\n          if (file) {\n            // Will be undefined if user clicked the cancel button\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }\n        }}\n      />\n    </Button>\n    {currentImageUrl && (\n      <img\n        style={{ maxWidth: '300px', maxHeight: 'auto' }}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </Stack>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import { dropdownParam } from '../params/dropdownParam';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { buildTransform } from '../domain/types';\nimport {\n  isTransparent,\n  mapFrames,\n  mapCoords,\n  resizeImage,\n  getPixel,\n} from '../domain/utils';\n\nexport const backgroundImage = buildTransform({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    dropdownParam({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ] as const,\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const otherImage = resizeImage({\n      image: parameters[0].image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n    });\n    const type = parameters[1];\n\n    return mapFrames(image, (data, frameIndex) => {\n      return mapCoords(image.dimensions, (coord) => {\n        const frameProgress = frameIndex / image.frames.length;\n        const otherImageFrame = Math.floor(\n          frameProgress * otherImage.frames.length\n        );\n        const otherImageSrc = getPixel({\n          image: otherImage,\n          frameIndex: otherImageFrame,\n          coord,\n        });\n\n        const src = getPixel({\n          image,\n          frameIndex,\n          coord,\n        });\n\n        if (type === 'background') {\n          // Only print the other image if the src image is transparent here\n          return isTransparent(src) ? otherImageSrc : src;\n        } else {\n          return isTransparent(otherImageSrc) ? src : otherImageSrc;\n        }\n      });\n    });\n  },\n});\n","import React from 'react';\n\nimport { readImage } from '../domain/run';\nimport { ParamFunction, Image } from '../domain/types';\nimport { ImagePicker } from '../components/ImagePicker';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<{ dataUrl: string; image: Image }> {\n  return {\n    name,\n    defaultValue: { valid: false },\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={\n          params.value.valid ? params.value.value.dataUrl : undefined\n        }\n        name={name}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ valid: true, value: { dataUrl, image } });\n        }}\n      />\n    ),\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildTransform({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [x, y] = coord;\n    const yOffset =\n      y +\n      Math.round(\n        parameters[0] * Math.sin((frameIndex / frameCount) * 2 * Math.PI)\n      );\n\n    return getSrcPixel([x, yOffset]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildTransform({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [radius] = parameters;\n    const [x, y] = coord;\n    const xOffset = Math.round(\n      radius * Math.sin(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    const yOffset = Math.round(\n      radius * Math.cos(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    return getSrcPixel([x + xOffset, y + yOffset]);\n  }),\n});\n","import {\n  Icon,\n  IconButton,\n  Button,\n  Paper,\n  Typography,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ninterface VariableLengthProps<T> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value?: T[];\n  description?: string;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<\n    { param: ParamFunction<any>; pValue: any }[]\n  >(\n    value === undefined\n      ? []\n      : value.map((v, idx) => ({ param: createNewParam(), pValue: v }))\n  );\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: { valid: true, value: pValue },\n            onChange: (newValue) => {\n              if (newValue.valid) {\n                const p = params.map((oldP, i) => {\n                  if (idx === i) {\n                    return {\n                      param,\n                      pValue: newValue.value,\n                    };\n                  }\n                  return oldP;\n                });\n                setParams(p);\n                onChange({\n                  valid: true,\n                  value: p.map((n) => n.pValue),\n                });\n              }\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange({\n                    valid: true,\n                    value: newParams.map((n) => n.pValue),\n                  });\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue.valid ? p.defaultValue.value : undefined,\n              },\n            ];\n            setParams(newParams);\n            if (p.defaultValue.valid) {\n              onChange({\n                valid: true,\n                value: newParams.map((n) => n.pValue),\n              });\n            }\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue?: T[];\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value.valid ? params.value.value : undefined}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport {\n  isTransparent,\n  getAveragePixelValue,\n  mapImage,\n  fromHexColor,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildTransform({\n  name: 'Colors',\n  description: 'Make the image flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    const [colors] = parameters;\n\n    if (isTransparent(srcPixel)) {\n      return [0, 0, 0, 0];\n    }\n\n    const colorIdx = Math.floor((frameIndex / frameCount) * colors.length);\n    const chosenColor = colors[colorIdx];\n\n    const gray = getAveragePixelValue(srcPixel);\n\n    return [\n      (gray * chosenColor[0]) / 255,\n      (gray * chosenColor[1]) / 255,\n      (gray * chosenColor[2]) / 255,\n      255,\n    ];\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent, fromHexColor } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildTransform({\n  name: 'Colors Background',\n  description: 'Transparent pixels will flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const srcPixel = getSrcPixel(coord);\n\n    const [colors] = parameters;\n\n    // Make the transparent parts colorful\n    if (isTransparent(srcPixel)) {\n      const colorIdx = Math.floor((frameIndex / frameCount) * colors.length);\n      return colors[colorIdx];\n    }\n\n    return srcPixel;\n  }),\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamValue, ParamFunction } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildTransform({\n  name: 'Double Vision',\n  description: 'See the image in double',\n  params: [floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [amplitude] = parameters;\n    const [x, y] = coord;\n    const dir = x % 2 === 0 ? -1 : 1;\n    const xOffset = Math.round(\n      dir * amplitude * Math.sin(-2 * Math.PI * (frameIndex / frameCount))\n    );\n    return getSrcPixel([x + xOffset, y]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildTransform({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const dist = Math.cos(idx * 2 * Math.PI) * parameters[0];\n\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const [width, height] = dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildTransform({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const idx = frameIndex / frameCount;\n      const expanding = idx < 0.5;\n      const [width, height] = dimensions;\n      const dist = (expanding ? idx : 1 - idx) * parameters[0];\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const [x, y] = coord;\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport * as convert from 'color-convert';\n\nimport { ParamValue, ParamFunction } from '../domain/types';\nimport { toHexColor } from '../domain/utils';\nimport { HelpTooltip } from '../components/HelpTooltip';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor =\n    value === undefined\n      ? undefined\n      : toHexColor([...convert.hsl.rgb([value, 255, 255]), 255]);\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        onChangeComplete={({ hsl }) => onChange({ valid: true, value: hsl.h })}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage, shiftHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildTransform({\n  name: 'Hue Shift',\n  description: 'Shift the hue to some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value?: string;\n  description?: string;\n  onChange: (v: ParamValue<string>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() =>\n            onChange(val ? { valid: true, value: val } : { valid: false })\n          }\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue?: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value.valid ? params.value.value : undefined}\n    />\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport seedrandom from 'seedrandom';\n\nimport { Color } from '../domain/types';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n  isTransparent,\n} from '../domain/utils';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildTransform({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ],\n  fn: ({ image, parameters }) => {\n    const random = seedrandom(parameters[0]);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\n\nexport const nuke = buildTransform({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, frameCount, frameIndex }) => {\n    const threshold = (frameIndex / frameCount) * 255;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildTransform({\n  name: 'Party',\n  description: 'Party time!',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 8,\n      defaultValue: 1,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      frameCount,\n      frameIndex,\n      parameters: [amount, shiftSpeed],\n    }) => {\n      const adjust = (c1: number, c2: number) =>\n        (1 - amount / 100) * c1 + (amount / 100) * c2;\n      const [r, g, b, a] = getSrcPixel(coord);\n      const [, s, l] = convert.rgb.hsl([r, g, b]);\n      const newH = ((frameIndex / frameCount) * shiftSpeed * 360) % 360;\n      const [newR, newG, newB] = convert.hsl.rgb([newH, s, l]);\n      return [adjust(r, newR), adjust(g, newG), adjust(b, newB), a];\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { isTransparent, mapImage } from '../domain/utils';\nimport * as convert from 'color-convert';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const partyBackground = buildTransform({\n  name: 'Party Background',\n  description: 'Party time for the background (transparent) pixels!',\n  params: [\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 8,\n      defaultValue: 1,\n    }),\n  ],\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      frameCount,\n      frameIndex,\n      parameters: [shiftSpeed],\n    }) => {\n      const src = getSrcPixel(coord);\n      if (isTransparent(src)) {\n        const [newR, newG, newB] = convert.hsl.rgb([\n          ((frameIndex / frameCount) * shiftSpeed * 360) % 360,\n          100,\n          50,\n        ]);\n        return [newR, newG, newB, 255];\n      }\n\n      return src;\n    }\n  ),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport {\n  mapImage,\n  isTransparent,\n  fromHexColor,\n  calculateAngle,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheel = buildTransform({\n  name: 'Pinwheel',\n  description: 'Create a pinwheel of colors',\n  params: [\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: -40,\n    }),\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated. Positive integer',\n      defaultValue: 1,\n      min: 1,\n      max: 30,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      dimensions,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const [offsetX, offsetY, groupCount, colors] = parameters;\n\n      const ribbonCount = colors.length * groupCount;\n      const ribbonArcDegrees = Math.round(360 / ribbonCount);\n      // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n      //  won't get a smooth transition.\n      // We'll cut off colors from the end of the list until we get an even multiple.\n      let colorsLength = colors.length;\n      while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n        colorsLength -= 1;\n      }\n\n      // Make the transparent parts colorful\n      if (isTransparent(srcPixel)) {\n        const center: Coord = [\n          dimensions[0] / 2 + offsetX,\n          dimensions[1] / 2 - offsetY,\n        ];\n        const pointAngle = calculateAngle(coord, center);\n\n        const colorIdx =\n          Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n        // Increment colorIdx based on current frame progress\n        const frameProgress = frameIndex / frameCount;\n        const idx =\n          (Math.floor(frameProgress * colorsLength) + colorIdx) % colorsLength;\n        return colors[idx];\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport {\n  mapImage,\n  isTransparent,\n  shiftHue,\n  calculateAngle,\n  colorFromeHue,\n} from '../domain/utils';\nimport { dropdownParam } from '../params/dropdownParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelParty = buildTransform({\n  name: 'Pinwheel Party',\n  description: 'Create a pinwheel of party colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 10,\n    }),\n    dropdownParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      dimensions,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const isBackground = isTransparent(srcPixel);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return srcPixel;\n      }\n\n      const center: Coord = [\n        dimensions[0] / 2 + offsetX,\n        dimensions[1] / 2 - offsetY,\n      ];\n      const pointAngle = calculateAngle(coord, center);\n      const frameProgress = frameIndex / frameCount;\n      const newH = (pointAngle * groupCount + frameProgress * 360) % 360;\n\n      return isBackground\n        ? colorFromeHue(newH)\n        : shiftHue(srcPixel, newH, amount);\n    }\n  ),\n});\n","import { range } from 'remeda';\n\nimport { buildTransform } from '../domain/types';\nimport {\n  isTransparent,\n  fromHexColor,\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radiance = buildTransform({\n  name: 'Radiance',\n  description: 'Radiate colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated. Positive integer',\n      defaultValue: 1,\n      min: 1,\n      max: 30,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const [groupCount, colors] = parameters;\n    const colorList = range(0, groupCount).flatMap(() => colors);\n    const [width, height] = image.dimensions;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    return mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) => {\n        const srcPixel = getPixelFromSource(image.dimensions, imageData, coord);\n\n        // Make the transparent parts colorful\n        if (isTransparent(srcPixel)) {\n          const [x, y] = coord;\n          const xRelCenter = x - centerX;\n          const yRelCenter = y - centerY;\n\n          const maxDist = Math.sqrt(\n            (width / 2) * (width / 2) + (height / 2) * (height / 2)\n          );\n          const distFromCenter = Math.sqrt(\n            yRelCenter * yRelCenter + xRelCenter * xRelCenter\n          );\n\n          const colorIdx =\n            Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n            colorList.length;\n\n          // Increment colorIdx based on current frame progress\n          const frameProgress = frameIndex / frameCount;\n          const idx =\n            (Math.floor(frameProgress * colorList.length) + colorIdx) %\n            colorList.length;\n          return colorList[idx];\n        }\n\n        return srcPixel;\n      })\n    );\n  },\n});\n","import { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { expand } from './expand';\nimport { fisheye } from './fisheye';\nimport { hueShift } from './hue-shift';\nimport { lightning } from './lightning';\nimport { nuke } from './nuke';\nimport { party } from './party';\nimport { partyBackground } from './party-background';\nimport { pinwheel } from './pinwheel';\nimport { pinwheelParty } from './pinwheel-party';\nimport { radiance } from './radiance';\nimport { radianceParty } from './radiance-party';\nimport { resizeImage } from './resize-image';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { staticc } from './static';\nimport { staticBackground } from './static-background';\nimport { transparentColor } from './transparent-color';\nimport { transpose } from './transpose';\n\nimport { assert } from '../domain/utils';\n\nexport const POSSIBLE_TRANSFORMS = [\n  adjustImage,\n  backgroundColor,\n  backgroundImage,\n  bounce,\n  circle,\n  colors,\n  colorsBackground,\n  doubleVision,\n  expand,\n  fisheye,\n  hueShift,\n  lightning,\n  nuke,\n  party,\n  partyBackground,\n  pinwheel,\n  pinwheelParty,\n  radiance,\n  radianceParty,\n  resizeImage,\n  ripple,\n  rotate,\n  roxbury,\n  shake,\n  staticc,\n  staticBackground,\n  transparentColor,\n  transpose,\n].sort((x, y) => (x.name > y.name ? 1 : -1));\n\nexport const transformByName = (name: string) => {\n  const t = POSSIBLE_TRANSFORMS.find((t) => t.name === name);\n  assert(t);\n  return t;\n};\n","import { buildTransform } from '../domain/types';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n  isTransparent,\n  shiftHue,\n  colorFromeHue,\n} from '../domain/utils';\nimport { dropdownParam } from '../params/dropdownParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceParty = buildTransform({\n  name: 'Radiance Party',\n  description: 'Radiate party colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 10,\n    }),\n    dropdownParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [groupCount, type, amount, offsetX, offsetY] }) => {\n    const [width, height] = image.dimensions;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    const maxDist = Math.sqrt(\n      (width / 2) * (width / 2) + (height / 2) * (height / 2)\n    );\n\n    return mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) => {\n        const [x, y] = coord;\n        const src = getPixelFromSource(image.dimensions, imageData, coord);\n\n        const isBackground = isTransparent(src);\n\n        if (type === 'foreground' ? isBackground : !isBackground) {\n          return src;\n        }\n\n        const xRelCenter = x - centerX - offsetX;\n        const yRelCenter = y - centerY + offsetY;\n\n        const distFromCenter = Math.sqrt(\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\n        );\n\n        const frameProgress = frameIndex / frameCount;\n        const newH =\n          ((1 - distFromCenter / maxDist) * 360 * groupCount +\n            360 * frameProgress) %\n          360;\n\n        return isBackground ? colorFromeHue(newH) : shiftHue(src, newH, amount);\n      })\n    );\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildTransform({\n  name: 'Resize Image',\n  description:\n    'Change the dimensions of the image. ' +\n    'If bigger than original, the extra space will be transparent. ' +\n    'If smaller, the image will be cropped. ',\n  params: [\n    intParam({ name: 'Width', defaultValue: 128, min: 0 }),\n    intParam({ name: 'Height', defaultValue: 128, min: 0 }),\n  ],\n  fn: ({ image, parameters }) =>\n    resizeImageUtil({\n      image,\n      newWidth: parameters[0],\n      newHeight: parameters[1],\n    }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapFrames, mapCoords, getPixelFromSource } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\nimport { intParam } from '../params/intParam';\n\nexport const ripple = buildTransform({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: 10,\n      description: 'How strong the ripple effect should be',\n    }),\n    intParam({\n      name: 'Period',\n      defaultValue: 2,\n      min: 0,\n      description: 'How many ripples you want. Positive number.',\n    }),\n  ],\n  fn: ({ image, parameters }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const [amplitude, period] = parameters;\n\n      const height = image.dimensions[1];\n      const shift = (frameIndex / frameCount) * 2 * Math.PI;\n      return mapCoords(image.dimensions, ([x, y]) => {\n        const offset = Math.round(\n          amplitude * Math.sin((y / height) * period * Math.PI + shift)\n        );\n\n        return getPixelFromSource(image.dimensions, data, [x + offset, y]);\n      });\n    }),\n});\n","import { mapImage } from '../domain/utils';\nimport { buildTransform, Coord } from '../domain/types';\nimport { dropdownParam } from '../params/dropdownParam';\n\nexport const rotate = buildTransform({\n  name: 'Rotate',\n  description: 'Make the image rotate about the center point',\n  params: [\n    dropdownParam({\n      name: 'Direction',\n      defaultValue: -1,\n      options: [\n        { name: 'Clockwise', value: -1 },\n        { name: 'Counter-Clockwise', value: 1 },\n      ],\n    }),\n  ],\n  fn: mapImage(\n    ({\n      dimensions,\n      coord,\n      frameCount,\n      frameIndex,\n      getSrcPixel,\n      parameters,\n    }) => {\n      const [sign] = parameters;\n      const centerX = dimensions[0] / 2;\n      const centerY = dimensions[1] / 2;\n      const [x, y] = coord;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const amount = (frameIndex / frameCount) * (sign || 1);\n      const cos = Math.cos(2 * Math.PI * amount);\n      const sin = Math.sin(2 * Math.PI * amount);\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { mapFrames, mapCoords, getPixelFromSource } from '../domain/utils';\nimport { buildTransform, Coord } from '../domain/types';\n\nexport const roxbury = buildTransform({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (data, frameIndex, frameCount) => {\n      const idx = frameIndex / frameCount;\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(idx * 4);\n      const phaseIdx = (idx - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      const cos = Math.cos(-angle * 1.35);\n      const sin = Math.sin(-angle * 1.35);\n\n      const rotatePointX = image.dimensions[0] * 0.25;\n      const rotatePointY = image.dimensions[1] * 0.7;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const [x, y] = coord;\n        const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n        const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n        const newCoord: Coord = [\n          Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n          Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n        ];\n\n        return getPixelFromSource(image.dimensions, data, newCoord);\n      });\n    }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildTransform({\n  name: 'Shake',\n  description: 'Make the image shake back and forth',\n  params: [floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 })],\n  fn: mapImage(({ coord, frameCount, frameIndex, getSrcPixel, parameters }) => {\n    const [amplitude] = parameters;\n    const [x, y] = coord;\n    const xOffset =\n      x +\n      Math.round(amplitude * Math.cos((frameIndex / frameCount) * 2 * Math.PI));\n\n    return getSrcPixel([xOffset, y]);\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildTransform({\n  name: 'Static',\n  description: 'Adds random static to the image',\n  params: [\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      return [0, 0, 0, 0];\n    }\n\n    const isStatic = Math.ceil(random() * 100) < strength;\n    const grey = Math.ceil(random() * 255);\n\n    return isStatic ? [grey, grey, grey, src[3]] : src;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, isTransparent } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticBackground = buildTransform({\n  name: 'Static Background',\n  description: 'Adds random static to the background',\n  params: [\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters, random }) => {\n    const [strength] = parameters;\n    const src = getSrcPixel(coord);\n\n    if (isTransparent(src)) {\n      const inverse = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return inverse ? [grey, grey, grey, 255] : src;\n    }\n\n    return src;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { fromHexColor, mapImage } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparentColor = buildTransform({\n  name: 'Transparent Color',\n  description:\n    'All pixels similar in color to the chosen one will be made transparent',\n  params: [\n    colorPickerParam({\n      name: 'Transparent Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [color, tolerance] = parameters;\n    const p = getSrcPixel(coord);\n    const diff0 = p[0] - color[0];\n    const diff1 = p[1] - color[1];\n    const diff2 = p[2] - color[2];\n    const diff = Math.sqrt(diff0 * diff0 + diff1 * diff1 + diff2 * diff2);\n    if ((diff / 255) * 100 <= tolerance) {\n      return [p[0], p[1], p[2], 0];\n    }\n    return p;\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildTransform({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ],\n  fn: mapImage(({ coord, getSrcPixel, parameters }) => {\n    const [transX, transY] = parameters;\n    const [x, y] = coord;\n\n    return getSrcPixel([x + transX, y + transY]);\n  }),\n});\n","import React from 'react';\nimport {\n  Button,\n  CircularProgress,\n  Divider,\n  Grid,\n  Icon,\n  LinearProgress,\n  Stack,\n  Typography,\n} from '@material-ui/core';\n\nimport { assert } from '../domain/utils';\nimport { runTransforms } from '../domain/run';\nimport { AppState, TransformInput } from '../domain/types';\nimport { transformByName } from '../transforms';\nimport { sliderParam } from '../params/sliderParam';\n\ninterface ComputeBoxProps {\n  computeDisabled: boolean;\n  appState: AppState;\n  onFpsChange: (fps: number) => void;\n  onComputed: () => void;\n}\n\ntype ComputeState =\n  | {\n      loading: false;\n      results: { transformName: string; gif: string }[];\n      computeTime: number | undefined;\n    }\n  | { loading: true };\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nexport const ComputeBox: React.FC<ComputeBoxProps> = ({\n  computeDisabled,\n  appState,\n  onFpsChange,\n  onComputed,\n}) => {\n  const [computeState, setComputeState] = React.useState<ComputeState>({\n    loading: false,\n    results: [],\n    computeTime: undefined,\n  });\n  const [progress, setProgress] = React.useState<number | undefined>();\n\n  return (\n    <Stack spacing={1}>\n      <Typography variant=\"h5\">Create Gif</Typography>\n\n      <div style={{ maxWidth: '300px' }}>\n        {fpsParam.fn({\n          value: { valid: true, value: appState.fps },\n          onChange: (x) => {\n            if (x.valid) {\n              onFpsChange(x.value);\n            }\n          },\n        })}\n      </div>\n      <Button\n        variant=\"contained\"\n        sx={{ maxWidth: '300px' }}\n        endIcon={\n          !computeState.loading && appState.dirty ? (\n            <Icon>priority_high</Icon>\n          ) : undefined\n        }\n        disabled={computeDisabled}\n        onClick={async () => {\n          const transformInputs = appState.transforms.map(\n            (t): TransformInput<any> => ({\n              transform: transformByName(t.transformName),\n              params: t.paramsValues.map((p) => {\n                assert(p.valid);\n                return p.value;\n              }),\n            })\n          );\n          setComputeState({ loading: true });\n          setTimeout(async () => {\n            try {\n              assert(\n                appState.baseImage,\n                'No source image, this button should be disabled!'\n              );\n              const start = Date.now();\n              let currIdx = 0;\n              setProgress(0);\n              const results = await runTransforms({\n                inputDataUrl: appState.baseImage,\n                transformList: transformInputs,\n                fps: appState.fps,\n                onImageFinished: () => {\n                  currIdx += 1;\n                  setProgress((currIdx / transformInputs.length) * 100);\n                },\n              });\n              const computeTime = Math.ceil((Date.now() - start) / 1000);\n              setComputeState({\n                loading: false,\n                computeTime,\n                results: results.map((result, idx) => ({\n                  transformName: appState.transforms[idx].transformName,\n                  gif: result.gif,\n                })),\n              });\n              setProgress(undefined);\n              onComputed();\n            } catch (err) {\n              console.error(err);\n              console.error((err as any).stack);\n            }\n          });\n        }}\n      >\n        {computeState.loading ? (\n          <CircularProgress color=\"inherit\" />\n        ) : (\n          'Compute'\n        )}\n      </Button>\n      {progress !== undefined && (\n        <LinearProgress variant=\"determinate\" value={progress} />\n      )}\n      {!computeState.loading && computeState.computeTime !== undefined && (\n        <>\n          <Divider />\n          <Typography variant=\"caption\">\n            Compute Time: {computeState.computeTime} second(s)\n          </Typography>\n        </>\n      )}\n\n      {!computeState.loading && computeState.results.length > 0 && (\n        <>\n          <Divider />\n          <Grid\n            container\n            spacing={2}\n            padding={1}\n            columns={{ xs: 4, sm: 8, md: 12 }}\n          >\n            {computeState.results.map(({ gif, transformName }, idx) => (\n              <Grid item xs={4} sm={4} md={4} key={`${transformName}-${idx}`}>\n                <Typography variant=\"subtitle2\">{transformName}</Typography>\n                <img\n                  src={gif}\n                  alt={`gif-${transformName}-${idx}`}\n                  style={{ maxWidth: '300px', maxHeight: 'auto' }}\n                ></img>\n              </Grid>\n            ))}\n          </Grid>\n        </>\n      )}\n    </Stack>\n  );\n};\n","import {\n  FormControl,\n  IconButton,\n  Icon,\n  Tooltip,\n  Stack,\n  Typography,\n  Paper,\n  Autocomplete,\n  TextField,\n  Divider,\n} from '@material-ui/core';\nimport React from 'react';\n\nimport { ParamFunction, ParamValue, Transform } from '../domain/types';\n\ninterface SelectedTransform {\n  transform: Transform<any>;\n  paramValues: ParamValue<any>[];\n}\n\ninterface ImageTransformProps {\n  selectedTransform: SelectedTransform;\n  possibleTransforms: Transform<any>[];\n  index: number;\n  onSelect: (selected: SelectedTransform) => void;\n  onRemove: () => void;\n  onMoveLeft?: () => void;\n  onMoveRight?: () => void;\n}\n\nexport const ImageTransform: React.FC<ImageTransformProps> = ({\n  selectedTransform,\n  possibleTransforms,\n  index,\n  onSelect,\n  onRemove,\n  onMoveLeft,\n  onMoveRight,\n}) => {\n  return (\n    <Paper style={{ padding: 8 }} elevation={3}>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={2}>\n          <Typography variant=\"subtitle1\">{index + 1}</Typography>\n          <Tooltip title=\"Delete transform\">\n            <IconButton aria-label=\"delete\" onClick={onRemove}>\n              <Icon>delete</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform left\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveLeft}\n              disabled={!onMoveLeft}\n            >\n              <Icon>chevron_left</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform right\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveRight}\n              disabled={!onMoveRight}\n            >\n              <Icon>chevron_right</Icon>\n            </IconButton>\n          </Tooltip>\n        </Stack>\n        <Stack direction=\"row\" spacing={4}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={selectedTransform.transform.name}\n              options={possibleTransforms.map((t) => t.name)}\n              onChange={(event, newTransformName) => {\n                const t = possibleTransforms.find(\n                  (t) => t.name === newTransformName\n                )!;\n                // Reset all the params when you select a new transform\n                onSelect({\n                  transform: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n              renderInput={(params) => (\n                <TextField {...params} label=\"Transform\" />\n              )}\n            />\n          </FormControl>\n        </Stack>\n        {selectedTransform.transform.description && (\n          <Typography variant=\"caption\">\n            {selectedTransform.transform.description}\n          </Typography>\n        )}\n        {selectedTransform.transform.params.length > 0 && (\n          <Typography variant=\"subtitle1\">Parameters</Typography>\n        )}\n        <Stack divider={<Divider />} spacing={2}>\n          {selectedTransform.transform.params.map(\n            // Create elements for each of the parameters for the selectect transform.\n            // Each of these would get an onChange event so we know when the user has\n            //  selected a value.\n            (param: ParamFunction<any>, idx: number) => {\n              const ele = param.fn({\n                value: selectedTransform.paramValues[idx],\n                onChange: (v) => {\n                  onSelect({\n                    ...selectedTransform,\n                    paramValues: selectedTransform.paramValues.map((x, i) => {\n                      if (i === idx) {\n                        return v;\n                      }\n                      return x;\n                    }),\n                  });\n                },\n              });\n              return (\n                <React.Fragment\n                  key={`${selectedTransform.transform.name}-${param.name}`}\n                >\n                  {ele}\n                </React.Fragment>\n              );\n            }\n          )}\n        </Stack>\n      </Stack>\n    </Paper>\n  );\n};\n","import { Button, Grid, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Transform, TransformWithParams } from '../domain/types';\nimport { transformByName } from '../transforms';\nimport { ImageTransform } from './ImageTransform';\n\ninterface TransformListProps {\n  currentTransforms: TransformWithParams<any>[];\n  possibleTransforms: Transform<any>[];\n  onTransformsChange: (t: TransformWithParams<any>[]) => void;\n}\n\nexport const ImageTransformList: React.FC<TransformListProps> = ({\n  currentTransforms,\n  possibleTransforms,\n  onTransformsChange,\n}) => (\n  <Stack spacing={1}>\n    <Typography variant=\"h5\">Image Transforms</Typography>\n    <Grid\n      container\n      spacing={2}\n      padding={1}\n      columns={{ xs: 4, sm: 8, md: 12 }}\n      rowSpacing={4}\n    >\n      {currentTransforms.map((t, tIdx) => (\n        <Grid item xs={4} sm={4} md={4} key={`${t.transformName}-${tIdx}`}>\n          <ImageTransform\n            index={tIdx}\n            possibleTransforms={possibleTransforms}\n            selectedTransform={{\n              transform: transformByName(t.transformName),\n              paramValues: t.paramsValues,\n            }}\n            onRemove={() =>\n              onTransformsChange(\n                currentTransforms.filter((nextT, newIdx) => newIdx !== tIdx)\n              )\n            }\n            onMoveLeft={\n              tIdx > 0\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx - 1) {\n                          // This is the next item in the list\n                          return currentTransforms[newIdx + 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the previous item\n                          return currentTransforms[tIdx - 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onMoveRight={\n              tIdx < currentTransforms.length - 1\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx + 1) {\n                          // This is the previous item in the list\n                          return currentTransforms[newIdx - 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the next item\n                          return currentTransforms[tIdx + 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onSelect={(selected) =>\n              onTransformsChange(\n                currentTransforms.map((nextT, nextTIdx) => {\n                  if (tIdx === nextTIdx) {\n                    // This is the one we just changed\n                    return {\n                      transformName: selected.transform.name,\n                      paramsValues: selected.paramValues,\n                      computedImage: undefined,\n                    };\n                  }\n                  // Reset all the images if we changed anything\n                  return {\n                    transformName: nextT.transformName,\n                    paramsValues: nextT.paramsValues,\n                    computedImage: undefined,\n                  };\n                })\n              )\n            }\n          />\n        </Grid>\n      ))}\n      <Grid item xs={4} sm={4} md={4}>\n        <Stack spacing={4}>\n          <Button\n            fullWidth={false}\n            variant=\"contained\"\n            startIcon={<Icon>add</Icon>}\n            onClick={() =>\n              onTransformsChange([\n                ...currentTransforms,\n                {\n                  transformName: possibleTransforms[0].name,\n                  paramsValues: possibleTransforms[0].params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                },\n              ])\n            }\n          >\n            New Transform\n          </Button>\n        </Stack>\n      </Grid>\n    </Grid>\n  </Stack>\n);\n","import { Stack, Button, Icon, Typography, Alert } from '@material-ui/core';\nimport React from 'react';\nimport * as lz from 'lz-string';\nimport { AppState } from '../domain/types';\n\ninterface ImportExportProps {\n  state: AppState;\n  onImport: (o: AppState) => void;\n}\n\nexport const ImportExport: React.FC<ImportExportProps> = ({\n  state,\n  onImport,\n}) => {\n  const [info, setInfo] = React.useState<string | undefined>();\n  const [isInvalid, setInvalid] = React.useState(false);\n\n  const showInfo = (text: string) => {\n    setInfo(text);\n    setTimeout(() => setInfo(undefined), 2000);\n  };\n\n  const showError = () => {\n    setInvalid(true);\n    setTimeout(() => setInvalid(false), 2000);\n  };\n\n  return (\n    <Stack spacing={3}>\n      <Typography variant=\"h5\">Import/Export</Typography>\n      <Button\n        startIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(\n            JSON.stringify({ ...state, baseImage: undefined })\n          );\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard <br /> (NO Source Image)\n      </Button>\n      <Button\n        startIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(JSON.stringify(state));\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard <br />\n        (With Source Image)\n      </Button>\n      <Button\n        startIcon={<Icon>file_download</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={async () => {\n          try {\n            const clipboardContents = await navigator.clipboard.readText();\n            if (!clipboardContents) {\n              showError();\n              return;\n            }\n            const data = JSON.parse(\n              lz.decompressFromBase64(clipboardContents)!\n            );\n            if (!Array.isArray(data.transforms)) {\n              showError();\n              return;\n            }\n            onImport(data);\n            setInvalid(false);\n          } catch (e) {\n            console.error(e);\n            showError();\n          }\n        }}\n      >\n        Import from clipboard\n      </Button>\n      {info && (\n        <Alert severity=\"info\" sx={{ maxWidth: '300px' }}>\n          {info}\n        </Alert>\n      )}\n      {isInvalid && (\n        <Alert severity=\"error\" sx={{ maxWidth: '300px' }}>\n          Error importing from clipboard\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import React from 'react';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\nimport {\n  Container,\n  Stack,\n  Divider,\n  Paper,\n  Typography,\n  Button,\n  Icon,\n} from '@material-ui/core';\n\nimport { POSSIBLE_TRANSFORMS, transformByName } from './transforms';\nimport { ParamFunction, AppState } from './domain/types';\nimport { ComputeBox } from './components/ComputeBox';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageTransformList } from './components/ImageTransformList';\nimport { ImportExport } from './components/ImportExport';\nimport { Help } from './components/Help';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\n\n// Set to true to print out the current state at the bottom of the page\nconst DEBUG = false;\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nconst DEFAULT_STATE: AppState = {\n  dirty: false,\n  transforms: [],\n  baseImage: undefined,\n  fps: 20,\n};\n\nexport const App: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n\n  React.useEffect(() => {\n    // If we have local storage state on startup, then reload that\n    try {\n      const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n      if (stored) {\n        const savedState = JSON.parse(stored);\n        if (!Array.isArray(savedState.transforms)) {\n          // Dunno what we just loaded, not the right thing\n          return;\n        }\n\n        setStateRaw(savedState);\n      }\n    } catch (err) {\n      // @ts-ignore\n      console.error('Error loading state from local storage', err.stack || err);\n    }\n  }, []);\n\n  const setState = (newState: AppState) => {\n    try {\n      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(newState));\n    } catch (err) {\n      // @ts-ignore\n      console.error('Error saving state to local storage', err.stack || err);\n    }\n    setStateRaw(newState);\n  };\n\n  if (DEBUG) {\n    (window as any).STATE = state;\n  }\n\n  const computeBtnDisbled =\n    !state.baseImage ||\n    state.transforms.length === 0 ||\n    !state.dirty ||\n    state.transforms.some((t) => {\n      const params = transformByName(t.transformName)\n        .params as ParamFunction<any>[];\n      return (\n        params.length > 0 && t.paramsValues.every((p, i) => p.valid === false)\n      );\n    });\n\n  return (\n    <TopLevelErrorBoundary\n      onClearLocalStorage={() => {\n        window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n        window.location.reload();\n      }}\n    >\n      <ScopedCssBaseline />\n      <Container>\n        <Stack spacing={4} justifyContent=\"space-evenly\" divider={<Divider />}>\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />}>\n            {DEBUG && (\n              <Paper style={{ padding: 16 }}>\n                <Help />\n              </Paper>\n            )}\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={1}>\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Choose a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState({\n                      ...state,\n                      baseImage,\n                      dirty: true,\n                    });\n                  }}\n                />\n              </Stack>\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImageTransformList\n                currentTransforms={state.transforms}\n                possibleTransforms={POSSIBLE_TRANSFORMS}\n                onTransformsChange={(transforms) =>\n                  setState({\n                    ...state,\n                    dirty: true,\n                    transforms,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ComputeBox\n                computeDisabled={computeBtnDisbled}\n                appState={state}\n                onFpsChange={(fps) =>\n                  setState({\n                    ...state,\n                    fps,\n                    dirty: true,\n                  })\n                }\n                onComputed={() =>\n                  setState({\n                    ...state,\n                    dirty: false,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImportExport\n                state={state}\n                onImport={(newState) => setState({ ...newState, dirty: true })}\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear State</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear the source image and all\n                  transforms\n                </Typography>\n                <Button\n                  startIcon={<Icon>clear</Icon>}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  onClick={() => {\n                    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n                    setStateRaw(DEFAULT_STATE);\n                  }}\n                >\n                  Clear State\n                </Button>\n              </Stack>\n            </Paper>\n            {DEBUG && (\n              <div>\n                <code>{JSON.stringify(state, null, 2)}</code>\n              </div>\n            )}\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n    </TopLevelErrorBoundary>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}