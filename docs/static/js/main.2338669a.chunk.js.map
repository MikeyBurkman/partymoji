{"version":3,"sources":["components/Icon.tsx","components/Expandable.tsx","components/Help.tsx","domain/importImageFromUrl.ts","domain/utils/misc.ts","domain/types.ts","domain/utils/color.ts","domain/utils/isWorker.ts","domain/utils/canvas.ts","domain/utils/image.ts","components/HelpTooltip.tsx","params/intParam.tsx","domain/utils/useDebounce.tsx","params/sliderParam.tsx","effects/adjust-image.ts","params/colorPickerParam.tsx","effects/background-color.ts","params/checkboxParam.tsx","params/imagePickerParam.tsx","params/radioParam.tsx","effects/background-image.ts","effects/blur.ts","domain/utils/CanvasElement.tsx","params/bezierParam.tsx","params/dropdownParam.tsx","params/floatParam.tsx","params/huePickerParam.tsx","params/textParam.tsx","params/variableLengthParam.tsx","effects/bounce.ts","effects/bounce-animation.ts","effects/circle.ts","effects/colors.ts","effects/colors-background.ts","effects/double-vision.ts","effects/drop-shadow.ts","effects/expand.ts","effects/fade.ts","effects/fill.ts","effects/fisheye.ts","effects/grid.ts","effects/hue-change.ts","effects/hue-shift.ts","effects/hue-shift-pulse.ts","effects/hue-wave.ts","effects/lightning.ts","effects/mirror.ts","effects/nuke.ts","effects/opacity.ts","effects/party.ts","effects/party-background.ts","effects/party-harder.ts","effects/party-shadow.ts","effects/pinwheel-colors.ts","effects/pinwheel-rainbow.ts","effects/pinwheel-rainbow-background.ts","effects/radiance-colors.ts","effects/radiance-rainbow.ts","effects/radiance-rainbow-background.ts","effects/reduce-color-palette.ts","effects/repeat-animation.ts","effects/resize-image.ts","effects/reverse-animation.ts","effects/ripple.ts","effects/rotate.ts","effects/roxbury.ts","effects/scale-image.ts","effects/set-animation-length.ts","effects/shake.ts","effects/slow-animation.ts","effects/spin.ts","effects/static.ts","effects/text.ts","effects/transparency.ts","effects/transpose.ts","effects/index.ts","effects/fake-transparency.ts","domain/run.ts","components/Gif.tsx","components/ImagePicker.tsx","domain/env.ts","domain/effect.worker.ts","domain/runAsync.ts","domain/computeGifs.ts","components/useProcessingQueue.tsx","components/BackgroundPreviewTooltip.tsx","components/ImageEffectDialog.tsx","components/ImageEffectList.tsx","localStorage.ts","AlertContext.tsx","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["ClickableIcon","name","onClick","isDisabled","tooltip","React","useState","hover","setHover","onMouseEnter","useCallback","onMouseLeave","onClickAction","color","useMemo","icon","style","cursor","undefined","Tooltip","title","Icon","Expandable","mainEle","children","collapsed","setCollapsed","ClickAwayListener","onClickAway","Stack","Button","variant","size","direction","alignItems","spacing","Collapse","in","Help","Typography","Divider","Group","Section","width","SectionHeader","paddingLeft","SectionText","sx","fontSize","marginRight","getImageFromUrl","url","a","Promise","resolve","reject","img","Image","setAttribute","onload","canvas","document","createElement","height","ctx","getContext","Error","drawImage","toDataURL","onerror","src","assert","condition","message","replaceIndex","arr","index","newValueFn","map","x","i","insertInto","newValue","slice","clamp","n","min","max","Math","weightedValue","percent","v1","v2","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","pointDistance","x1","y1","x2","y2","xDiff","pow","yDiff","sqrt","bezierCurve","easing","mirror","fn","bezier","amount","LINEAR_BEZIER","toParamFunction","buildEffect","args","params","description","secondaryDescription","disabled","toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","isPartiallyTransparent","randomColor","random","floor","int32","clampColor","TRANSPARENT_COLOR","shiftTowardsHue","hue","convert","hsl","l","rgb","newR","newG","newB","shiftHue","h","colorFromHue","colorDiff","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","IS_WORKER","window","createCanvas","OffscreenCanvas","frameToCanvas","dimensions","frame","imageData","ImageData","putImageData","canvasToFrame","canvasData","getImageData","data","applyCanvasFromFrame","preEffect","postEffect","save","restore","combineImages","background","foreground","backgroundCanvas","foregroundCanvas","applyFilter","blur","brightness","contrast","opacity","saturation","hueRotate","sepia","dropShadow","shadow","offsetX","offsetY","blurRadius","join","filters","filter","applyTransform","horizontalScale","verticalScale","horizontalSkew","verticalSkew","horizontalTranslation","verticalTranslation","transform","applyRotation","degrees","radians","rotate","getPixelFromSource","image","coord","y","idx","getImageIndex","mapFrames","cb","frames","mapCoords","transformedImageData","Uint8ClampedArray","mapImage","parameters","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","resizeImage","newWidth","newHeight","keepScale","newFrames","rootCanvas","imgCanvas","setPixel","px","isColorPartiallyTransparent","HelpTooltip","IntParam","value","parse","onChange","val","setVal","invalidText","setInvalidText","FormControl","TextField","error","onBlur","valid","reason","e","target","FormHelperText","intParam","defaultValue","isNaN","useDebounce","debounceMillis","v","setV","debounceRef","useRef","newV","current","clearTimeout","setTimeout","SliderParam","step","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","sliderParam","adjustImage","resizeToWidth","resizeToHeight","oldWidth","oldHeight","hasScaleChange","ceil","isBiggerImage","currImage","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","CheckboxParam","paddingTop","Checkbox","checked","checkboxParam","DEFAULT_IMAGE","gif","gifWithBackgroundColor","partiallyTransparent","RadioParam","options","component","RadioGroup","event","t","FormControlLabel","control","Radio","label","radioParam","backgroundImage","currentImage","otherImagePreResize","type","otherImage","thisFrameCanvas","otherImageFrameIndex","otherFrameCanvas","CanvasElement","cursorIsPointer","onCanvasMount","onMouseDown","onMouseUp","onMouseMove","ref","isMounted","useEffect","onEvent","callback","evt","rect","getBoundingClientRect","clientX","left","clientY","top","BezierParam","WIDTH","HEIGHT","curValue","setCurValue","latestMouseLocation","setLatestMouseLocation","canvasCtx","setCanvasCtx","isDragging","setIsDragging","closestPointIdx","distances","distance","closest","R","d","clearRect","fillStyle","beginPath","ellipse","fill","moveTo","strokeStyle","bezierCurveTo","stroke","newCoord","Box","border","bezierParam","DropdownParam","Select","autoWidth","MenuItem","FloatParam","floatParam","parseFloat","HuePickerParam","hexColor","huePickerParam","TextParam","textParam","VariableLengthParam","newParamText","createNewParam","param","pValue","setParams","Paper","ele","p","oldP","IconButton","newParams","visibility","vals","variableLengthParam","bounce","yOffset","round","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","sin","cos","DEFAULT_COLORS","colors","brightnessIncrease","chosenColor","srcPixel","gray","getAveragePixelValue","adjustBrightness","colorsBackground","bgColor","doubleVision","dir","expand","dist","centerX","centerY","xRatio","yRatio","fade","curve","getOpacityAmount","progress","oldImage","colorToReplace","tolerance","f","duplicateImage","floodFill","newColor","visited","set","Set","add","has","stack","push","pop","currColor","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","abs","newSat","adjustSaturation","hueChange","newHue","hueShift","hueShiftPulse","hueWave","shift","amplitude","period","lightningIntensities","lightning","seed","seedrandom","flashIntensity","icf","nuke","party","speed","partyBackground","shiftSpeed","partyHarder","partyShadow","layers","startHue","hueSize","applyShadows","rest","newFrame","pinwheelColors","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","center","pointAngle","colorIdx","pinwheelRainbow","strength","pinwheelRainbowBackground","radianceColors","colorList","range","flatMap","maxDist","distFromCenter","radianceRainbow","radianceRainbowBackground","reduceColorPalette","percentReduction","allColorsSet","allColors","Array","from","numColors","colorMap","numClosestColors","closestColorIdx","closetsColorDist","k","colorPalette","sortBy","minBy","repeatAnimation","numRepeats","resizeImageUtil","reverseAnimation","ripple","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","scaleImage","scale","scaleImageUtil","setAnimationLength","currentFrames","frameToCopy","changeFrameCount","shake","slowAnimation","ogFrameIdx","r1","g1","b1","a1","spin","staticc","isBackground","inverse","grey","isStatic","FONTS","text","font","fillText","transparency","matchesTransparent","selectedColor","withinTolerance","transpose","otherEffects","POSSIBLE_EFFECTS","effectByName","find","COLORS","fakeTransparency","createBackground","blockWidth","blockHeight","j","fillRect","runEffects","effectInput","randomSeed","fps","effect","effectName","result","getTransparentColor","transparentColor","hasPartialTransparency","createGif","encodeTransparency","resultWithBG","gifEncoder","setFrameRate","setRepeat","writeHeader","setTransparent","on","chunk","blob","Blob","blobOrFileToDataUrl","dataUrl","forEach","addFrame","finish","readImage","res","rej","getPixels","err","results","shape","numFrames","sliceSize","subarray","hasTransparent","seenPixels","attempt","findRandomColorNotInSet","attempts","col","file","reader","FileReader","readAsDataURL","MAX_SIZE","calculateDimensions","maxWidth","maxHeight","aspectRatio","Gif","alt","parseFileName","parts","split","nameParts","ImagePicker","setError","fullWidth","helperText","startsWith","test","startIcon","hidden","accept","files","IS_MOBILE","MobileDetect","navigator","userAgent","mobile","ENV","debugLog","console","log","Worker_fn","Worker","computationMap","Map","handleError","computationId","computation","get","delete","computeGif","worker","RunEffectWorker","Date","now","addEventListener","onmessage","status","handleSuccess","postMessage","computeGifsForState","state","startEffectIndex","onCompute","baseImage","prevEffectState","effects","start","paramsValues","ga","hitType","timingCategory","timingVar","timingValue","ProcessorQueueContext","createContext","latestRunIdRef","ProcessorQueueProvider","Provider","useProcessingQueue","onComplete","onError","useContext","onFinish","runId","then","catch","TOOLTIP","BackgroundPreviewTooltip","ImageEffectDialog","open","initialImage","currentEffect","possibleEffects","currFps","currRandomSeed","onChangeEffect","onCancel","computing","setImage","onImageChange","initialLoaded","setInitialLoaded","editingEffect","setEditingEffect","dirty","setDirty","closeDialog","Dialog","DialogTitle","marginTop","Autocomplete","disableClearable","newEffectName","renderOption","props","option","marginLeft","renderInput","DialogContent","divider","Fragment","CircularProgress","DialogActions","autoFocus","ImageEffect","totalEffects","onEdit","onDelete","onMoveBefore","onMoveAfter","onAddBefore","onAddAfter","margin","justifyContent","minHeight","fontWeight","marginBottom","alignSelf","mt","ImageEffectList","appState","onEffectsChange","currentEffects","effectDialogOpen","setEffectDialogOpen","swiper","setSwiper","setBaseImage","dialogInitialImage","prevEffect","newDefaultEffect","tIdx","previousEffect","finalGif","lastEffect","newEffect","computedImage","isNew","navigation","modules","Navigation","Controller","controller","onSwiper","fname","nextT","newIdx","slideTo","substring","effectKey","saveAs","LOCAL_STORAGE_KEY","getStoredAppState","stored","localStorage","getItem","savedState","JSON","isArray","saveAppState","setItem","serializeAppState","clearAppState","removeItem","toStore","stringify","alertContext","alert","setAlert","AlertProvider","alertValue","setAlertValue","AlertSnackbar","Snackbar","Alert","severity","onClose","fpsParam","DEFAULT_STATE","version","Inner","setStateRaw","doCompute","setDoCompute","computeTimer","setComputeTimer","startIndex","setState","oldState","newState","STATE","effectsDiff","currState","prevState","diff","currEffects","prevEffects","currE","prevE","ei","currEParam","prevEP","getEffectsDiff","computeIdx","ScopedCssBaseline","Container","pt","href","rel","padding","App","TopLevelErrorBoundary","hasError","errorInfo","this","endIcon","onClearLocalStorage","Component","theme","createTheme","typography","fontFamily","ReactDOM","render","StrictMode","ThemeProvider","location","reload","getElementById"],"mappings":"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","file":"static/js/main.2338669a.chunk.js","sourcesContent":["import React from 'react';\nimport { Icon as MuiIcon, Tooltip } from '@material-ui/core';\n\nexport type Icons =\n  | 'add'\n  | 'remove'\n  | 'clear'\n  | 'circle'\n  | 'delete'\n  | 'arrow_upward'\n  | 'arrow_downward'\n  | 'arrow_right'\n  | 'arrow_left'\n  | 'arrow_circle_right'\n  | 'arrow_circle_left'\n  | 'keyboard_double_arrow_right'\n  | 'keyboard_double_arrow_left'\n  | 'edit'\n  | 'image'\n  | 'priority_high'\n  | 'list'\n  | 'settings'\n  | 'save_alt';\n\nexport interface ClickableIconProps {\n  name: Icons;\n  onClick?: () => void;\n  isDisabled?: boolean;\n  tooltip?: string;\n}\n\nexport const ClickableIcon: React.FC<ClickableIconProps> = ({\n  name,\n  onClick,\n  isDisabled,\n  tooltip,\n}) => {\n  const [hover, setHover] = React.useState(false);\n  const onMouseEnter = React.useCallback(() => {\n    if (onClick) {\n      setHover(true);\n    }\n  }, [onClick]);\n  const onMouseLeave = React.useCallback(() => {\n    if (onClick) {\n      setHover(false);\n    }\n  }, [onClick]);\n  const onClickAction = React.useCallback(() => {\n    if (isDisabled === true) {\n      return;\n    }\n    onClick?.();\n  }, [onClick, isDisabled]);\n\n  const color = React.useMemo(() => {\n    if (isDisabled) {\n      return 'disabled';\n    }\n    return hover ? 'secondary' : 'primary';\n  }, [isDisabled, hover]);\n\n  const icon = (\n    <MuiIcon\n      onClick={onClickAction}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      color={color}\n      style={{ cursor: isDisabled ? undefined : 'pointer' }}\n    >\n      {name}\n    </MuiIcon>\n  );\n\n  if (tooltip) {\n    return <Tooltip title={tooltip}>{icon}</Tooltip>;\n  }\n\n  return icon;\n};\n\nexport interface IconProps {\n  name: Icons;\n}\n\nexport const Icon: React.FC<IconProps> = ({ name }) => (\n  <MuiIcon>{name}</MuiIcon>\n);\n","import { Button, ClickAwayListener, Collapse, Stack } from '@material-ui/core';\nimport React from 'react';\nimport { Icon } from './Icon';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Stack>\n        <Button\n          variant=\"text\"\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ color: 'black' }}\n          size=\"small\"\n        >\n          <Stack direction=\"row\" alignItems=\"center\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon name={collapsed ? 'add' : 'remove'} />\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Stack>\n    </ClickAwayListener>\n  );\n};\n","import { Divider, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { Expandable } from './Expandable';\n\nexport const Help: React.FC = () => (\n  <Expandable\n    mainEle={<Typography variant=\"h5\">Click here for Help</Typography>}\n  >\n    <Group>\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Getting Started</Typography>}\n      >\n        <Section>\n          <SectionHeader>Start by importing an image.</SectionHeader>\n          <SectionText>\n            You may upload a png, jpg, or gif from your device.\n          </SectionText>\n          <SectionText>\n            Alternatively, you can post a URL to a png, jpg, or gif, though this\n            can be a little flaky, and does not support animated images.\n          </SectionText>\n          <SectionText>\n            The frames per second controls how fast the final gif will animate.\n          </SectionText>\n        </Section>\n      </Expandable>\n\n      <Expandable\n        mainEle={<Typography variant=\"h6\">Adding Effects</Typography>}\n      >\n        <Group>\n          <Section>\n            <Section>\n              <SectionHeader>\n                Effects are applied to an image to manipulate it\n              </SectionHeader>\n              <SectionText>\n                Some may adjust the basic attributes of an image, such as size,\n                or number of animation frames.\n              </SectionText>\n              <SectionText>\n                Others may apply animated effects, such as making the image\n                spin, or cycle through colors.\n              </SectionText>\n            </Section>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>\n              For static images, you'll likely want to first \"Set Animation\n              Length\".\n            </SectionHeader>\n            <SectionText>\n              This controls how many frames are in the animation. Typically this\n              is between 10 and 20.\n            </SectionText>\n            <SectionText>\n              More frames will increase both the time to compute the image, and\n              the final file size.\n            </SectionText>\n            <SectionText>\n              Remember that some places (like Slack and Discord) have strict\n              limits on the file size of emojis, so you may need to reduce the\n              number of frames in order to meet those requirements. Slack has a\n              limit of 128kb, and Discord has a limit of 256kb.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>\n              If uploading to Slack or Discord, you will probably want to use\n              \"Adjust Image\" to set the width and height.\n            </SectionHeader>\n            <SectionText>\n              Slack has a limit of 128x128 pixels. Discord has a limit of\n              256x256.\n            </SectionText>\n            <SectionText>\n              Making images smaller will also decrease how long it takes to\n              apply effects.\n            </SectionText>\n          </Section>\n\n          <Divider />\n\n          <Section>\n            <SectionHeader>The order of effects matters</SectionHeader>\n            <SectionText>\n              The result of each effect is send to the next effect.\n            </SectionText>\n            <SectionText>\n              Because of this, the order of effects matter.\n            </SectionText>\n            <SectionText>\n              Experiment with moving effects around to see different effects.\n            </SectionText>\n            <SectionText>\n              For instance, applying a background color before rotating the\n              image will have a very different effect than rotating before\n              setting a background color.\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n\n      <Expandable mainEle={<Typography variant=\"h6\">Creating Gifs</Typography>}>\n        <Group>\n          <Section>\n            <SectionHeader>Gifs will compute automatically</SectionHeader>\n            <SectionText>\n              Whenever you add an effect, it will automatically compute a new\n              gif with that effect.\n            </SectionText>\n            <SectionText>\n              The gif below each effect shows the results of that effect.\n            </SectionText>\n            <SectionText>\n              Click on \"Save Gif\" at the bottom to export the final version of\n              the gif after all effects have been applied.\n            </SectionText>\n          </Section>\n        </Group>\n      </Expandable>\n    </Group>\n  </Expandable>\n);\n\nconst Group: React.FC = ({ children }) => <Stack spacing={2}>{children}</Stack>;\n\nconst Section: React.FC = ({ children }) => (\n  <Stack width=\"sm\" spacing={1}>\n    {children}\n  </Stack>\n);\n\nconst SectionHeader: React.FC = ({ children }) => (\n  <Typography variant=\"body1\" paddingLeft=\"0.5rem\">\n    {children}\n  </Typography>\n);\n\nconst SectionText: React.FC = ({ children }) => (\n  <Typography variant=\"body2\" paddingLeft=\"1.0rem\">\n    <Icon sx={{ fontSize: 8, marginRight: 1 }}>circle</Icon> {children}\n  </Typography>\n);\n","/** Given a URL to an image, try to load it and return the data URL for it */\nexport const getImageFromUrl = async (url: string) => {\n  return new Promise<string>((resolve, reject) => {\n    const img = new Image();\n    img.setAttribute('crossOrigin', 'anonymous');\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error('Canvas not supported');\n      }\n      ctx.drawImage(img, 0, 0);\n      resolve(canvas.toDataURL());\n    };\n\n    img.onerror = () => {\n      reject(new Error('Error loading url'));\n    };\n\n    img.src = url;\n  });\n};\n","import bezier from 'bezier-easing';\nimport { Coord } from '../types';\nimport { BezierTuple } from '../../params';\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new Error(`AssertionFailure: ${message}`);\n  }\n}\n\n/** Returns a new array where the item at the given index is replaced by the given value */\nexport const replaceIndex = <T>(\n  arr: T[],\n  index: number,\n  newValueFn: (oldValue: T) => T\n): T[] => arr.map((x, i) => (index === i ? newValueFn(x) : x));\n\n/**\n * Returns a new array with the new item inserted into the given index.\n * @example\n * insertInto(['a','b','c'], 1, 'z'); // ['a','z','b','c']\n */\nexport const insertInto = <T>(arr: T[], index: number, newValue: T): T[] => {\n  return [...arr.slice(0, index), newValue, ...arr.slice(index)];\n};\n\nexport const isUrl = (s: string): boolean =>\n  /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/.test(\n    s\n  );\n\nexport const copyToClipboard = (s: string): Promise<void> =>\n  navigator.clipboard.writeText(s);\n\nexport const readFromClipboard = (): Promise<string> =>\n  navigator.clipboard.readText();\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Returns the angle in degrees (0 to 360) from c2 to c1\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\nexport const pointDistance = ([x1, y1]: Coord, [x2, y2]: Coord): number => {\n  const xDiff = Math.pow(x2 - x1, 2);\n  const yDiff = Math.pow(y2 - y1, 2);\n  return Math.sqrt(xDiff + yDiff);\n};\n\n/**\n * Calculates a cubic bezier curve for a given value.\n * Each value in the BezierTuple must also be between 0 and 1.\n * The amount must be between 0 and 1.\n * If mirror is true, then amount of [0, 0.5] will go from 0 to 1, and (0.5, 1] will go from 1 to 0.\n * The returned value will be between 0 and 1\n */\nexport const bezierCurve = (easing: BezierTuple, mirror?: boolean) => {\n  const fn = bezier(easing[0][0], easing[0][1], easing[1][0], easing[1][1]);\n  if (!mirror) {\n    return (amount: number): number => fn(amount);\n  }\n  return (amount: number): number => {\n    return amount < 0.5 ? fn(amount * 2) : fn(1 - 2 * (amount - 0.5));\n  };\n};\n\nexport const LINEAR_BEZIER: BezierTuple = [\n  [0.1, 0.1],\n  [0.9, 0.9],\n];\n","import seedrandom from 'seedrandom';\n\ntype JsonPrimitive = string | number | boolean | Uint8ClampedArray | null;\ninterface JsonMap {\n  [member: string]: JsonPrimitive | JsonArray | JsonMap;\n}\ninterface JsonArray extends Array<JsonPrimitive | JsonArray | JsonMap> {}\nexport type JsonType = JsonPrimitive | JsonMap | JsonArray;\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * Coordinate to index mapping:\n * [0, 0] = indices 0-3\n * [1, 0] = indices 4-7\n * [2, 0] = indices 8-11\n * [0, 1] = indices 12-15\n * [1, 1] = indices 16-19\n * [2, 1] = indices 20-23\n *\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type FrameData = Uint8ClampedArray;\n\n/**\n * Contains the dimensions of an image, along with an array of frames.\n * Each frame is a one-dimension array of colors (see `FrameData`).\n * Each frame represents one frame in the animation -- if `frames` has length 4, then\n *  it means that there are 4 animation frames in the image.\n */\nexport type Image = {\n  dimensions: Dimensions;\n  frames: FrameData[];\n};\n\nexport type Random = seedrandom.prng;\n\nexport interface EffectFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport interface Parameter<T extends JsonType> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T extends JsonType> {\n  value: T;\n  onChange: (v: T) => void;\n}\n\nexport type ParamFunction<T extends JsonType> = {\n  name: string;\n  /**\n   * If the previous image is done computing, it will be given to this function.\n   * If it's not done computing, `undefined` will be given\n   */\n  defaultValue: (image?: Image) => T;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type ParamFnDefault<T extends JsonType> =\n  | ParamFunction<T>['defaultValue']\n  | T;\n\nexport const toParamFunction = <T extends JsonType>(\n  x: ParamFnDefault<T>\n): ParamFunction<T>['defaultValue'] => {\n  if (typeof x === 'function') {\n    return x;\n  }\n  return () => x;\n};\n\nexport type EffectFn<Params> = (\n  opts: EffectFnOpts<Params>\n) => Image | Promise<Image>;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Effect<T extends readonly ParamFunction<any>[]> {\n  /** Name of the effect. Must be globally unique */\n  name: string;\n  params: T;\n  /** Description of the effect, will show up in the dropdown */\n  description: string;\n  /** Extra description to be shown in the parameters dialog menu */\n  secondaryDescription?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled: boolean;\n}\n\nexport interface EffectInput {\n  effectName: string;\n  params: any;\n}\n\nexport const buildEffect = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description: string;\n  secondaryDescription?: string;\n  fn: EffectFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled?: boolean;\n}): Effect<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  secondaryDescription: args.secondaryDescription,\n  fn: args.fn,\n  disabled: args.disabled ?? false,\n});\n\nexport interface AppStateEffect {\n  effectName: string;\n  paramsValues: any[];\n  state:\n    | { status: 'init' }\n    | { status: 'computing' }\n    | {\n        status: 'done';\n        image: ImageEffectResult;\n      };\n}\n\nexport interface AppState {\n  version: number;\n  baseImage?: ImageEffectResult;\n  fname?: string;\n  effects: AppStateEffect[];\n  fps: number;\n}\n\nexport interface ImageEffectResult {\n  gif: string;\n  image: Image;\n  gifWithBackgroundColor: string;\n  partiallyTransparent: boolean;\n}\n\nexport type AsyncRunMessage = {\n  status: 'complete';\n  result: ImageEffectResult;\n};\n\nexport interface CanvasData {\n  canvas: OffscreenCanvas | HTMLCanvasElement;\n  ctx: OffscreenCanvasRenderingContext2D | CanvasRenderingContext2D;\n}\n","import * as convert from 'color-convert';\nimport { Color } from '../types';\nimport { clamp, weightedValue } from './misc';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our effect functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\n/**\n * Returns true if the pixel is partially transparent enough that\n *  it would cause issues rendering.\n */\nexport const isPartiallyTransparent = (pixel: Color) =>\n  !isTransparent(pixel) && pixel[3] < 220;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\n/**\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftTowardsHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Adds the given amount to the hue of the color.\n * Amount should be between 0 and 360\n */\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\n  return [newR, newG, newB, a];\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n\nexport const adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nexport const adjustBrightness = (color: Color, amount: number): Color => {\n  const d = (amount / 100) * 128;\n  const [r, g, b, a] = color;\n  return clampColor([r + d, g + d, b + d, a]);\n};\n\n// Amount: -100 to 100\nexport const adjustContrast = (color: Color, amount: number): Color => {\n  const d = amount / 100 + 1;\n  const [r, g, b, a] = color;\n  return clampColor([\n    d * (r - 128) + 128,\n    d * (g - 128) + 128,\n    d * (b - 128) + 128,\n    a,\n  ]);\n};\n\n/**\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\n */\nexport const colorDiff = (c1: Color, c2: Color): number => {\n  // Red-mean color diff algorithm\n  // https://en.wikipedia.org/wiki/Color_difference\n  const deltaRed = c1[0] - c2[0];\n  const deltaBlue = c1[1] - c2[1];\n  const deltaGreen = c1[2] - c2[2];\n  const rSomething = (c1[0] + c2[0]) / 2;\n\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\n  const gComponent = 4 * deltaGreen * deltaGreen;\n  // 765 = ~ difference between black and white pixels\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\n};\n","// When in a web worker, the window isn't defined.\nexport const IS_WORKER = typeof window === 'undefined';\n","import { CanvasData, Dimensions, FrameData, Color } from '../types';\nimport { toHexColor } from './color';\nimport { IS_WORKER } from './isWorker';\nimport { assert } from './misc';\n\nexport const createCanvas = ([width, height]: Dimensions): CanvasData => {\n  if (IS_WORKER) {\n    // Note that mobile does NOT support OffscreenCanvas.\n    // So if mobile, then we can not use web workers!\n    const canvas = new OffscreenCanvas(width, height);\n    const ctx = canvas.getContext('2d');\n    assert(ctx, 'Canvas not supported');\n    return { canvas, ctx };\n  } else {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    assert(ctx, 'Canvas not supported');\n    return { canvas, ctx };\n  }\n};\n\n/** Converts a frame to a CanvasData */\nexport const frameToCanvas = ({\n  dimensions,\n  frame,\n}: {\n  dimensions: Dimensions;\n  frame: FrameData;\n}): CanvasData => {\n  const [width, height] = dimensions;\n  const { canvas, ctx } = createCanvas(dimensions);\n\n  const imageData = new ImageData(frame, width, height);\n\n  ctx.putImageData(imageData, 0, 0);\n\n  return { canvas, ctx };\n};\n\n/** Convert a CanvasData into a FrameData */\nexport const canvasToFrame = (canvasData: CanvasData): FrameData => {\n  const imageData = canvasData.ctx.getImageData(\n    0,\n    0,\n    canvasData.canvas.width,\n    canvasData.canvas.height\n  );\n  return imageData.data;\n};\n\n/**\n * Allows you to apply a JS Canvas to an image.\n * Use the `preEffect` and `postEffect` functions to maniuplate the image\n *  both before and after drawing the image to the canvas.\n */\nexport const applyCanvasFromFrame = ({\n  dimensions,\n  frame,\n  preEffect,\n  postEffect,\n}: {\n  dimensions: Dimensions;\n  frame: FrameData;\n  /** Manipulate the context *before* drawing the image. Set things like filters here */\n  preEffect?: (canvasData: CanvasData) => void;\n  /** Manipulate the context *after* drawing the image. Use this to draw on top of the image */\n  postEffect?: (canvasData: CanvasData) => void;\n}): FrameData => {\n  // Create a new Canvas using our existing image.\n  // We can then draw that onto a second canvas, which will have effects applied to it.\n  const canvasData = createCanvas(dimensions);\n\n  canvasData.ctx.save();\n  preEffect?.(canvasData);\n  canvasData.ctx.drawImage(frameToCanvas({ dimensions, frame }).canvas, 0, 0);\n  canvasData.ctx.restore();\n  postEffect?.(canvasData);\n\n  return canvasData.ctx.getImageData(0, 0, dimensions[0], dimensions[1]).data;\n};\n\n/**\n * Combines two canvases or frames together.\n * It's assumed that the foreground has some transparency to it.\n */\nexport const combineImages = ({\n  dimensions,\n  background,\n  foreground,\n}: {\n  dimensions: Dimensions;\n  background: FrameData | CanvasData;\n  foreground: FrameData | CanvasData;\n}): FrameData => {\n  const backgroundCanvas =\n    'canvas' in background\n      ? background\n      : frameToCanvas({\n          dimensions: dimensions,\n          frame: background,\n        });\n\n  const foregroundCanvas =\n    'canvas' in foreground\n      ? foreground\n      : frameToCanvas({\n          dimensions: dimensions,\n          frame: foreground,\n        });\n\n  backgroundCanvas.ctx.drawImage(foregroundCanvas.canvas, 0, 0);\n\n  return canvasToFrame(backgroundCanvas);\n};\n\nexport const applyFilter = (\n  canvas: CanvasData,\n  {\n    blur,\n    brightness,\n    contrast,\n    opacity,\n    saturation,\n    hueRotate,\n    sepia,\n    dropShadow,\n  }: {\n    /** # pixels */\n    blur?: number;\n    /** [0, 100) percent */\n    opacity?: number;\n    /** [0, 100) percent */\n    brightness?: number;\n    /** [0, 100) percent */\n    contrast?: number;\n    /** [0, 100) percent */\n    saturation?: number;\n    /** [0, 360) degrees */\n    hueRotate?: number;\n    /** [0, 100) percent */\n    sepia?: number;\n    dropShadow?: {\n      offsetX: number;\n      offsetY: number;\n      color: Color;\n      /** Positive number, defaults to 0 */\n      blurRadius?: number;\n    };\n  }\n): CanvasData => {\n  const shadow = dropShadow\n    ? [\n        `${dropShadow.offsetX}px`,\n        `${dropShadow.offsetY}px`,\n        `${dropShadow.blurRadius ?? 0}px`,\n        `${toHexColor(dropShadow.color)}`,\n      ].join(' ')\n    : null;\n\n  const filters = [\n    blur == null ? '' : `blur(${blur}px)`,\n    brightness == null ? '' : `brightness(${brightness}%)`,\n    contrast == null ? '' : `contrast(${contrast}%)`,\n    opacity == null ? '' : `opacity(${opacity}%)`,\n    saturation == null ? '' : `saturate(${saturation}%)`,\n    hueRotate == null ? '' : `hue-rotate(${hueRotate}deg)`,\n    sepia == null ? '' : `sepia(${sepia}%)`,\n    shadow == null ? '' : `drop-shadow(${shadow})`,\n  ].filter((x) => x.length > 0);\n\n  canvas.ctx.filter = filters.join(' ');\n\n  return canvas;\n};\n\nexport const applyTransform = (\n  canvas: CanvasData,\n  {\n    horizontalScale,\n    verticalScale,\n    horizontalSkew,\n    verticalSkew,\n    horizontalTranslation,\n    verticalTranslation,\n  }: {\n    horizontalScale?: number;\n    verticalScale?: number;\n    horizontalSkew?: number;\n    verticalSkew?: number;\n    horizontalTranslation?: number;\n    verticalTranslation?: number;\n  }\n): CanvasData => {\n  canvas.ctx.transform(\n    horizontalScale ?? 1,\n    verticalSkew ?? 0,\n    horizontalSkew ?? 0,\n    verticalScale ?? 1,\n    horizontalTranslation ?? 0,\n    verticalTranslation ?? 0\n  );\n  return canvas;\n};\n\n/**\n * Rotates a canvas a number of degrees.\n * 0 degrees points to the right, 90 degrees points up.\n */\nexport const applyRotation = (\n  canvas: CanvasData,\n  degrees: number\n): CanvasData => {\n  const offsetX = canvas.canvas.width / 2;\n  const offsetY = canvas.canvas.height / 2;\n  applyTransform(canvas, {\n    horizontalTranslation: offsetX,\n    verticalTranslation: offsetY,\n  });\n  const radians = -(degrees * Math.PI) / 180;\n  canvas.ctx.rotate(radians);\n  applyTransform(canvas, {\n    horizontalTranslation: -offsetX,\n    verticalTranslation: -offsetY,\n  });\n  return canvas;\n};\n","import { range } from 'remeda';\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  EffectFn,\n  EffectFnOpts,\n  FrameData,\n  Image,\n  Random,\n} from '../types';\nimport {\n  applyCanvasFromFrame,\n  applyTransform,\n  canvasToFrame,\n  createCanvas,\n  frameToCanvas,\n} from './canvas';\nimport {\n  clampColor,\n  TRANSPARENT_COLOR,\n  isPartiallyTransparent as isColorPartiallyTransparent,\n} from './color';\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: FrameData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: FrameData,\n    frameIndex: number,\n    frameCount: number\n  ) => FrameData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): FrameData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8ClampedArray(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress: frameIndex / frameCount,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/**\n * Similar to mapImage, but the first argument pre-computes some things for\n *  each frame, which is then passed to the second callback function.\n * This is useful for performance (only compute things every frame rather than every pixel),\n *  and also allows you to generate some random value that will be the same for every frame.\n */\nexport const mapImageWithPrecompute = <T, R>(\n  compute: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n  }) => R,\n  cb: (args: {\n    computed: R;\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): EffectFn<T> => {\n  return ({ image, random, parameters }: EffectFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const computed = compute({\n        image,\n        dimensions: image.dimensions,\n        random,\n        parameters,\n        frameCount,\n        frameIndex,\n        animationProgress,\n      });\n\n      return mapCoords(image.dimensions, (coord) =>\n        cb({\n          computed,\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      );\n    });\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Scales the image according to a coefficient\n * Coefficient should be greater than 0.\n * A coefficient of 1 equals no scaling.\n * The image will be centered.\n */\nexport const scaleImage = ({\n  image,\n  horizontalScale,\n  verticalScale,\n}: {\n  image: Image;\n  horizontalScale?: number;\n  verticalScale?: number;\n}): Image => {\n  const [width, height] = image.dimensions;\n  // Adjust how much the image is offset in order to keep it centered\n  const offsetX = (width / 2) * (horizontalScale ?? 1) - width / 2;\n  const offsetY = (height / 2) * (verticalScale ?? 1) - height / 2;\n  return mapFrames(image, (imageData) =>\n    applyCanvasFromFrame({\n      dimensions: image.dimensions,\n      frame: imageData,\n      preEffect: (canvasData) =>\n        applyTransform(canvasData, {\n          horizontalScale,\n          verticalScale,\n          horizontalTranslation: -offsetX,\n          verticalTranslation: -offsetY,\n        }),\n    })\n  );\n};\n\n/**\n * Resize the image to the given dimensions.\n * If `keepScale` is true, then the image will be automatically\n *  resized to keep match the new dimensions.\n * If false, then the image will remain the same size, and will be cropped\n *  if the new dimensions are smaller.\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n  keepScale,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n  keepScale: boolean;\n}): Image => {\n  const newFrames = mapFrames(image, (frame) => {\n    const rootCanvas = createCanvas([newWidth, newHeight]);\n    const imgCanvas = frameToCanvas({ dimensions: image.dimensions, frame });\n\n    if (keepScale) {\n      // Just blow it up\n      rootCanvas.ctx.drawImage(imgCanvas.canvas, 0, 0, newWidth, newHeight);\n    } else {\n      // Keep the image the same size, but be sure to center it\n      const offsetX = newWidth / 2 - image.dimensions[0] / 2;\n      const offsetY = newHeight / 2 - image.dimensions[1] / 2;\n      rootCanvas.ctx.drawImage(\n        imgCanvas.canvas,\n        offsetX,\n        offsetY,\n        image.dimensions[0],\n        image.dimensions[1]\n      );\n    }\n\n    return canvasToFrame(rootCanvas);\n  });\n\n  return {\n    dimensions: [newWidth, newHeight],\n    frames: newFrames.frames,\n  };\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8ClampedArray(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const duplicateImage = (image: Image): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((f) => new Uint8ClampedArray(f)),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\nexport const changeFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had fewer than that, then we'll\n  //  duplicate some frames to approximately slow the animation.\n  // If the original has more frames, then we'll discard some frames.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) => {\n      const frameToCopy = Math.floor((i / frameCount) * currentFrames.length);\n      return currentFrames[frameToCopy];\n    }),\n  };\n};\n\nexport const isPartiallyTransparent = (image: Image): boolean => {\n  // Could probably optimize this to just read the image data arrays directly, for every 4th index\n  for (const frame of image.frames) {\n    for (let x = 0; x < image.dimensions[0]; x += 1) {\n      for (let y = 0; y < image.dimensions[1]; y += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isColorPartiallyTransparent(px)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n","import { Icon, Tooltip } from '@material-ui/core';\nimport React from 'react';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import React from 'react';\n\ninterface Props<T> {\n  value: T;\n  debounceMillis?: number;\n  onChange: (newValue: T) => void;\n}\n\nexport function useDebounce<T>({\n  value,\n  debounceMillis,\n  onChange,\n}: Props<T>): [T, (newT: T) => void] {\n  const [v, setV] = React.useState<T>(value);\n  const debounceRef = React.useRef<NodeJS.Timeout>();\n  const onValueChange = React.useCallback(\n    (newV: T) => {\n      setV(newV);\n      if (debounceRef.current != null) {\n        clearTimeout(debounceRef.current);\n      }\n      debounceRef.current = setTimeout(() => {\n        onChange(newV);\n      }, debounceMillis ?? 200);\n    },\n    [debounceMillis, onChange]\n  );\n\n  return [v, onValueChange];\n}\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { useDebounce } from '../domain/utils/useDebounce';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  const [val, setVal] = useDebounce({\n    value,\n    onChange,\n    debounceMillis: 500,\n  });\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={val}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) => {\n            setVal(value as number);\n          }}\n        />\n        <Typography variant=\"body2\">{val}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue: ParamFnDefault<number>;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { resizeImage, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const adjustImage = buildEffect({\n  name: 'Adjust Image',\n  description: 'Change the dimensions, brightness, contrast etc.',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Sepia',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [\n      resizeToWidth,\n      resizeToHeight,\n      brightness,\n      contrast,\n      saturation,\n      sepia,\n    ],\n  }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\n\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\n    const newWidth =\n      hasScaleChange && resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      hasScaleChange && resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\n\n    let currImage = image;\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = resizeImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n        keepScale: true,\n      });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      applyCanvasFromFrame({\n        dimensions: currImage.dimensions,\n        frame: imageData,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            brightness: brightness + 100,\n            contrast: contrast + 100,\n            saturation: saturation + 100,\n            sepia: sepia,\n          }),\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = resizeImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n        keepScale: true,\n      });\n    }\n\n    return currImage;\n  },\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  Color,\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils/color';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value: Color;\n  description?: string;\n  onChange: (v: Color) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={toHexColor(value)}\n        onChangeComplete={(c) => {\n          onChange(fromHexColor(c.hex));\n        }}\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<Color>;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const backgroundColor = buildEffect({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [color, opacity] }) =>\n    mapFrames(image, (frame) => {\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => color),\n        foreground,\n      });\n    }),\n});\n","import React from 'react';\nimport { Checkbox, Stack, Typography } from '@material-ui/core';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst CheckboxParam: React.FC<{\n  name: string;\n  value?: boolean;\n  description?: string;\n  onChange: (v: boolean) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Checkbox\n          aria-label={name}\n          checked={value}\n          onChange={(e) => onChange(e.target.checked)}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function checkboxParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<boolean>;\n  description?: string;\n}): ParamFunction<boolean> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <CheckboxParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { ImagePicker } from '../components/ImagePicker';\nimport { Image, ImageEffectResult, ParamFunction } from '../domain/types';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\n// Technically a ImageEffectResult but TS pukes for some reason\ntype ParamType = {\n  gif: string;\n  gifWithBackgroundColor: string;\n  image: Image;\n  partiallyTransparent: boolean;\n};\n\n// Just a 1x1 black jpg. Surprisingly big!\nconst DEFAULT_IMAGE: ImageEffectResult = {\n  gif: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\n  gifWithBackgroundColor:\n    'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/8AAEQgAAQABAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgICAgICAwICAgIDBAMDAwMDBAUEBAQEBAQFBQUFBQUFBQYGBgYGBgcHBwcHCAgICAgICAgICP/bAEMBAQEBAgICAwICAwgFBAUICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/dAAQAAf/aAAwDAQACEQMRAD8A/wA/+iiigD//2Q==',\n  image: {\n    dimensions: [1, 1],\n    frames: [new Uint8ClampedArray([0, 0, 0, 255])],\n  },\n  partiallyTransparent: false,\n};\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<ParamType> {\n  return {\n    name,\n    defaultValue: () => DEFAULT_IMAGE,\n    fn: (params) => (\n      <ImagePicker\n        currentImage={params.value}\n        width={64}\n        height={64}\n        onChange={params.onChange}\n      />\n    ),\n  };\n}\n","import {\n  FormControl,\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst RadioParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value: string;\n  description?: string;\n  onChange: (s: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label={name}\n          defaultValue={value}\n          onChange={(event) => onChange(event.target.value)}\n        >\n          {options.map((t) => (\n            <FormControlLabel\n              value={t.value}\n              control={<Radio />}\n              label={t.name}\n              key={t.value}\n            />\n          ))}\n        </RadioGroup>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function radioParam<T extends string>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue: ParamFnDefault<T>;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <RadioParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={(s) => params.onChange(s as T)}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { combineImages, frameToCanvas } from '../domain/utils/canvas';\nimport { resizeImage, mapFrames } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { radioParam } from '../params/radioParam';\n\nexport const backgroundImage = buildEffect({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  secondaryDescription:\n    'If the selected image is animated, this will speed up/slow down ' +\n    'the animation to match the original image',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    checkboxParam({\n      name: 'Scale Image',\n      defaultValue: false,\n      description:\n        'If true, the new image will be scaled to fit the dimensions of the original image',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [otherImagePreResize, type, keepScale] }) => {\n    const otherImage = resizeImage({\n      image: otherImagePreResize.image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n      keepScale,\n    });\n\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n\n      const thisFrameCanvas = frameToCanvas({\n        dimensions: image.dimensions,\n        frame,\n      });\n\n      const otherImageFrameIndex = Math.floor(\n        animationProgress * otherImage.frames.length\n      );\n      const otherFrameCanvas = frameToCanvas({\n        dimensions: otherImage.dimensions,\n        frame: otherImage.frames[otherImageFrameIndex],\n      });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: type === 'background' ? otherFrameCanvas : thisFrameCanvas,\n        foreground: type === 'background' ? thisFrameCanvas : otherFrameCanvas,\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const blur = buildEffect({\n  name: 'Blur',\n  description: 'Blurs the image',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      defaultValue: 2,\n      min: 0,\n      max: 20,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [amount] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyFilter(canvasData, { blur: amount }),\n      })\n    ),\n});\n","import React from 'react';\nimport { Coord } from '../../domain/types';\n\nexport type BezierTuple = [Coord, Coord];\n\nexport interface CavasElementProps {\n  width: number;\n  height: number;\n  cursorIsPointer?: boolean;\n  onCanvasMount: (context: CanvasRenderingContext2D) => void;\n  onMouseDown?: (coord: Coord) => void;\n  onMouseMove?: (coord: Coord) => void;\n  onMouseUp?: (coord: Coord) => void;\n  onMouseLeave?: (coord: Coord) => void;\n}\n\nexport const CanvasElement: React.FC<CavasElementProps> = ({\n  width,\n  height,\n  cursorIsPointer,\n  onCanvasMount,\n  onMouseDown,\n  onMouseUp,\n  onMouseMove,\n  onMouseLeave,\n}) => {\n  const ref = React.useRef<HTMLCanvasElement>(null);\n  const isMounted = React.useRef(false);\n\n  const canvas = ref.current;\n\n  React.useEffect(() => {\n    if (canvas && !isMounted.current) {\n      const ctx = canvas.getContext('2d');\n      if (ctx != null) {\n        onCanvasMount(ctx);\n        isMounted.current = true;\n      }\n    }\n  }, [canvas, isMounted, onCanvasMount]);\n\n  const onEvent =\n    (callback: undefined | ((c: Coord) => void)) =>\n    (evt: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      if (!canvas || !callback) {\n        return;\n      }\n\n      const rect = canvas.getBoundingClientRect();\n      const x = evt.clientX - rect.left;\n      const y = evt.clientY - rect.top;\n      setTimeout(() => callback([x, y]), 0);\n    };\n\n  const style = React.useMemo((): React.CSSProperties | undefined => {\n    if (cursorIsPointer) {\n      return { cursor: 'pointer' };\n    } else {\n      return undefined;\n    }\n  }, [cursorIsPointer]);\n\n  return (\n    <canvas\n      ref={ref}\n      width={width}\n      height={height}\n      onMouseDown={onEvent(onMouseDown)}\n      onMouseUp={onEvent(onMouseUp)}\n      onMouseMove={onEvent(onMouseMove)}\n      onMouseLeave={onEvent(onMouseLeave)}\n      style={style}\n    ></canvas>\n  );\n};\n","import React from 'react';\nimport * as R from 'remeda';\nimport { Box, Stack, Typography } from '@material-ui/core';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  Coord,\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { CanvasElement } from '../domain/utils/CanvasElement';\nimport { useDebounce } from '../domain/utils/useDebounce';\nimport { clamp, pointDistance } from '../domain/utils/misc';\n\nexport type BezierTuple = [Coord, Coord];\n\nconst BezierParam: React.FC<{\n  name: string;\n  value: BezierTuple;\n  description?: string;\n  onChange: (v: BezierTuple) => void;\n}> = ({ name, value, description, onChange }) => {\n  const WIDTH = 64;\n  const HEIGHT = 64;\n  const MARKER_RADIUS = 5;\n  const DEBOUNCE_TIME = 200;\n\n  const [curValue, setCurValue] = useDebounce({\n    value,\n    onChange,\n    debounceMillis: DEBOUNCE_TIME,\n  });\n\n  const [latestMouseLocation, setLatestMouseLocation] = React.useState<Coord>([\n    0, 0,\n  ]);\n\n  const [canvasCtx, setCanvasCtx] =\n    React.useState<CanvasRenderingContext2D | null>(null);\n  const onCanvasMount = React.useCallback((ctx: CanvasRenderingContext2D) => {\n    setCanvasCtx(ctx);\n  }, []);\n\n  const [isDragging, setIsDragging] = React.useState<number | null>(null);\n\n  const closestPointIdx = React.useMemo(() => {\n    const distances = curValue.map((c, idx) => ({\n      idx,\n      coord: c,\n      distance: pointDistance(\n        [c[0] * WIDTH, c[1] * HEIGHT],\n        latestMouseLocation\n      ),\n    }));\n\n    const sorted = R.sortBy(distances, (d) => d.distance);\n    const closest = sorted[0];\n    return closest.distance < MARKER_RADIUS ? closest.idx : null;\n  }, [latestMouseLocation, curValue]);\n\n  React.useEffect(() => {\n    if (!canvasCtx) {\n      return;\n    }\n\n    canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\n\n    // Draw each dot - 4x4 circle\n    canvasCtx.fillStyle = 'red';\n    for (const coord of curValue) {\n      const x = coord[0] * WIDTH;\n      const y = coord[1] * HEIGHT;\n      canvasCtx.beginPath();\n      canvasCtx.ellipse(x, y, MARKER_RADIUS, MARKER_RADIUS, 0, 0, 2 * Math.PI);\n      canvasCtx.fill();\n    }\n\n    // Draw the bezier curve itself\n    canvasCtx.beginPath();\n    canvasCtx.moveTo(0, 0);\n    canvasCtx.strokeStyle = 'black';\n    canvasCtx.bezierCurveTo(\n      curValue[0][0] * WIDTH,\n      curValue[0][1] * HEIGHT,\n      curValue[1][0] * WIDTH,\n      curValue[1][1] * HEIGHT,\n      WIDTH,\n      HEIGHT\n    );\n    canvasCtx.stroke();\n  }, [curValue, canvasCtx]);\n\n  const onMouseDown = React.useCallback(() => {\n    setIsDragging(closestPointIdx);\n  }, [closestPointIdx]);\n\n  const onMouseUp = React.useCallback(() => {\n    setIsDragging(null);\n  }, []);\n\n  const onMouseMove = React.useCallback(\n    (c: Coord) => {\n      setLatestMouseLocation(c);\n\n      const newCoord: Coord = [\n        clamp(c[0] / WIDTH, 0, WIDTH),\n        clamp(c[1] / HEIGHT, 0, HEIGHT),\n      ];\n\n      if (isDragging === 0) {\n        setCurValue([newCoord, curValue[1]]);\n      } else if (isDragging === 1) {\n        setCurValue([curValue[0], newCoord]);\n      }\n    },\n    [isDragging, curValue, setCurValue]\n  );\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Box border={1}>\n          <CanvasElement\n            width={WIDTH}\n            height={HEIGHT}\n            onCanvasMount={onCanvasMount}\n            onMouseDown={onMouseDown}\n            onMouseUp={onMouseUp}\n            onMouseLeave={onMouseUp}\n            onMouseMove={onMouseMove}\n            cursorIsPointer={closestPointIdx != null}\n          />\n        </Box>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function bezierParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<BezierTuple>;\n  description?: string;\n}): ParamFunction<BezierTuple> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <BezierParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import {\n  FormControl,\n  MenuItem,\n  Select,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst DropdownParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: string }[];\n  value?: any;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <Select\n          autoWidth\n          value={value}\n          onChange={(event) => onChange(event.target.value as string)}\n        >\n          {options.map((t) => (\n            <MenuItem key={t.value} value={t.value}>\n              {t.name}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function dropdownParam<T extends string>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue: ParamFnDefault<T>;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <DropdownParam\n          name={args.name}\n          value={params.value}\n          options={args.options}\n          description={args.description}\n          onChange={params.onChange as any}\n        />\n      );\n    },\n  };\n}\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(value.toString());\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n      onChange(n.value);\n    } else {\n      setInvalidText(n.reason);\n    }\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value}\n      />\n    );\n  },\n});\n","import { Stack, Typography } from '@material-ui/core';\nimport * as convert from 'color-convert';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\nimport { toHexColor } from '../domain/utils/color';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: number) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor = React.useMemo(\n    () =>\n      value === undefined\n        ? undefined\n        : toHexColor([...convert.hsl.rgb([value, 100, 50]), 255]),\n    [value]\n  );\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        // HSL is in [0-360, 0-100, 0-100]\n        onChangeComplete={({ hsl }) => onChange(hsl.h)}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue: ParamFnDefault<number>;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value: string;\n  description?: string;\n  onChange: (v: string) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() => {\n            if (val.length > 0) {\n              onChange(val);\n            }\n          }}\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue: ParamFnDefault<string>;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue: toParamFunction(args.defaultValue),\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value}\n    />\n  ),\n});\n","import {\n  Button,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport {\n  JsonType,\n  ParamFnDefault,\n  ParamFunction,\n  toParamFunction,\n} from '../domain/types';\n\ninterface VariableLengthProps<T extends JsonType> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value: T[];\n  description?: string;\n  onChange: (v: T) => void;\n}\n\ntype ParamState = { param: ParamFunction<any>; pValue: any };\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<ParamState[]>(\n    value.map((v) => ({ param: createNewParam(), pValue: v }))\n  );\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: pValue,\n            onChange: (newValue) => {\n              const p = params.map((oldP, i) => {\n                if (idx === i) {\n                  return {\n                    param,\n                    pValue: newValue,\n                  };\n                }\n                return oldP;\n              });\n              setParams(p);\n              onChange(p.map((n) => n.pValue));\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange(newParams.map((n) => n.pValue));\n                }}\n                style={{\n                  visibility:\n                    idx === 0 /* Hide delete on first item */\n                      ? 'hidden'\n                      : undefined,\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams: ParamState[] = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue(),\n              },\n            ];\n            setParams(newParams);\n            const vals = newParams.map((n) => n.pValue);\n            onChange(vals);\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T extends JsonType>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue: ParamFnDefault<T[]>;\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: toParamFunction(args.defaultValue),\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { bezierCurve, LINEAR_BEZIER } from '../domain/utils/misc';\nimport { bezierParam } from '../params';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildEffect({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Height',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[1] / 10) : 10,\n      min: 0,\n    }),\n    bezierParam({\n      name: 'Easing',\n      defaultValue: LINEAR_BEZIER,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [height, easing] }) => {\n      const b = bezierCurve(easing, true)(animationProgress);\n      return {\n        yOffset: Math.round(height * b),\n      };\n    },\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x, y + yOffset])\n  ),\n});\n","import { concat, drop, pipe, reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const bounceAnimation = buildEffect({\n  name: 'Bounce Animation',\n  description: 'When the animation finishes, it will be replayed in reverse',\n  secondaryDescription: 'This doubles the number of animation frames.',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: concat(\n      image.frames,\n      pipe(image.frames, drop(1), reverse(), drop(1))\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildEffect({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [radius] }) => ({\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\n    }),\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y + yOffset])\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  adjustBrightness,\n  getAveragePixelValue,\n} from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildEffect({\n  name: 'Colors',\n  description: 'Make the image flash different colors of your choosing',\n  secondaryDescription: 'Increase the brightness to increase the effect',\n  params: [\n    sliderParam({\n      name: 'Brightness Increase',\n      defaultValue: 0,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [brightnessIncrease, colors] }) => ({\n      brightnessIncrease,\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { brightnessIncrease, chosenColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (isTransparent(srcPixel)) {\n        return [0, 0, 0, 0];\n      }\n\n      const brightnessAdjusted =\n        brightnessIncrease > 0\n          ? adjustBrightness(srcPixel, brightnessIncrease)\n          : srcPixel;\n      const gray = getAveragePixelValue(brightnessAdjusted);\n\n      return [\n        (gray * chosenColor[0]) / 255,\n        (gray * chosenColor[1]) / 255,\n        (gray * chosenColor[2]) / 255,\n        255,\n      ];\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  combineImages,\n  applyCanvasFromFrame,\n  applyFilter,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildEffect({\n  name: 'Colors Background',\n  description:\n    'Transparent pixels will flash different colors of your choosing',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [colors, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const bgColor = colors[Math.floor(animationProgress * colors.length)];\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => bgColor),\n        foreground,\n      });\n    }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildEffect({\n  name: 'Double Vision',\n  description: 'See double',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\n      const dir = x % 2 === 0 ? -1 : 1;\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const dropShadow = buildEffect({\n  name: 'Drop Shadow',\n  description: 'Adds a drop shadow effect to the image',\n  params: [\n    intParam({\n      name: 'Offset X',\n      defaultValue: 10,\n    }),\n    intParam({\n      name: 'Offset Y',\n      defaultValue: 10,\n    }),\n    sliderParam({\n      name: 'Blur Radius',\n      min: 0,\n      max: 20,\n      step: 1,\n      defaultValue: 0,\n    }),\n    colorPickerParam({\n      name: 'Shadow Color',\n      defaultValue: [0, 0, 0, 0],\n    }),\n  ] as const,\n  fn: ({ image, parameters: [offsetX, offsetY, blurRadius, color] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            dropShadow: {\n              offsetX,\n              offsetY,\n              blurRadius,\n              color,\n            },\n          }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { bezierCurve, LINEAR_BEZIER } from '../domain/utils/misc';\nimport { bezierParam } from '../params';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildEffect({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\n      min: 0,\n    }),\n    bezierParam({\n      name: 'Easing',\n      defaultValue: LINEAR_BEZIER,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      animationProgress,\n      parameters: [radius, easing],\n    }) => ({\n      dist: bezierCurve(easing, true)(animationProgress) * radius,\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, dist },\n      dimensions: [width, height],\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { bezierCurve } from '../domain/utils/misc';\nimport { bezierParam, BezierTuple } from '../params';\n\nexport const fade = buildEffect({\n  name: 'Fade',\n  description: 'Fades the image in or out',\n  params: [\n    bezierParam({\n      name: 'Curve',\n      defaultValue: [\n        [0.25, 0.75],\n        [0.75, 0.25],\n      ],\n    }),\n  ] as const,\n  fn: ({ image, parameters: [curve] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            opacity: getOpacityAmount({\n              frameCount,\n              frameIndex,\n              curve,\n            }),\n          }),\n      })\n    ),\n});\n\nconst getOpacityAmount = ({\n  frameIndex,\n  frameCount,\n  curve,\n}: {\n  frameIndex: number;\n  frameCount: number;\n  curve: BezierTuple;\n}): number => {\n  const progress = frameIndex / (frameCount - 1);\n\n  return Math.round(bezierCurve(curve, true)(progress) * 100);\n};\n","import { buildEffect, Color, Coord, Image } from '../domain/types';\nimport { TRANSPARENT_COLOR, colorDiff } from '../domain/utils/color';\nimport {\n  duplicateImage,\n  getPixelFromSource,\n  setPixel,\n} from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\n// TODO\nexport const fill = buildEffect({\n  disabled: true,\n  name: 'Fill Transparent',\n  description:\n    'Makes transparent all pixels of similar color surrounding a point',\n  params: [\n    colorPickerParam({\n      name: 'Color to Make Transparent',\n      defaultValue: [0, 0, 0, 255],\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image: oldImage, parameters: [colorToReplace, tolerance] }) => {\n    const image = duplicateImage(oldImage);\n\n    for (\n      let frameIndex = 0;\n      frameIndex < image.frames.length;\n      frameIndex += 1\n    ) {\n      floodFill({\n        image,\n        frameIndex,\n        colorToReplace,\n        newColor: TRANSPARENT_COLOR,\n        tolerance,\n      });\n    }\n\n    return image;\n  },\n});\n\n// Mutates the given image/frameIndex\nconst floodFill = ({\n  image,\n  frameIndex,\n  colorToReplace,\n  newColor,\n  tolerance,\n}: {\n  image: Image;\n  frameIndex: number;\n  colorToReplace: Color;\n  tolerance: number;\n  newColor: Color;\n}) => {\n  const visited = (() => {\n    const set = new Set<string>();\n    return {\n      add: ([x, y]: Coord) => {\n        set.add(`${x}-${y}`);\n      },\n      has: ([x, y]: Coord) => set.has(`${x}-${y}`),\n    };\n  })();\n  const stack: Coord[] = [[0, image.dimensions[1] - 1]]; // Bottom right pixel\n  const push = (coord: Coord) => {\n    if (!visited.has(coord)) {\n      visited.add(coord);\n      stack.push(coord);\n    }\n  };\n\n  while (stack.length > 0) {\n    const coord = stack.pop()!;\n    const [x, y] = coord;\n    if (\n      x < 0 ||\n      x >= image.dimensions[0] ||\n      y < 0 ||\n      y >= image.dimensions[1]\n    ) {\n      // Out of bounds\n      continue;\n    }\n\n    const currColor = getPixelFromSource(\n      image.dimensions,\n      image.frames[frameIndex],\n      coord\n    );\n    if (colorDiff(currColor, colorToReplace) * 100 > tolerance) {\n      continue;\n    }\n\n    setPixel({\n      image,\n      frameIndex,\n      color: newColor,\n      coord: coord,\n    });\n\n    push([x + 1, y]);\n    push([x - 1, y]);\n    push([x, y + y]);\n    push([x, y - 1]);\n  }\n};\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildEffect({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 6) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      animationProgress,\n      dimensions: [width, height],\n      parameters: [radius],\n    }) => {\n      const expanding = animationProgress < 0.5;\n      return {\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\n        centerX: width / 2,\n        centerY: height / 2,\n      };\n    },\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { adjustSaturation } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nconst MAX_GRID_SIZE = 64;\n\nexport const grid = buildEffect({\n  name: 'Grid',\n  description: 'Removes the color from all pixels not aligned with a grid',\n  params: [\n    sliderParam({\n      name: 'Grid Size',\n      description: 'The length of each square in the grid',\n      defaultValue: 24,\n      min: 2,\n      max: MAX_GRID_SIZE,\n      step: 2,\n    }),\n    sliderParam({\n      name: 'Grid Angle',\n      defaultValue: 45,\n      min: 0,\n      max: 90,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    let isOnGrid = false;\n    if (gridAngle % 90 === 0) {\n      // Vertical/Horizonal lines\n      isOnGrid = x % gridSize === 0 || y % gridSize === 0;\n    } else {\n      // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\n      // Larger threshold = thicker lines.\n      const threshold =\n        ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\n\n      const onGrid = (angleDegrees: number) => {\n        const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\n        return Math.abs(Math.round(n) - n) < threshold;\n      };\n\n      isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\n    }\n\n    return isOnGrid ? p : adjustSaturation(p, -100);\n  }),\n});\n\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueChange = buildEffect({\n  name: 'Hue Change',\n  description: 'Change the hue of each pixel towards some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftTowardsHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildEffect({\n  name: 'Hue Shift',\n  description: 'Shift the hue of each pixel in the image by some amount',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How much to shift the hue of each pixel',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [amount] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            hueRotate: amount * 3.6,\n          }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShiftPulse = buildEffect({\n  name: 'Hue Shift Pulse',\n  description: 'Shift the hue to the given value in a pulsating manner',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, frameCount, frameIndex, parameters: [hue] }) => {\n      const amount = Math.abs(Math.sin(Math.PI * (frameIndex / frameCount)));\n      return shiftTowardsHue(getSrcPixel(coord), hue, amount * 360);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftHue } from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueWave = buildEffect({\n  name: 'Hue Wave',\n  description: 'Shifts the hue of pixels in the image in a wave motion',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the hue shift effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many waves you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: -1 * animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord,\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const [, y] = coord;\n      const amount = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return shiftHue(getSrcPixel(coord), (amount / 100) * 360);\n    }\n  ),\n});\n","import seedrandom from 'seedrandom';\nimport { buildEffect, Color } from '../domain/types';\nimport { isTransparent } from '../domain/utils/color';\nimport {\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils/image';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildEffect({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [seed] }) => {\n    const random = seedrandom(seed);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyTransform } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\n\nexport const mirror = buildEffect({\n  name: 'Mirror',\n  description: 'Mirrors the image',\n  params: [],\n  fn: ({ image }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyTransform(canvasData, {\n            horizontalScale: -1,\n            horizontalTranslation: image.dimensions[0],\n          }),\n      })\n    ),\n});\n","import * as convert from 'color-convert';\nimport { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils/image';\n\nexport const nuke = buildEffect({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const threshold = animationProgress * 100;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const opacity = buildEffect({\n  name: 'Opacity',\n  description: 'Sets the opacity of the image',\n  secondaryDescription:\n    'Because gifs do not support transparency, ' +\n    'the preview below will not reflect the transparency accurately. ' +\n    'It will apply to subsequent effects though.',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      defaultValue: 50,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [amount] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyFilter(canvasData, { opacity: amount }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildEffect({\n  name: 'Party',\n  description: 'Shift the hue of the image over the course of the animation',\n  params: [\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [speed] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) =>\n          applyFilter(canvasData, {\n            hueRotate: (frameIndex / frameCount) * 360 * speed,\n          }),\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const partyBackground = buildEffect({\n  name: 'Party Background',\n  description:\n    'Smoothly cycles through background colors over the course of the animation',\n  params: [\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [shiftSpeed, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n      const bgColor = colorFromHue(newH);\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background: mapCoords(image.dimensions, () => bgColor),\n        foreground,\n      });\n    }),\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftHue } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\n\nexport const partyHarder = buildEffect({\n  name: 'Party Harder',\n  description:\n    'Shift the hue of each individual pixel over the course of the animation',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) =>\n    shiftHue(getSrcPixel(coord), animationProgress * 360)\n  ),\n});\n","import { Color, Dimensions, FrameData, buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyFilter } from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const partyShadow = buildEffect({\n  name: 'Party Shadow',\n  description: 'Apply a party shadow effect',\n  params: [\n    sliderParam({\n      name: 'Layers',\n      defaultValue: 4,\n      min: 1,\n      max: 30,\n    }),\n    sliderParam({\n      name: 'Blur Radius',\n      min: 0,\n      max: 30,\n      step: 1,\n      defaultValue: 2,\n    }),\n    intParam({\n      name: 'Offset X',\n      defaultValue: 10,\n    }),\n    intParam({\n      name: 'Offset Y',\n      defaultValue: 10,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [layers, blurRadius, offsetX, offsetY] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const colors: Color[] = [];\n      const startHue = animationProgress * 360;\n      const hueSize = 360 / layers;\n      for (let i = 0; i < layers; i += 1) {\n        colors.push(colorFromHue((startHue - hueSize * i) % 360));\n      }\n\n      return applyShadows({\n        frame,\n        colors,\n        blurRadius,\n        dimensions: image.dimensions,\n        offsetX,\n        offsetY,\n      });\n    }),\n});\n\nconst applyShadows = ({\n  frame,\n  dimensions,\n  colors,\n  offsetX,\n  offsetY,\n  blurRadius,\n}: {\n  frame: FrameData;\n  dimensions: Dimensions;\n  colors: Color[];\n  offsetX: number;\n  offsetY: number;\n  blurRadius: number;\n}): FrameData => {\n  const [color, ...rest] = colors;\n  const newFrame = applyCanvasFromFrame({\n    dimensions,\n    frame,\n    preEffect: (canvasData) =>\n      applyFilter(canvasData, {\n        dropShadow: {\n          offsetX,\n          offsetY,\n          blurRadius,\n          color,\n        },\n      }),\n  });\n\n  if (rest.length === 0) {\n    return newFrame;\n  } else {\n    // Apply it recursively but with more offset\n    return applyShadows({\n      frame: newFrame,\n      colors: rest,\n      dimensions,\n      blurRadius,\n      offsetX,\n      offsetY,\n    });\n  }\n};\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { calculateAngle } from '../domain/utils/misc';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheelColors = buildEffect({\n  name: 'Pinwheel Colors',\n  description: 'Create a background pinwheel of colors of your choosing',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\n  }) => {\n    const [width, height] = image.dimensions;\n\n    const ribbonCount = colors.length * groupCount;\n    const ribbonArcDegrees = Math.round(360 / ribbonCount);\n    // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n    //  won't get a smooth transition.\n    // We'll cut off colors from the end of the list until we get an even multiple.\n    let colorsLength = colors.length;\n    while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n      colorsLength -= 1;\n    }\n\n    const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n\n      const background = mapCoords(image.dimensions, (coord) => {\n        const pointAngle = calculateAngle(coord, center);\n\n        const colorIdx =\n          Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n        // Increment colorIdx based on current frame progress\n        const idx =\n          (Math.floor(animationProgress * colorsLength) + colorIdx) %\n          colorsLength;\n        return colors[idx];\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    });\n  },\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { calculateAngle } from '../domain/utils/misc';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelRainbow = buildEffect({\n  name: 'Pinwheel Rainbow',\n  description: 'Make the image look like a pinwheel rainbow',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    sliderParam({\n      name: 'Strength',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      parameters: [groupCount, amount, offsetX, offsetY],\n    }) => {\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n      return { center };\n    },\n    ({\n      computed: { center },\n      coord,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, strength],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const pointAngle = calculateAngle(coord, center);\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n\n      return shiftTowardsHue(srcPixel, newH, strength);\n    }\n  ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { calculateAngle } from '../domain/utils/misc';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelRainbowBackground = buildEffect({\n  name: 'Pinwheel Rainbow Background',\n  description: 'Create a background pinwheel of rainbow colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n\n      const background = mapCoords(image.dimensions, (coord) => {\n        const pointAngle = calculateAngle(coord, center);\n        const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n        return colorFromHue(newH);\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    }),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { fromHexColor } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radianceColors = buildEffect({\n  name: 'Radiance Colors',\n  description: 'Radiate background colors of your choosing out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n          defaultValue: DEFAULT_COLORS[0],\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [groupCount, colors, offsetX, offsetY, opacity],\n  }) => {\n    return mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n\n      const colorList = range(0, groupCount).flatMap(() => colors);\n      const centerX = width / 2;\n      const centerY = height / 2;\n\n      const background = mapCoords(image.dimensions, ([x, y]) => {\n        const xRelCenter = x - centerX - offsetX;\n        const yRelCenter = y - centerY + offsetY;\n\n        const maxDist = Math.sqrt(\n          (width / 2) * (width / 2) + (height / 2) * (height / 2)\n        );\n        const distFromCenter = Math.sqrt(\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\n        );\n\n        const colorIdx =\n          Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n          colorList.length;\n\n        // Increment colorIdx based on current frame progress\n        const idx =\n          (Math.floor(animationProgress * colorList.length) + colorIdx) %\n          colorList.length;\n        return colorList[idx];\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    });\n  },\n});\n","import { buildEffect } from '../domain/types';\nimport { shiftTowardsHue } from '../domain/utils/color';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceRainbow = buildEffect({\n  name: 'Radiance Rainbow',\n  description: 'Radiate rainbow colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    sliderParam({\n      name: 'Strength',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height] }) => ({\n      centerX: width / 2,\n      centerY: height / 2,\n      maxDist: Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      ),\n    }),\n    ({\n      computed: { centerX, centerY, maxDist },\n      coord,\n      animationProgress,\n      parameters: [groupCount, strength, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const newH =\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\n          360 * animationProgress) %\n        360;\n\n      return shiftTowardsHue(src, newH, strength);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport {\n  applyCanvasFromFrame,\n  applyFilter,\n  combineImages,\n} from '../domain/utils/canvas';\nimport { colorFromHue } from '../domain/utils/color';\nimport { mapCoords, mapFrames } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceRainbowBackground = buildEffect({\n  name: 'Radiance Rainbow Background',\n  description: 'Radiate rainbow colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Foreground Opacity',\n      defaultValue: 100,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [groupCount, offsetX, offsetY, opacity] }) =>\n    mapFrames(image, (frame, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const [width, height] = image.dimensions;\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const maxDist = Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      );\n\n      const background = mapCoords(image.dimensions, ([x, y]) => {\n        const xRelCenter = x - centerX - offsetX;\n        const yRelCenter = y - centerY + offsetY;\n\n        const distFromCenter = Math.sqrt(\n          yRelCenter * yRelCenter + xRelCenter * xRelCenter\n        );\n\n        const newH =\n          ((1 - distFromCenter / maxDist) * 360 * groupCount +\n            360 * animationProgress) %\n          360;\n\n        return colorFromHue(newH);\n      });\n\n      const foreground =\n        opacity === 100\n          ? frame\n          : applyCanvasFromFrame({\n              dimensions: image.dimensions,\n              frame,\n              preEffect: (canvasData) => applyFilter(canvasData, { opacity }),\n            });\n\n      return combineImages({\n        dimensions: image.dimensions,\n        background,\n        foreground,\n      });\n    }),\n});\n","import { minBy, sortBy } from 'remeda';\nimport { buildEffect, Color } from '../domain/types';\nimport {\n  toHexColor,\n  TRANSPARENT_COLOR,\n  fromHexColor,\n  colorDiff,\n} from '../domain/utils/color';\nimport {\n  mapImageWithPrecompute,\n  mapFrames,\n  mapCoords,\n  getPixelFromSource,\n} from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const reduceColorPalette = buildEffect({\n  name: 'Reduce Color Palette',\n  description:\n    'Reduce the number of unique colors in the gif, to reduce the file size.',\n  secondaryDescription:\n    'This can be a slow operation depending on the number of final colors',\n  params: [\n    sliderParam({\n      name: 'Percent Reduction',\n      description:\n        '0% will have no effect, 100% will result in just one unique color in the result',\n      defaultValue: 70,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ image, parameters: [percentReduction] }) => {\n      // Buid up a set of all unique colors.\n      // These will be our data points that we're going to group into to N clusters\n      const allColorsSet = new Set<string>();\n      mapFrames(image, (frame) =>\n        mapCoords(image.dimensions, (coord) => {\n          const px = getPixelFromSource(image.dimensions, frame, coord);\n          allColorsSet.add(toHexColor(px));\n          return TRANSPARENT_COLOR; // Not actually used, just makes TS happy\n        })\n      );\n\n      const allColors = Array.from(allColorsSet).map(fromHexColor);\n      const numColors = Math.max(\n        Math.floor((allColors.length * (100 - percentReduction)) / 100),\n        1\n      );\n\n      // Create a mapping of each unique color to the list of colors are the closest to it.\n      // We'll then pick the top N colors.\n      // Lastly, we'll replace every pixel with the color that it reduces to.\n\n      // colorMap[i].numClosestColors is the number of colors closest to allColors[i]\n      const colorMap: { color: Color; numClosestColors: number }[] =\n        allColors.map((c) => ({\n          color: c,\n          numClosestColors: 0,\n        }));\n\n      for (let i = 1; i < allColors.length; i += 1) {\n        let closestColorIdx = 0;\n        let closetsColorDist = colorDiff(\n          allColors[i],\n          allColors[closestColorIdx]\n        );\n        // Find the other color that is closest to this one\n        for (let k = 0; k < allColors.length; k += 1) {\n          if (k === i) {\n            // Don't check the distance between this color and itself\n            continue;\n          }\n          const dist = colorDiff(allColors[k], allColors[i]);\n          if (dist < closetsColorDist) {\n            closestColorIdx = k;\n            closetsColorDist = dist;\n          }\n        }\n        colorMap[closestColorIdx].numClosestColors += 1;\n      }\n\n      const colorPalette = sortBy(colorMap, [(c) => c.numClosestColors, 'desc'])\n        .slice(0, numColors)\n        .map(({ color }) => color);\n\n      return { colorPalette };\n    },\n    ({ coord, getSrcPixel, computed: { colorPalette } }) => {\n      const px = getSrcPixel(coord);\n      // Find the color in the palette this one is closest to\n      const closestColor = minBy(colorPalette, (top) => colorDiff(top, px))!;\n      return closestColor;\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const repeatAnimation = buildEffect({\n  name: 'Repeat Animation',\n  description: 'Repeats the current animation some number of times',\n  secondaryDescription: 'This can greatly increase the final file size!',\n  params: [\n    sliderParam({\n      name: 'Number of Repeats',\n      defaultValue: 1,\n      min: 1,\n      max: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [numRepeats] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\n      (i) => image.frames[i % image.frames.length]\n    ),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildEffect({\n  name: 'Resize Image',\n  description: 'Change the absolute dimensions of the image.',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\n      defaultValue: (image) => (image ? image.dimensions[0] : 0),\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\n      defaultValue: (image) => (image ? image.dimensions[1] : 0),\n      min: 0,\n    }),\n    checkboxParam({\n      name: 'Keep scale',\n      description:\n        'If checked, the image will be stretched to fit the new dimensions',\n      defaultValue: false,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight, keepScale] }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n    const newWidth =\n      resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n    return resizeImageUtil({\n      image,\n      newWidth,\n      newHeight,\n      keepScale,\n    });\n  },\n});\n","import { reverse } from 'remeda';\nimport { buildEffect } from '../domain/types';\n\nexport const reverseAnimation = buildEffect({\n  name: 'Reverse Animation',\n  description: 'Reverses the animation',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: reverse(image.frames),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const ripple = buildEffect({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    sliderParam({\n      name: 'Amplitude',\n      defaultValue: 20,\n      min: 0,\n      max: 100,\n      step: 5,\n      description: 'How strong the ripple effect should be',\n    }),\n    sliderParam({\n      name: 'Period',\n      defaultValue: 1,\n      min: 1,\n      max: 20,\n      description: 'How many ripples you want',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord: [x, y],\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const offset = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return getSrcPixel([x + offset, y]);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyRotation } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const rotate = buildEffect({\n  name: 'Rotate',\n  description: 'Rotes the image to a given angle',\n  params: [\n    sliderParam({\n      name: 'Angle',\n      defaultValue: 0,\n      min: 0,\n      max: 360,\n      step: 5,\n      description:\n        'The angle in degrees. 0 degrees points to the right, 90 degrees points up.',\n    }),\n  ],\n  fn: ({ image, parameters: [angle] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyRotation(canvasData, angle),\n      })\n    ),\n});\n","import { buildEffect, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\n\nexport const roxbury = buildEffect({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], animationProgress }) => {\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(animationProgress * 4);\n      const phaseIdx = (animationProgress - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      return {\n        angle,\n        cos: Math.cos(-angle * 1.35),\n        sin: Math.sin(-angle * 1.35),\n        rotatePointX: width * 0.25,\n        rotatePointY: height * 0.7,\n      };\n    },\n    ({\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n      const newCoord: Coord = [\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { scaleImage as scaleImageUtil } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const scaleImage = buildEffect({\n  name: 'Scale Image',\n  description: 'Scale the image without changing the dimensions',\n  params: [\n    sliderParam({\n      name: 'Scale',\n      min: 0.1,\n      max: 3,\n      step: 0.1,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [scale] }) =>\n    scaleImageUtil({ image, horizontalScale: scale, verticalScale: scale }),\n});\n","import { buildEffect } from '../domain/types';\nimport { changeFrameCount } from '../domain/utils/image';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const setAnimationLength = buildEffect({\n  name: 'Set Animation Length',\n  description: 'Change the length of the animation.',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description: 'Set how many frames of animation there will be.',\n      defaultValue: (image) => (image ? image.frames.length : 1),\n      min: 1,\n      max: 60,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [frameCount] }) =>\n    changeFrameCount(image, frameCount),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils/image';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildEffect({\n  name: 'Shake',\n  description: 'Make the image shake left and right',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: (image) =>\n        image ? Math.floor(image.dimensions[0] / 10) : 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: Math.round(\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\n      ),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y])\n  ),\n});\n","import { range } from 'remeda';\nimport { buildEffect } from '../domain/types';\nimport { getPixelFromSource, mapCoords } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\n\nexport const slowAnimation = buildEffect({\n  name: 'Slow Animation',\n  description: 'Attempts to slow the animation by adding intermediate frames',\n  secondaryDescription: 'This will make the final filze size larger',\n  params: [\n    radioParam<'basic' | 'smooth'>({\n      name: 'Interpolation Type',\n      options: [\n        { name: 'Basic', value: 'basic' },\n        { name: 'Smooth', value: 'smooth' },\n      ],\n      defaultValue: 'basic',\n      description:\n        'With basic interpolation, frames are simply duplicated. ' +\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\n    }),\n  ],\n  fn: ({ image, parameters: [type] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\n\n      // Even numbered frames are just the original frames\n      if (i % 2 === 0) {\n        return image.frames[i / 2];\n      }\n\n      const ogFrameIdx = (i - 1) / 2;\n\n      if (type === 'basic') {\n        // Intermediate frame is simply the previous OG frame\n        return image.frames[ogFrameIdx];\n      }\n\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\n      return mapCoords(image.dimensions, (coord) => {\n        const [r1, g1, b1, a1] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx],\n          coord\n        );\n        const [r2, g2, b2, a2] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx + 1],\n          coord\n        );\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\n      });\n    }),\n  }),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame, applyRotation } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\n\nexport const spin = buildEffect({\n  name: 'Spin',\n  description: 'Make the image rotate about the center point in an animation',\n  params: [\n    radioParam<'clockwise' | 'counter'>({\n      name: 'Direction',\n      defaultValue: 'clockwise',\n      options: [\n        { name: 'Clockwise', value: 'clockwise' },\n        { name: 'Counter-Clockwise', value: 'counter' },\n      ],\n    }),\n  ] as const,\n  fn: ({ image, parameters: [direction] }) =>\n    mapFrames(image, (frame, idx, frameCount) => {\n      const angle =\n        (((direction === 'counter' ? 1 : -1) * idx) / frameCount) * 360;\n      return applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        preEffect: (canvasData) => applyRotation(canvasData, angle),\n      });\n    }),\n});\n","import { buildEffect } from '../domain/types';\nimport { isTransparent } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildEffect({\n  name: 'Static',\n  description: 'Adds random static to each frame the image',\n  params: [\n    radioParam<'background' | 'foreground'>({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      if (isBackground && type === 'background') {\n        const inverse = Math.ceil(random() * 100) < strength;\n        const grey = Math.ceil(random() * 255);\n\n        return inverse ? [grey, grey, grey, 255] : src;\n      }\n\n      const isStatic = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return isStatic ? [grey, grey, grey, src[3]] : src;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { applyCanvasFromFrame } from '../domain/utils/canvas';\nimport { fromHexColor, toHexColor } from '../domain/utils/color';\nimport { mapFrames } from '../domain/utils/image';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { dropdownParam } from '../params/dropdownParam';\nimport { intParam } from '../params/intParam';\nimport { textParam } from '../params/textParam';\n\nconst FONTS = [\n  'Arial',\n  'Verdana',\n  'Tahoma',\n  'Trebuchet MS',\n  'Times New Roman',\n  'Georgia',\n  'Garamond',\n  'Courier New',\n  'Brush Script MT',\n];\n\nexport const text = buildEffect({\n  name: 'Text',\n  description: 'Puts text on the image',\n  params: [\n    textParam({\n      name: 'Text',\n      description: 'The text to put on the image',\n      defaultValue: '',\n    }),\n    dropdownParam({\n      name: 'Font',\n      defaultValue: FONTS[0],\n      options: FONTS.map((font) => ({ name: font, value: font })),\n    }),\n    intParam({\n      name: 'X',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Y',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Size',\n      defaultValue: 12,\n      min: 8,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ] as const,\n  fn: ({ image, parameters: [text, font, x, y, fontSize, color] }) =>\n    mapFrames(image, (frame) =>\n      applyCanvasFromFrame({\n        dimensions: image.dimensions,\n        frame,\n        postEffect: ({ ctx }) => {\n          ctx.font = `${fontSize}px ${font}`;\n          ctx.fillStyle = toHexColor(color);\n          ctx.fillText(text, x, y);\n        },\n      })\n    ),\n});\n","import { buildEffect } from '../domain/types';\nimport { fromHexColor, colorDiff } from '../domain/utils/color';\nimport { mapImage } from '../domain/utils/image';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparency = buildEffect({\n  name: 'Transparency',\n  description: 'Set certain pixels to be transparent',\n  params: [\n    checkboxParam({\n      name: 'Matches are Transparent',\n      description:\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\n      defaultValue: true,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      parameters: [matchesTransparent, selectedColor, tolerance],\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const withinTolerance = colorDiff(src, selectedColor) * 100 <= tolerance;\n\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\n        return [src[0], src[1], src[2], 0];\n      }\n      return src;\n    }\n  ),\n});\n","import { buildEffect } from '../domain/types';\nimport { mapImage } from '../domain/utils/image';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildEffect({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ] as const,\n  fn: mapImage(({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\n    getSrcPixel([x + transX, y + transY])\n  ),\n});\n","import { pipe, reject, sortBy } from 'remeda';\nimport { ParamFunction, Effect } from '../domain/types';\nimport { assert } from '../domain/utils/misc';\n\nimport { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { blur } from './blur';\nimport { bounce } from './bounce';\nimport { bounceAnimation } from './bounce-animation';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { dropShadow } from './drop-shadow';\nimport { expand } from './expand';\nimport { fade } from './fade';\nimport { fill } from './fill';\nimport { fisheye } from './fisheye';\nimport { grid } from './grid';\nimport { hueChange } from './hue-change';\nimport { hueShift } from './hue-shift';\nimport { hueShiftPulse } from './hue-shift-pulse';\nimport { hueWave } from './hue-wave';\nimport { lightning } from './lightning';\nimport { mirror } from './mirror';\nimport { nuke } from './nuke';\nimport { opacity } from './opacity';\nimport { party } from './party';\nimport { partyBackground } from './party-background';\nimport { partyHarder } from './party-harder';\nimport { partyShadow } from './party-shadow';\nimport { pinwheelColors } from './pinwheel-colors';\nimport { pinwheelRainbow } from './pinwheel-rainbow';\nimport { pinwheelRainbowBackground } from './pinwheel-rainbow-background';\nimport { radianceColors } from './radiance-colors';\nimport { radianceRainbow } from './radiance-rainbow';\nimport { radianceRainbowBackground } from './radiance-rainbow-background';\nimport { reduceColorPalette } from './reduce-color-palette';\nimport { repeatAnimation } from './repeat-animation';\nimport { resizeImage } from './resize-image';\nimport { reverseAnimation } from './reverse-animation';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { scaleImage } from './scale-image';\nimport { setAnimationLength } from './set-animation-length';\nimport { shake } from './shake';\nimport { slowAnimation } from './slow-animation';\nimport { spin } from './spin';\nimport { staticc } from './static';\nimport { text } from './text';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nconst otherEffects = pipe(\n  [\n    backgroundColor,\n    backgroundImage,\n    blur,\n    bounce,\n    bounceAnimation,\n    circle,\n    colors,\n    colorsBackground,\n    doubleVision,\n    dropShadow,\n    expand,\n    fade,\n    fill,\n    fisheye,\n    grid,\n    hueChange,\n    hueShift,\n    hueShiftPulse,\n    hueWave,\n    lightning,\n    mirror,\n    nuke,\n    opacity,\n    party,\n    partyBackground,\n    partyHarder,\n    partyShadow,\n    pinwheelColors,\n    pinwheelRainbow,\n    pinwheelRainbowBackground,\n    radianceColors,\n    radianceRainbow,\n    radianceRainbowBackground,\n    reduceColorPalette,\n    repeatAnimation,\n    resizeImage,\n    reverseAnimation,\n    ripple,\n    rotate,\n    roxbury,\n    scaleImage,\n    shake,\n    slowAnimation,\n    spin,\n    staticc,\n    text,\n    transparency,\n    transpose,\n  ],\n  sortBy((x) => x.name),\n  reject((x) => x.disabled)\n);\n\nexport const POSSIBLE_EFFECTS = [\n  // The first one is the one that is automatically selected, so make sure this is at the top of the list\n  setAnimationLength,\n  adjustImage,\n  ...otherEffects,\n];\n\nexport const effectByName = (\n  name: string\n): Effect<readonly ParamFunction<any>[]> => {\n  const t = POSSIBLE_EFFECTS.find((t) => t.name === name);\n  assert(t, `Could not find matching effect: ${name}`);\n  return t as any as Effect<readonly ParamFunction<any>[]>;\n};\n","import { buildEffect } from '../domain/types';\nimport { combineImages, createCanvas } from '../domain/utils/canvas';\nimport { mapFrames } from '../domain/utils/image';\n\n// NOTE: This is not intended as an end-user effect!\n// This is just to display behind a picture when there are partially-transparent pixels,\n//  as GIFs do not support partial transparency.\n\nconst COLORS = ['#111111', '#888888'];\n\nexport const fakeTransparency = buildEffect({\n  name: 'Fake Transparency',\n  description:\n    'This is just to display behind a picture when there are partially-transparent pixels,' +\n    ' as GIFs do not support partial transparency',\n  params: [] as const,\n  fn: ({ image }) => {\n    const createBackground = () => {\n      const canvas = createCanvas(image.dimensions);\n      const ctx = canvas.ctx;\n\n      const numBlocks = 10;\n      const blockWidth = image.dimensions[0] / numBlocks;\n      const blockHeight = image.dimensions[1] / numBlocks;\n      for (let i = 0; i < numBlocks; i += 1) {\n        for (let j = 0; j < numBlocks; j += 1) {\n          ctx.fillStyle = COLORS[(i + j) % 2];\n          ctx.fillRect(\n            i * blockWidth,\n            j * blockHeight,\n            (i + 1) * blockWidth,\n            (j + 1) * blockHeight\n          );\n        }\n      }\n      return canvas;\n    };\n\n    return mapFrames(image, (imageData) =>\n      combineImages({\n        dimensions: image.dimensions,\n        background: createBackground(),\n        foreground: imageData,\n      })\n    );\n  },\n});\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\nimport { effectByName } from '../effects';\nimport {\n  Color,\n  Image,\n  FrameData,\n  ImageEffectResult,\n  EffectInput,\n} from './types';\nimport {\n  fromHexColor,\n  isPartiallyTransparent,\n  isTransparent,\n  randomColor,\n  toHexColor,\n} from './utils/color';\nimport { getPixelFromSource } from './utils/image';\nimport { fakeTransparency } from '../effects/fake-transparency';\n\nexport interface RunArgs {\n  randomSeed: string;\n  image: Image;\n  effectInput: EffectInput;\n  fps: number;\n}\n\n// Returns a list of gif data URLs, for each effect\nexport const runEffects = async ({\n  image,\n  effectInput,\n  randomSeed,\n  fps,\n}: RunArgs): Promise<ImageEffectResult> => {\n  const random = seedrandom(randomSeed);\n\n  const effect = effectByName(effectInput.effectName);\n  const result = await effect.fn({\n    image,\n    parameters: effectInput.params,\n    random,\n  });\n\n  const { transparentColor, hasPartialTransparency } = getTransparentColor(\n    result,\n    random\n  );\n\n  const gif = await createGif({\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    image: encodeTransparency(result, transparentColor),\n    transparentColor,\n    fps,\n  });\n\n  const resultWithBG = hasPartialTransparency\n    ? await fakeTransparency.fn({\n        image: result,\n        parameters: [],\n        random,\n      })\n    : null;\n\n  return {\n    gif,\n    image: result,\n    gifWithBackgroundColor: resultWithBG\n      ? await createGif({\n          image: resultWithBG,\n          transparentColor: undefined,\n          fps,\n        })\n      : gif,\n    partiallyTransparent: hasPartialTransparency,\n  };\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  image: Image,\n  transparentColor: Color | undefined\n): Image => {\n  const newFrames = image.frames.map((frame) => {\n    const img = new Uint8ClampedArray(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = 0;\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 0; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return {\n    dimensions: image.dimensions,\n    frames: newFrames,\n  };\n};\n\nconst createGif = async ({\n  image,\n  transparentColor,\n  fps,\n}: {\n  image: Image;\n  transparentColor: Color | undefined;\n  fps: number;\n}): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = image.dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', async () => {\n      const blob = new Blob(data, { type: 'image/gif' });\n      const dataUrl = await blobOrFileToDataUrl(blob);\n      resolve(dataUrl);\n    });\n\n    image.frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: FrameData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          const [width, height] = results.shape;\n          // Single frame\n          return res({\n            frames: [Uint8ClampedArray.from(results.data)],\n            dimensions: [width, height],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8ClampedArray[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          const frame = results.data.subarray(\n            i * sliceSize,\n            (i + 1) * sliceSize\n          );\n          // Contrary to the TS types, the result of subarray returns a regular Uint8Array, NOT a clamped one!\n          frames.push(Uint8ClampedArray.from(frame));\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): {\n  transparentColor: Color | undefined;\n  hasPartialTransparency: boolean;\n} => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let hasPartialTransparency = false;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isPartiallyTransparent(px)) {\n          hasPartialTransparency = true;\n        }\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return {\n    transparentColor: hasTransparent ? fromHexColor(attempt) : undefined,\n    hasPartialTransparency,\n  };\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n\nexport const blobOrFileToDataUrl = (file: File | Blob) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import React from 'react';\nimport { Dimensions } from '../domain/types';\n\nconst MAX_SIZE = 220;\n\nexport interface GifProps {\n  src: string;\n  alt: string;\n  dimensions?: Dimensions;\n}\n\n/**\n * Returns a size that will make the image at most 300px width or tall,\n *  while preserving the aspect ratio.\n */\nconst calculateDimensions = (\n  dimensions: GifProps['dimensions']\n): { maxWidth: string; maxHeight: string } => {\n  if (dimensions == null) {\n    // TODO This happens in image picker, where we don't have a parsed image.\n    // We can probably parse the image in the image picker instead of just using a URL.\n    return { maxWidth: `${MAX_SIZE}px`, maxHeight: `${MAX_SIZE}px` };\n  }\n\n  const [width, height] = dimensions;\n  const aspectRatio = height / width;\n  if (width > height) {\n    const maxWidth = MAX_SIZE;\n    const maxHeight = aspectRatio * MAX_SIZE;\n    // If width is bigger, then limit by width\n    return { maxWidth: `${maxWidth}px`, maxHeight: `${maxHeight}px` };\n  } else {\n    // Else, limit by height\n    const maxHeight = MAX_SIZE;\n    const maxWidth = (1 / aspectRatio) * MAX_SIZE;\n    return { maxHeight: `${maxHeight}px`, maxWidth: `${maxWidth}px` };\n  }\n};\n\nexport const Gif: React.FC<GifProps> = ({ src, alt, dimensions }) => (\n  <img\n    src={src}\n    alt={`gif-${alt}`}\n    style={calculateDimensions(dimensions)}\n  ></img>\n);\n","import { Button, Icon, Stack, Box, TextField } from '@material-ui/core';\nimport React from 'react';\nimport { getImageFromUrl } from '../domain/importImageFromUrl';\nimport { blobOrFileToDataUrl, readImage } from '../domain/run';\nimport { ImageEffectResult } from '../domain/types';\nimport { isUrl } from '../domain/utils/misc';\nimport { isPartiallyTransparent } from '../domain/utils/image';\nimport { Gif } from './Gif';\n\nconst parseFileName = (s: string): string => {\n  const parts = s.split('/'); // For URLs\n  const name = parts[parts.length - 1];\n  // Now remove file extension\n  const nameParts = name.split('.');\n  if (nameParts.length === 1) {\n    return nameParts[0];\n  }\n  return nameParts.slice(0, nameParts.length - 1).join('.');\n};\n\ninterface ImagePickerProps {\n  currentImage?: ImageEffectResult;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (image: ImageEffectResult, fileName: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImage,\n  onChange,\n}) => {\n  const [error, setError] = React.useState<string | undefined>();\n  return (\n    <Stack spacing={2}>\n      <Stack direction=\"row\">\n        <TextField\n          label=\"URL\"\n          variant=\"outlined\"\n          fullWidth\n          error={!!error}\n          helperText={error ?? 'Only supports static images'}\n          onBlur={async (e) => {\n            const text = e.target.value;\n            try {\n              setError(undefined);\n\n              if (text.startsWith('data:')) {\n                // Data URL\n                const image = await readImage(text);\n                onChange(\n                  {\n                    gif: text,\n                    image,\n                    gifWithBackgroundColor: text,\n                    partiallyTransparent: isPartiallyTransparent(image),\n                  },\n                  'image'\n                );\n                return;\n              }\n\n              if (!isUrl(text)) {\n                return;\n              }\n              const gif = await getImageFromUrl(text);\n              const image = await readImage(gif);\n              onChange(\n                {\n                  gif,\n                  image,\n                  gifWithBackgroundColor: gif,\n                  partiallyTransparent: isPartiallyTransparent(image),\n                },\n                parseFileName(text)\n              );\n            } catch {\n              setError('Error importing url');\n            }\n          }}\n        />\n      </Stack>\n      <Box>OR</Box>\n      <Button\n        startIcon={<Icon>image</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        component=\"label\"\n      >\n        Upload an Image\n        <input\n          type=\"file\"\n          hidden\n          accept=\"image/png,image/jpg,image/jpeg,image/gif\"\n          name=\"source-png\"\n          onChange={async (event) => {\n            const files = Array.from(event.target.files ?? []);\n            const file = files[0];\n            if (file) {\n              // Will be undefined if user clicked the cancel button\n              const gif = await blobOrFileToDataUrl(file);\n              const image = await readImage(gif);\n              onChange(\n                {\n                  gif,\n                  image,\n                  gifWithBackgroundColor: gif,\n                  partiallyTransparent: isPartiallyTransparent(image),\n                },\n                parseFileName(file.name)\n              );\n            }\n          }}\n        />\n      </Button>\n      {currentImage && (\n        <Gif\n          src={currentImage.gif}\n          dimensions={currentImage.image.dimensions}\n          alt=\"Source\"\n        />\n      )}\n    </Stack>\n  );\n};\n","// DO NOT IMPORT THIS FILE FROM A WEB WORKER\n// Web workers do not have access to `window`\n\nimport MobileDetect from 'mobile-detect';\n\nexport const IS_MOBILE =\n  new MobileDetect(window.navigator.userAgent).mobile() != null;\n\nexport const ENV = (window as any).ENV as 'DEV' | 'PROD';\n\nexport const debugLog = ENV === 'DEV' ? console.log : () => undefined;\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/effect.worker.84a819cd.worker.js\");\n}\n","import { RunArgs } from './run';\n// @ts-ignore\nimport RunEffectWorker from './effect.worker';\nimport { AsyncRunMessage, ImageEffectResult } from './types';\n\ninterface Computation {\n  resolve: (result: ImageEffectResult) => void;\n  reject: (err: any) => void;\n}\n\n// The order of computations is not guaranteed, so add each computation to a map\nconst computationMap = new Map<string, Computation>();\n\nconst handleError = (computationId: string) => (error: any) => {\n  const computation = computationMap.get(computationId);\n  if (!computation) {\n    return;\n  }\n  computation.reject(error);\n  computationMap.delete(computationId);\n};\n\nconst handleSuccess = (computationId: string, result: ImageEffectResult) => {\n  const computation = computationMap.get(computationId);\n  if (!computation) {\n    return;\n  }\n  computation.resolve(result);\n  computationMap.delete(computationId);\n};\n\nexport const runEffectsAsync = (args: RunArgs) =>\n  new Promise<ImageEffectResult>((resolve, reject) => {\n    const worker = new RunEffectWorker();\n\n    const computationId = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;\n    computationMap.set(computationId, {\n      resolve,\n      reject,\n    });\n\n    worker.addEventListener('error', handleError(computationId));\n    worker.addEventListener('messageerror', handleError(computationId));\n\n    worker.onmessage = (message: { data: AsyncRunMessage }) => {\n      // See effect.worker.ts for what messages look like\n      const data = message.data;\n      if (data.status === 'complete') {\n        handleSuccess(computationId, data.result);\n      }\n    };\n\n    worker.postMessage(args);\n  });\n","import { runEffects } from './run';\nimport { runEffectsAsync } from './runAsync';\nimport { AppState, Image, ImageEffectResult } from './types';\nimport { ENV, debugLog, IS_MOBILE } from './env';\nimport { assert } from './utils/misc';\n\n// OffscreenCanvas isn't supported by mobile browsers, so mobile will also run synchronously,\n//  which will force us to use regular canvas and not OffscreenCanvas.\n// Also, we can't get web workers working with the dev build, so awalsy use the synchrounous\n//  version if not a prod build.\nexport const computeGif =\n  IS_MOBILE || ENV === 'DEV' ? runEffects : runEffectsAsync;\n\nexport const computeGifsForState = async ({\n  state,\n  startEffectIndex,\n  onCompute,\n}: {\n  state: AppState;\n  startEffectIndex: number;\n  onCompute: (image: ImageEffectResult, idx: number) => void;\n}): Promise<void> => {\n  assert(state.baseImage, 'No source image, this button should be disabled!');\n\n  let image: Image;\n  if (startEffectIndex === 0) {\n    image = state.baseImage.image;\n  } else {\n    const prevEffectState = state.effects[startEffectIndex - 1].state;\n    assert(\n      prevEffectState.status === 'done',\n      'We should not be starting with this effect if the previous is not done computing'\n    );\n    image = prevEffectState.image.image;\n  }\n\n  for (let i = startEffectIndex; i < state.effects.length; i += 1) {\n    const start = Date.now();\n\n    const effect = state.effects[i];\n\n    const result = await computeGif({\n      randomSeed: state.baseImage.gif,\n      image,\n      effectInput: {\n        effectName: effect.effectName,\n        params: effect.paramsValues,\n      },\n      fps: state.fps,\n    });\n\n    // Google analytics\n    ga('send', {\n      hitType: 'timing',\n      timingCategory: 'computeStep',\n      timingVar: effect.effectName,\n      timingValue: Math.ceil((Date.now() - start) / 1000),\n    });\n\n    image = result.image;\n\n    onCompute(result, i);\n  }\n};\n\n/** Get the index of the first effect that differs from curr to prev state */\nexport const getEffectsDiff = ({\n  currState,\n  prevState,\n}: {\n  currState: AppState;\n  prevState: AppState;\n}): { diff: true; index: number } | { diff: false } => {\n  if (\n    currState.fps !== prevState.fps ||\n    currState.baseImage !== prevState.baseImage\n  ) {\n    debugLog('FPS or base image is different');\n    return { diff: true, index: 0 };\n  }\n\n  const currEffects = currState.effects;\n  const prevEffects = prevState.effects;\n\n  // Find the first newEffect that is different from prevEffects\n  for (let i = 0; i < currEffects.length; i += 1) {\n    const currE = currEffects[i];\n    const prevE = prevEffects[i];\n    if (!prevE) {\n      debugLog('No prevE, index ', i);\n      return { diff: true, index: i };\n    }\n\n    if (prevE.state.status !== 'done') {\n      debugLog('PrevE not done ', i);\n      return { diff: true, index: i };\n    }\n\n    if (currE.effectName !== prevE.effectName) {\n      debugLog('Different effect name ', i);\n      return { diff: true, index: i };\n    }\n\n    // Compare the param values\n    for (let ei = 0; ei < currE.paramsValues.length; ei += 1) {\n      const currEParam = currE.paramsValues[ei];\n      const prevEP = prevE.paramsValues[ei];\n      if (JSON.stringify(currEParam) !== JSON.stringify(prevEP)) {\n        debugLog('Param different', i, ei);\n        return { diff: true, index: i };\n      }\n    }\n  }\n\n  debugLog('No diff');\n  return { diff: false };\n};\n","import React from 'react';\nimport { debugLog } from '../domain/env';\nimport { computeGif } from '../domain/computeGifs';\nimport { ImageEffectResult } from '../domain/types';\nimport { RunArgs } from '../domain/run';\n\nconst getRunId = () => Math.floor(Math.random() * 100000);\n\ninterface ContextProps {\n  latestRunIdRef: React.MutableRefObject<number>;\n}\n\nconst ProcessorQueueContext = React.createContext<ContextProps>({\n  latestRunIdRef: null as any, // Will be set immediately in the provider\n});\n\nexport const ProcessorQueueProvider: React.FC = ({ children }) => {\n  const latestRunIdRef = React.useRef(0);\n\n  return (\n    <ProcessorQueueContext.Provider value={{ latestRunIdRef }}>\n      {children}\n    </ProcessorQueueContext.Provider>\n  );\n};\n\n/**\n * Computes an asynchronous, calling the given callback when finished.\n *\n * If a compute is called while an existing one is in progress, then the\n *  result for the previous compute will be thrown away. The callback will\n *  only be called a single time. Think of it like a debounce.\n */\nexport function useProcessingQueue({\n  onComplete,\n  onError,\n}: {\n  onComplete: (results: ImageEffectResult) => void;\n  onError?: (error: Error) => void;\n}) {\n  const { latestRunIdRef } = React.useContext(ProcessorQueueContext);\n\n  const onFinish = React.useCallback(\n    (runId: number, results: ImageEffectResult) => {\n      debugLog('Finished', { runId, latestRunIdRef });\n      if (runId === latestRunIdRef.current) {\n        onComplete(results);\n      } else {\n        // Throw away this result -- it's been superceded by another compute\n        debugLog('Throwing away an old compute');\n      }\n    },\n    [onComplete, latestRunIdRef]\n  );\n\n  return React.useCallback(\n    (args: RunArgs): void => {\n      const runId = getRunId();\n      debugLog('Computing: ', { runId, args });\n      latestRunIdRef.current = runId;\n      computeGif(args)\n        .then((results) => onFinish(runId, results))\n        .catch(onError);\n    },\n    [onError, onFinish, latestRunIdRef]\n  );\n}\n","import { HelpTooltip } from './HelpTooltip';\n\nconst TOOLTIP = [\n  'The resulting image contains partial transparency, which gifs do not handle.',\n  'A fake background has been applied to preview the gif better.',\n].join(' ');\n\nexport const BackgroundPreviewTooltip: React.FC = () => {\n  return <HelpTooltip description={TOOLTIP} />;\n};\n","import React from 'react';\nimport {\n  Autocomplete,\n  Button,\n  CircularProgress,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  Divider,\n  FormControl,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport {\n  ParamFunction,\n  Effect,\n  EffectInput,\n  ImageEffectResult,\n} from '../domain/types';\nimport { replaceIndex } from '../domain/utils/misc';\nimport { debugLog } from '../domain/env';\nimport { effectByName } from '../effects';\nimport { Gif } from './Gif';\nimport { useProcessingQueue } from './useProcessingQueue';\nimport { BackgroundPreviewTooltip } from './BackgroundPreviewTooltip';\n\ninterface Props {\n  open: boolean;\n  initialImage: ImageEffectResult | undefined;\n  currentEffect: EffectInput | undefined;\n  possibleEffects: Effect<any>[];\n  currFps: number;\n  currRandomSeed: string;\n  onChangeEffect: (\n    effect: EffectInput,\n    computedImage: ImageEffectResult | undefined\n  ) => void;\n  onCancel: () => void;\n}\n\nexport const ImageEffectDialog: React.FC<Props> = ({\n  open,\n  initialImage,\n  currentEffect,\n  possibleEffects,\n  currFps,\n  currRandomSeed,\n  onChangeEffect,\n  onCancel,\n}) => {\n  const [image, setImage] = React.useState<\n    { computing: true } | { computing: false; results: ImageEffectResult }\n  >({ computing: true });\n\n  const onImageChange = useProcessingQueue({\n    onComplete: (results) => {\n      setImage({ computing: false, results });\n    },\n  });\n\n  const [initialLoaded, setInitialLoaded] = React.useState(false);\n\n  const [editingEffect, setEditingEffect] = React.useState<\n    EffectInput | undefined\n  >(undefined);\n\n  const [dirty, setDirty] = React.useState(false);\n\n  React.useEffect(() => {\n    if (currentEffect) {\n      setEditingEffect({\n        effectName: currentEffect.effectName,\n        params: [...currentEffect.params], // Make a defensive copy so we can edit the params\n      });\n    }\n  }, [currentEffect]);\n\n  React.useEffect(() => {\n    // Reset state to default values on close\n    if (!open) {\n      setInitialLoaded(false);\n      setEditingEffect(undefined);\n      setImage({ computing: true });\n    }\n  }, [open]);\n\n  React.useEffect(() => {\n    // Set initial loaded image once we have it\n    if (!initialImage) {\n      return;\n    }\n\n    if (!initialLoaded) {\n      debugLog('Initial loading');\n      // The initial loading of the original effect\n      setImage({\n        computing: false,\n        results: initialImage,\n      });\n      setInitialLoaded(true);\n      return;\n    }\n\n    // Just used for setting the initial image, so just change it when the initial image does.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialImage]);\n\n  React.useEffect(() => {\n    if (!initialImage || !editingEffect) {\n      return;\n    }\n\n    setImage({ computing: true });\n    onImageChange({\n      fps: currFps,\n      randomSeed: currRandomSeed,\n      image: initialImage.image,\n      effectInput: editingEffect,\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [initialImage, editingEffect, currFps, currRandomSeed]);\n\n  const closeDialog = ({ save }: { save: boolean }) => {\n    if (!save || !editingEffect) {\n      onCancel();\n      return;\n    }\n\n    onChangeEffect(editingEffect, image.computing ? undefined : image.results);\n    setDirty(false);\n  };\n\n  const effect =\n    editingEffect == null ? undefined : effectByName(editingEffect.effectName);\n\n  return (\n    <Dialog fullWidth maxWidth=\"sm\" open={open}>\n      {editingEffect && effect && (\n        <>\n          <DialogTitle>\n            <Stack direction=\"row\" spacing={4} marginTop={2}>\n              <FormControl fullWidth>\n                <Autocomplete\n                  disableClearable\n                  value={editingEffect.effectName}\n                  options={possibleEffects.map((t) => t.name)}\n                  onChange={(event, newEffectName) => {\n                    const t = effectByName(newEffectName)!;\n                    // Reset all the params when you select a new effect\n                    setEditingEffect({\n                      effectName: t.name,\n                      params: t.params.map((p) =>\n                        p.defaultValue(initialImage?.image ?? undefined)\n                      ),\n                    });\n                    setDirty(true);\n                  }}\n                  renderOption={(props, option) => (\n                    <li {...props}>\n                      <Stack marginLeft={2} marginRight={2}>\n                        <Typography variant=\"body1\">{option}</Typography>\n                        <Typography variant=\"caption\" marginLeft={2}>\n                          {effectByName(option).description}\n                        </Typography>\n                      </Stack>\n                    </li>\n                  )}\n                  renderInput={(params) => (\n                    <TextField {...params} label=\"Effect\" />\n                  )}\n                />\n              </FormControl>\n            </Stack>\n          </DialogTitle>\n          <DialogContent>\n            <Stack divider={<Divider />} spacing={2}>\n              <Typography variant=\"body2\">\n                {effect.description}\n                <div>\n                  {effect.secondaryDescription && (\n                    <Typography variant=\"caption\" marginLeft={2}>\n                      {effect.secondaryDescription}\n                    </Typography>\n                  )}\n                </div>\n              </Typography>\n\n              {effect.params.map(\n                // Create elements for each of the parameters for the selectect effect.\n                // Each of these would get an onChange event so we know when the user has\n                //  selected a value.\n                (param: ParamFunction<any>, idx: number) => {\n                  const ele = param.fn({\n                    value: editingEffect.params[idx],\n                    onChange: (v) => {\n                      setDirty(true);\n                      setEditingEffect({\n                        ...editingEffect,\n                        params: replaceIndex(\n                          editingEffect.params,\n                          idx,\n                          () => v\n                        ),\n                      });\n                    },\n                  });\n                  return (\n                    <React.Fragment\n                      key={`${editingEffect.effectName}-${param.name}`}\n                    >\n                      {ele}\n                    </React.Fragment>\n                  );\n                }\n              )}\n              <Stack sx={{ height: 300 }}>\n                {image.computing ? (\n                  <CircularProgress size={100} />\n                ) : (\n                  <>\n                    <Gif\n                      src={image.results.gifWithBackgroundColor}\n                      alt={`effect-${editingEffect.effectName}`}\n                      dimensions={image.results.image.dimensions}\n                    />\n                    {image.results.partiallyTransparent ? (\n                      <BackgroundPreviewTooltip />\n                    ) : null}\n                  </>\n                )}\n              </Stack>\n            </Stack>\n          </DialogContent>\n          <DialogActions>\n            <Button\n              variant=\"outlined\"\n              autoFocus\n              onClick={() => {\n                closeDialog({ save: false });\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"contained\"\n              autoFocus\n              disabled={!dirty}\n              onClick={() => {\n                closeDialog({ save: true });\n              }}\n            >\n              Save and Close\n            </Button>\n          </DialogActions>\n        </>\n      )}\n    </Dialog>\n  );\n};\n","import React from 'react';\nimport { Button, CircularProgress, Stack, Typography } from '@material-ui/core';\nimport { saveAs } from 'file-saver';\n\nimport { Swiper, SwiperSlide } from 'swiper/react';\nimport { Navigation, Controller } from 'swiper';\nimport SwiperClass from 'swiper/types/swiper-class';\nimport 'swiper/swiper.min.css';\nimport 'swiper/modules/navigation/navigation.min.css';\n\nimport {\n  ParamFunction,\n  Effect,\n  AppStateEffect,\n  Image,\n  AppState,\n  ImageEffectResult,\n  EffectInput,\n} from '../domain/types';\nimport { insertInto, replaceIndex } from '../domain/utils/misc';\nimport { Gif } from './Gif';\nimport { Icon, ClickableIcon } from './Icon';\nimport { ImageEffectDialog } from './ImageEffectDialog';\nimport { effectByName } from '../effects';\nimport { BackgroundPreviewTooltip } from './BackgroundPreviewTooltip';\n\ninterface EffectListProps {\n  appState: AppState;\n  possibleEffects: Effect<any>[];\n  onEffectsChange: (t: AppStateEffect[]) => void;\n}\n\nconst effectKey = (t: AppStateEffect, idx: number): string =>\n  `${t.effectName}-${idx}-${\n    t.state.status === 'done' ? t.state.image.gif.substring(0, 10) : 'pending'\n  }`;\n\ninterface ImageEffectProps {\n  effect: AppStateEffect;\n  index: number;\n  totalEffects: number;\n  fname?: string;\n  onDelete: () => void;\n  onEdit: () => void;\n  onMoveBefore: () => void;\n  onMoveAfter: () => void;\n  onAddBefore: () => void;\n  onAddAfter: () => void;\n}\n\nexport const ImageEffect: React.FC<ImageEffectProps> = ({\n  effect,\n  index,\n  totalEffects,\n  onEdit,\n  onDelete,\n  onMoveBefore,\n  onMoveAfter,\n  onAddBefore,\n  onAddAfter,\n}) => {\n  const e = effectByName(effect.effectName);\n  return (\n    <Stack alignItems=\"center\" margin={2} justifyContent=\"space-evenly\">\n      <Stack direction=\"row\" width=\"100%\" minHeight=\"4rem\">\n        <Typography\n          variant=\"subtitle1\"\n          fontWeight=\"bold\"\n          marginLeft={2}\n          marginBottom={1}\n          alignSelf=\"left\"\n          width=\"95%\"\n        >\n          {effect.effectName}\n        </Typography>\n        <ClickableIcon\n          tooltip=\"Delete effect\"\n          name=\"delete\"\n          onClick={onDelete}\n        />\n      </Stack>\n\n      {effect.state.status === 'done' ? (\n        <Stack sx={{ width: 250, paddingLeft: 3.5 }}>\n          <Gif\n            src={effect.state.image.gifWithBackgroundColor}\n            alt={`${effect.effectName}-${index}`}\n            dimensions={effect.state.image.image.dimensions}\n          />\n          {effect.state.image.partiallyTransparent ? (\n            <BackgroundPreviewTooltip />\n          ) : null}\n        </Stack>\n      ) : (\n        <CircularProgress size={100} />\n      )}\n\n      <Stack direction=\"row\" spacing={2} mt={4}>\n        <ClickableIcon\n          tooltip=\"Add new effect before this\"\n          name=\"add\"\n          onClick={onAddBefore}\n        />\n        <ClickableIcon\n          tooltip=\"Move effect left\"\n          isDisabled={index <= 0}\n          name=\"keyboard_double_arrow_left\"\n          onClick={onMoveBefore}\n        />\n        <ClickableIcon tooltip=\"Edit effect\" name=\"settings\" onClick={onEdit} />\n        <ClickableIcon\n          tooltip=\"Move effect right\"\n          isDisabled={index >= totalEffects - 1}\n          name=\"keyboard_double_arrow_right\"\n          onClick={onMoveAfter}\n        />\n        <ClickableIcon\n          tooltip=\"Add new effect after this\"\n          name=\"add\"\n          onClick={onAddAfter}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport const ImageEffectList: React.FC<EffectListProps> = ({\n  appState,\n  possibleEffects,\n  onEffectsChange,\n}) => {\n  const currentEffects = appState.effects;\n  const [effectDialogOpen, setEffectDialogOpen] = React.useState<\n    { open: false } | { open: true; idx: number; isNew: boolean }\n  >({ open: false });\n\n  const [swiper, setSwiper] = React.useState<SwiperClass | undefined>();\n\n  const [baseImage, setBaseImage] = React.useState<\n    ImageEffectResult | undefined\n  >();\n\n  React.useEffect(() => {\n    if (!appState.baseImage || baseImage?.gif === appState.baseImage.gif) {\n      return;\n    }\n\n    setBaseImage(baseImage);\n  }, [appState, baseImage]);\n\n  /** The first image to show when the edit dialog is opened */\n  const dialogInitialImage = React.useMemo(():\n    | ImageEffectResult\n    | undefined => {\n    if (!effectDialogOpen.open) {\n      return undefined;\n    }\n\n    const prevEffect = currentEffects[effectDialogOpen.idx - 1];\n    if (prevEffect) {\n      return prevEffect.state.status === 'done'\n        ? prevEffect.state.image\n        : undefined;\n    }\n\n    return appState.baseImage;\n  }, [appState, currentEffects, effectDialogOpen]);\n\n  const currentEffect = React.useMemo((): EffectInput | undefined => {\n    if (!effectDialogOpen.open) {\n      return undefined;\n    }\n\n    const e = currentEffects[effectDialogOpen.idx];\n    return {\n      effectName: e.effectName,\n      params: e.paramsValues,\n    };\n  }, [effectDialogOpen, currentEffects]);\n\n  const newDefaultEffect = (tIdx: number): AppStateEffect => ({\n    effectName: possibleEffects[0].name,\n    paramsValues: possibleEffects[0].params.map((p: ParamFunction<any>) => {\n      let image: Image | undefined = undefined;\n      const previousEffect = currentEffects[tIdx];\n      if (previousEffect?.state.status === 'done') {\n        image = previousEffect.state.image.image;\n      }\n\n      return p.defaultValue(image);\n    }),\n    state: { status: 'init' },\n  });\n\n  const onDelete = (idx: number) =>\n    onEffectsChange(currentEffects.filter((nextT, newIdx) => newIdx !== idx));\n\n  const onMoveBefore = (idx: number) => {\n    onEffectsChange(\n      currentEffects.map((nextT, newIdx) => {\n        if (newIdx === idx - 1) {\n          // This is the next item in the list\n          return currentEffects[newIdx + 1];\n        } else if (idx === newIdx) {\n          // This is the previous item\n          return currentEffects[idx - 1];\n        } else {\n          return nextT;\n        }\n      })\n    );\n    setTimeout(() => swiper?.slideTo(idx - 1), 50);\n  };\n\n  const onMoveAfter = (idx: number) => {\n    onEffectsChange(\n      currentEffects.map((nextT, newIdx) => {\n        if (newIdx === idx + 1) {\n          // This is the previous item in the list\n          return currentEffects[newIdx - 1];\n        } else if (idx === newIdx) {\n          // This is the next item\n          return currentEffects[idx + 1];\n        } else {\n          return nextT;\n        }\n      })\n    );\n    setTimeout(() => swiper?.slideTo(idx + 1), 50);\n  };\n\n  const onAddNew = () => {\n    onEffectsChange([newDefaultEffect(0)]);\n    setTimeout(() => swiper?.slideTo(0), 50);\n    setEffectDialogOpen({\n      open: true,\n      idx: 0,\n      isNew: true,\n    });\n  };\n\n  const onAddAfter = (tIdx: number) => {\n    const newIdx = tIdx + 1;\n    onEffectsChange(insertInto(currentEffects, newIdx, newDefaultEffect(tIdx)));\n    setTimeout(() => swiper?.slideTo(newIdx), 50);\n    setTimeout(\n      () =>\n        setEffectDialogOpen({\n          open: true,\n          idx: newIdx,\n          isNew: true,\n        }),\n      2\n    );\n  };\n\n  const onAddBefore = (tIdx: number) => {\n    onEffectsChange(\n      insertInto(currentEffects, tIdx, newDefaultEffect(tIdx - 1))\n    );\n    setTimeout(\n      () =>\n        setEffectDialogOpen({\n          open: true,\n          idx: tIdx,\n          isNew: true,\n        }),\n      2\n    );\n  };\n\n  const finalGif = React.useMemo((): string | undefined => {\n    const lastEffect = currentEffects[currentEffects.length - 1];\n    if (!lastEffect) {\n      return undefined;\n    }\n\n    if (lastEffect.state.status !== 'done') {\n      return undefined;\n    }\n\n    return lastEffect.state.image.gif;\n  }, [currentEffects]);\n\n  return (\n    <Stack spacing={4}>\n      <ImageEffectDialog\n        open={effectDialogOpen.open}\n        possibleEffects={possibleEffects}\n        onChangeEffect={(newEffect, computedImage) => {\n          if (!effectDialogOpen.open) {\n            return;\n          }\n\n          onEffectsChange(\n            replaceIndex(currentEffects, effectDialogOpen.idx, () => ({\n              effectName: newEffect.effectName,\n              paramsValues: newEffect.params,\n              state: computedImage\n                ? { status: 'done', image: computedImage }\n                : { status: 'init' },\n            }))\n          );\n          setEffectDialogOpen({ open: false });\n        }}\n        onCancel={() => {\n          // Assumed to be open at this point\n          if (effectDialogOpen.open && effectDialogOpen.isNew) {\n            // They pressed cancel on a new effect, so just remove this one.\n            // (It's assumed to be the last effect in the chain\n            onEffectsChange(currentEffects.slice(0, currentEffects.length - 1));\n          }\n\n          setEffectDialogOpen({ open: false });\n        }}\n        initialImage={dialogInitialImage}\n        currentEffect={currentEffect}\n        currFps={appState.fps}\n        currRandomSeed=\"partymoji\"\n      />\n      <Typography variant=\"h5\">Image Effects</Typography>\n      <Stack direction=\"row\">\n        <Swiper\n          navigation\n          modules={[Navigation, Controller]}\n          controller={{ control: swiper }}\n          onSwiper={setSwiper}\n        >\n          {currentEffects.map((t, tIdx) => (\n            <SwiperSlide key={effectKey(t, tIdx)}>\n              {tIdx + 1} of {currentEffects.length}\n              <ImageEffect\n                effect={t}\n                index={tIdx}\n                totalEffects={currentEffects.length}\n                fname={appState.fname}\n                onDelete={() => onDelete(tIdx)}\n                onEdit={() =>\n                  setEffectDialogOpen({\n                    open: true,\n                    idx: tIdx,\n                    isNew: false,\n                  })\n                }\n                onAddBefore={() => onAddBefore(tIdx)}\n                onAddAfter={() => onAddAfter(tIdx)}\n                onMoveBefore={() => onMoveBefore(tIdx)}\n                onMoveAfter={() => onMoveAfter(tIdx)}\n              />\n            </SwiperSlide>\n          ))}\n        </Swiper>\n      </Stack>\n      {currentEffects.length === 0 && (\n        <Button variant=\"outlined\" fullWidth onClick={onAddNew}>\n          Add First Effect\n        </Button>\n      )}\n      <Button\n        variant=\"contained\"\n        disabled={finalGif == null}\n        onClick={() => {\n          if (!finalGif) {\n            return; // Button will be disabled\n          }\n          saveAs(finalGif, appState.fname || 'image.gif');\n        }}\n        startIcon={<Icon name=\"save_alt\" />}\n      >\n        Save Gif\n      </Button>\n    </Stack>\n  );\n};\n","import { readImage } from './domain/run';\nimport { AppState, AppStateEffect } from './domain/types';\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nexport const getStoredAppState = async (): Promise<AppState | undefined> => {\n  try {\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (stored) {\n      const savedState = JSON.parse(stored);\n      if (Array.isArray(savedState.effects)) {\n        return {\n          ...savedState,\n          // Need to re-hydrate the baseImage's image data, as we don't save that to local storage\n          baseImage:\n            typeof savedState.baseImage === 'string'\n              ? {\n                  gif: savedState.baseImage,\n                  image: await readImage(savedState.baseImage),\n                }\n              : undefined,\n        };\n      }\n    }\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error loading state from local storage', err.stack || err);\n  }\n\n  return undefined;\n};\n\nexport const saveAppState = (state: AppState) => {\n  try {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, serializeAppState(state));\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error saving state to local storage', err.stack || err);\n  }\n};\n\nexport const clearAppState = () => {\n  try {\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error clearing state from local storage', err.stack || err);\n  }\n};\n\nconst serializeAppState = (state: AppState): string => {\n  const toStore = {\n    ...state,\n    // Do not save the frame data -- it's big and can be re-hydrated on load.\n    baseImage: state.baseImage?.gif,\n    effects: state.effects.map(\n      (t): AppStateEffect => ({\n        ...t,\n        // Remove the computed image for the state before storing.\n        // Like the base image frame data, it can be recreated when the app first loads.\n        state: { status: 'init' },\n      })\n    ),\n  };\n  return JSON.stringify(toStore);\n};\n","import React from 'react';\nimport { Alert, AlertColor, Snackbar } from '@material-ui/core';\n\nexport type AlertValue = { message: string; severity: AlertColor } | null;\n\ninterface AlertContext {\n  alert: AlertValue;\n  setAlert: (alert: AlertValue) => void;\n}\n\nexport const alertContext = React.createContext<AlertContext>({\n  alert: null,\n  setAlert: () => {\n    throw new Error('Context not initialized');\n  },\n});\n\nexport const AlertProvider: React.FC = ({ children }) => {\n  const [alertValue, setAlertValue] = React.useState<AlertValue>(null);\n\n  return (\n    <alertContext.Provider\n      value={{ alert: alertValue, setAlert: setAlertValue }}\n    >\n      {children}\n    </alertContext.Provider>\n  );\n};\n\nexport const AlertSnackbar: React.FC = () => {\n  const { alert, setAlert } = React.useContext(alertContext);\n  return (\n    <Snackbar open={alert != null}>\n      {alert == null ? undefined : (\n        <Alert severity={alert.severity} onClose={() => setAlert(null)}>\n          {alert.message}\n        </Alert>\n      )}\n    </Snackbar>\n  );\n};\n\nexport const useSetAlert = () => {\n  const { setAlert } = React.useContext(alertContext);\n  return setAlert;\n};\n","import React from 'react';\nimport {\n  Button,\n  Container,\n  Divider,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\n\nimport { Help } from './components/Help';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageEffectList } from './components/ImageEffectList';\nimport { computeGifsForState, getEffectsDiff } from './domain/computeGifs';\nimport { AppState, AppStateEffect } from './domain/types';\nimport { replaceIndex } from './domain/utils/misc';\nimport { ENV, debugLog, IS_MOBILE } from './domain/env';\nimport * as localStorage from './localStorage';\nimport { sliderParam } from './params/sliderParam';\nimport { POSSIBLE_EFFECTS } from './effects';\nimport { AlertProvider, AlertSnackbar, useSetAlert } from './AlertContext';\nimport { Icon } from './components/Icon';\nimport { ProcessorQueueProvider } from './components/useProcessingQueue';\n\n// Number of millis to wait after a change before recomputing the gif\nconst COMPUTE_DEBOUNCE_MILLIS = 1000;\n\n// Increase this by 1 when there's a breaking change to the app state.\n// Don't change this unless we have to!\nconst CURRENT_APP_STATE_VERSION = 7;\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Final Gif Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nconst DEFAULT_STATE: AppState = {\n  version: CURRENT_APP_STATE_VERSION,\n  effects: [],\n  baseImage: undefined,\n  fps: DEFAULT_FPS,\n};\n\nconst Inner: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n  const [doCompute, setDoCompute] = React.useState<\n    { compute: true; startIndex: number } | { compute: false }\n  >({ compute: false });\n  const [computeTimer, setComputeTimer] = React.useState<null | NodeJS.Timeout>(\n    null\n  );\n\n  const setAlert = useSetAlert();\n\n  React.useEffect(() => {\n    if (IS_MOBILE) {\n      setAlert({\n        severity: 'warning',\n        message:\n          'This app is not well optimized for mobile. Your experience may not be great.',\n      });\n    }\n  }, [setAlert]);\n\n  React.useEffect(() => {\n    (async () => {\n      // If we have local storage state on startup, then reload that\n      const stored = await localStorage.getStoredAppState();\n      if (stored) {\n        if (stored.version === CURRENT_APP_STATE_VERSION) {\n          setStateRaw(stored);\n          setDoCompute({ compute: true, startIndex: 0 });\n        } else {\n          // TODO Might be nice to tell the user we erased their previous stuff\n          localStorage.clearAppState();\n        }\n      }\n    })();\n  }, []);\n\n  const setState = React.useCallback(\n    (\n      fn: (oldState: AppState) => AppState,\n      { compute }: { compute: 'no' | 'now' | 'later' }\n    ) => {\n      setStateRaw((oldState) => {\n        const newState = fn(oldState);\n        localStorage.saveAppState(newState);\n\n        if (ENV === 'DEV') {\n          (window as any).STATE = newState;\n        }\n\n        if (compute !== 'no' && newState.baseImage != null) {\n          // Compute the gif some time from now.\n          // Other changes within this time should push the compute time back\n          if (computeTimer) {\n            clearTimeout(computeTimer);\n            setComputeTimer(null);\n          }\n\n          const effectsDiff = getEffectsDiff({\n            prevState: oldState,\n            currState: newState,\n          });\n\n          if (effectsDiff.diff) {\n            if (compute === 'now') {\n              setDoCompute({ compute: true, startIndex: effectsDiff.index });\n            } else {\n              setDoCompute({ compute: false });\n              setComputeTimer(\n                setTimeout(() => {\n                  setComputeTimer(null);\n                  setDoCompute({\n                    compute: true,\n                    startIndex: effectsDiff.index,\n                  });\n                }, COMPUTE_DEBOUNCE_MILLIS)\n              );\n            }\n          }\n        }\n\n        return newState;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  React.useEffect(() => {\n    debugLog('UseEffect, doCompute', doCompute);\n    if (doCompute.compute === false) {\n      return;\n    }\n\n    // TODO What happens if new changes come in while we're already computing?\n    // Need to throw away previous results and calculate new ones.\n    setDoCompute({ compute: false });\n    (async () => {\n      setState(\n        (prevState) => ({\n          ...prevState,\n          effects: prevState.effects.map((t, i): AppStateEffect => {\n            if (i < doCompute.startIndex) {\n              return t;\n            } else {\n              return {\n                ...t,\n                state: { status: 'computing' },\n              };\n            }\n          }),\n        }),\n        { compute: 'no' }\n      );\n      // TODO error handling\n      await computeGifsForState({\n        state,\n        onCompute: (image, computeIdx) => {\n          setState(\n            (prevState) => ({\n              ...prevState,\n              effects: replaceIndex(\n                prevState.effects,\n                computeIdx,\n                (t): AppStateEffect => ({\n                  ...t,\n                  state: { status: 'done', image },\n                })\n              ),\n            }),\n            { compute: 'no' }\n          );\n        },\n        startEffectIndex: doCompute.startIndex,\n      });\n    })();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [doCompute]);\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container maxWidth=\"sm\">\n        <Stack\n          spacing={4}\n          justifyContent=\"space-evenly\"\n          alignItems=\"center\"\n          width=\"sm\"\n          divider={<Divider />}\n        >\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />} alignItems=\"center\">\n            <Section>\n              <Help />\n            </Section>\n            <Section>\n              <Stack spacing={1} alignItems=\"center\">\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Upload a source image\"\n                  currentImage={state.baseImage}\n                  onChange={(baseImage, fname) => {\n                    if (IS_MOBILE) {\n                      const [width, height] = baseImage.image.dimensions;\n                      if (width > 512 || height > 512) {\n                        setAlert({\n                          severity: 'error',\n                          message:\n                            'The image you chose is too large to work well on mobile.',\n                        });\n\n                        return;\n                      }\n                    }\n\n                    setState(\n                      (prevState) => ({\n                        ...prevState,\n                        baseImage,\n                        fname,\n                      }),\n                      { compute: 'now' }\n                    );\n                  }}\n                />\n                <div style={{ maxWidth: '300px' }}>\n                  {fpsParam.fn({\n                    value: state.fps,\n                    onChange: (fps) =>\n                      setState(\n                        (prevState) => ({\n                          ...prevState,\n                          fps,\n                        }),\n                        { compute: 'later' }\n                      ),\n                  })}\n                </div>\n              </Stack>\n            </Section>\n            <Section>\n              <ImageEffectList\n                appState={state}\n                possibleEffects={POSSIBLE_EFFECTS}\n                onEffectsChange={(effects) =>\n                  setState(\n                    (prevState) => ({\n                      ...prevState,\n                      effects,\n                    }),\n                    { compute: 'now' }\n                  )\n                }\n              />\n            </Section>\n            <Section>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear Effects</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear all effects for the image\n                </Typography>\n                <Button\n                  startIcon={<Icon name=\"clear\" />}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  color=\"warning\"\n                  onClick={() => {\n                    const newState: AppState = {\n                      ...DEFAULT_STATE,\n                      baseImage: state.baseImage,\n                    };\n                    setStateRaw(newState);\n                    localStorage.saveAppState(newState);\n                  }}\n                >\n                  Clear Effects\n                </Button>\n              </Stack>\n            </Section>\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n\n      <AlertSnackbar />\n    </>\n  );\n};\n\nconst Section: React.FC = ({ children }) => (\n  <Paper style={{ padding: 16 }} sx={{ width: 300 }}>\n    {children}\n  </Paper>\n);\n\n// Icons at https://fonts.google.com/icons?selected=Material+Icons\n\nexport const App: React.FC = () => {\n  return (\n    <ProcessorQueueProvider>\n      <AlertProvider>\n        <Inner />\n      </AlertProvider>\n    </ProcessorQueueProvider>\n  );\n};\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import { createTheme, ThemeProvider } from '@material-ui/core';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\nimport * as localStorage from './localStorage';\n\nconst theme = createTheme({\n  typography: {\n    fontFamily: 'Raleway, Arial',\n  },\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <TopLevelErrorBoundary\n        onClearLocalStorage={() => {\n          localStorage.clearAppState();\n          window.location.reload();\n        }}\n      >\n        <App />\n      </TopLevelErrorBoundary>\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}