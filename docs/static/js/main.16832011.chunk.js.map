{"version":3,"sources":["domain/utils.ts","domain/run.ts","components/HelpTooltip.tsx","params/sliderParam.tsx","domain/types.ts","params/intParam.tsx","transforms/adjust-image.ts","components/Expandable.tsx","params/colorPickerParam.tsx","transforms/background-color.ts","components/ImagePicker.tsx","params/radioParam.tsx","transforms/background-image.ts","params/imagePickerParam.tsx","transforms/bounce.ts","transforms/bounce-animation.ts","transforms/circle.ts","params/variableLengthParam.tsx","transforms/colors.ts","transforms/colors-background.ts","params/floatParam.tsx","transforms/double-vision.ts","transforms/expand.ts","transforms/fill.ts","transforms/fisheye.ts","transforms/grid.ts","params/huePickerParam.tsx","transforms/hue-change.ts","params/textParam.tsx","transforms/hue-shift.ts","transforms/hue-shift-pulse.ts","transforms/lightning.ts","transforms/nuke.ts","transforms/party.ts","transforms/party-two.ts","transforms/pinwheel.ts","transforms/pinwheel-party.ts","transforms/radiance.ts","transforms/radiance-party.ts","transforms/repeat-animation.ts","transforms/resize-image.ts","transforms/reverse-animation.ts","transforms/ripple.ts","transforms/rotate.ts","transforms/roxbury.ts","transforms/shake.ts","transforms/slow-animation.ts","transforms/spin.ts","transforms/static.ts","params/checkboxParam.tsx","transforms/transparency.ts","transforms/transpose.ts","transforms/index.ts","components/ComputeBox.tsx","components/ImageTransform.tsx","components/ImageTransformList.tsx","components/ImportExport.tsx","localStorage.ts","App.tsx","components/TopLevelErrorBoundary.tsx","index.tsx"],"names":["toHexColor","r","g","b","toHexValue","c","s","toString","toUpperCase","length","fromHexColor","hex","parseInt","substr","isTransparent","pixel","randomColor","random","Math","floor","int32","clamp","n","min","max","clampColor","a","TRANSPARENT_COLOR","getPixelFromSource","dimensions","image","coord","width","height","x","y","idx","getImageIndex","assert","condition","message","AssertionError","actual","mapFrames","cb","frames","map","frame","mapCoords","transformedImageData","Uint8Array","mapImage","parameters","imageData","frameIndex","frameCount","animationProgress","getSrcPixel","mapImageWithPrecompute","compute","computed","scaleImage","args","newWidth","newHeight","xRatio","yRatio","newImage","createNewImage","srcX","srcY","color","getPixel","setPixel","resizeImage","sourceWidth","sourceHeight","xPadding","round","yPadding","range","weightedValue","percent","v1","v2","shiftTowardsHue","hue","amount","convert","hsl","l","rgb","newR","newG","newB","shiftHue","h","calculateAngle","c1","c2","xRelCenter","yRelCenter","atan2","PI","colorFromHue","adjustSaturation","newSat","abs","runTransforms","transformList","inputDataUrl","fps","onImageFinished","seedrandom","readImage","originalImage","results","currentImage","transformInput","result","transform","fn","params","transparentColor","getTransparentColor","encodeTransparency","createGif","gif","push","img","i","Promise","resolve","gifEncoder","setFrameRate","setRepeat","hexColor","slice","setTransparent","writeHeader","data","on","chunk","dataUrl","URL","createObjectURL","Blob","type","forEach","f","addFrame","finish","res","rej","getPixels","err","shape","from","numFrames","sliceSize","subarray","hasTransparent","seenPixels","Set","attempt","px","add","findRandomColorNotInSet","undefined","set","attempts","col","has","HelpTooltip","description","Tooltip","title","Icon","fontSize","SliderParam","name","value","step","onChange","Stack","spacing","direction","Typography","variant","sx","paddingLeft","paddingRight","Slider","aria-label","valueLabelDisplay","getAriaValueText","e","valid","sliderParam","defaultValue","buildTransform","disabled","IntParam","parse","React","useState","val","setVal","invalidText","setInvalidText","FormControl","TextField","error","onBlur","reason","target","FormHelperText","intParam","isNaN","adjustImage","resizeToWidth","resizeToHeight","brightness","contrast","saturation","hasFrameCount","oldWidth","oldHeight","hasScaleChange","ceil","console","log","isBiggerImage","currImage","setFrameCount","currColor","d","adjustBrightness","adjustContrast","currentFrames","Expandable","mainEle","children","collapsed","setCollapsed","ClickAwayListener","onClickAway","Box","Button","onClick","style","textTransform","Collapse","in","ColorBox","backgroundColor","ColorPickerParam","disableAlpha","presetColors","onChangeComplete","colorPickerParam","p","ImagePicker","currentImageUrl","startIcon","maxWidth","component","hidden","accept","event","files","Array","file","readFile","baseImage","maxHeight","src","alt","reader","FileReader","onload","readAsDataURL","RadioParam","options","RadioGroup","t","FormControlLabel","control","Radio","label","radioParam","backgroundImage","imagePickerParam","otherImage","frameProgress","otherImageFrame","otherImageSrc","bounce","speed","yOffset","sin","bounceAnimation","concat","pipe","drop","reverse","circle","radius","xOffset","cos","VariableLengthParam","newParamText","createNewParam","v","param","pValue","setParams","Paper","ele","newValue","oldP","IconButton","newParams","filter","variableLengthParam","colors","chosenColor","srcPixel","gray","getAveragePixelValue","colorsBackground","bgColor","FloatParam","floatParam","parseFloat","doubleVision","dir","expand","dist","centerX","centerY","fill","fisheye","angle","grid","gridSize","gridAngle","isOnGrid","threshold","onGrid","angleDegrees","tan","toRad","degrees","HuePickerParam","huePickerParam","hueChange","newHue","hueShift","hueShiftPulse","TextParam","lightningIntensities","lightning","seed","flashIntensity","icf","nuke","party","shiftSpeed","isBackground","newH","partyTwo","DEFAULT_COLORS","pinwheel","groupCount","ribbonCount","ribbonArcDegrees","colorsLength","toFixed","offsetX","offsetY","center","pointAngle","colorIdx","pinwheelParty","radiance","colorList","flatMap","maxDist","sqrt","distFromCenter","radianceParty","repeatAnimation","numRepeats","resizeImageUtil","reverseAnimation","ripple","shift","amplitude","period","rotate","roxbury","phase","phaseIdx","maxAngle","rotatePointX","rotatePointY","shake","slowAnimation","ogFrameIdx","r1","g1","b1","a1","spin","staticc","strength","inverse","grey","isStatic","CheckboxParam","paddingTop","Checkbox","checked","transparency","checkboxParam","matchesTransparent","selectedColor","tolerance","withinTolerance","deltaRed","deltaBlue","deltaGreen","rSomething","rComponent","bComponent","gComponent","colorDiff","transpose","POSSIBLE_TRANSFORMS","sortBy","reject","transformByName","find","fpsParam","ComputeBox","computeDisabled","appState","onFpsChange","onComputed","loading","computeTime","computeState","setComputeState","progress","setProgress","endIcon","dirty","transformInputs","transforms","transformName","paramsValues","setTimeout","start","Date","now","currIdx","timings","timingValue","ga","hitType","timingCategory","timingVar","stack","CircularProgress","LinearProgress","Divider","Grid","container","padding","columns","xs","sm","md","item","ImageTransform","selectedTransform","possibleTransforms","index","onSelect","onRemove","onMoveLeft","onMoveRight","elevation","fullWidth","Autocomplete","disableClearable","newTransformName","paramValues","renderInput","divider","Fragment","ImageTransformList","currentTransforms","onTransformsChange","rowSpacing","tIdx","nextT","newIdx","selected","nextTIdx","computedImage","ImportExport","state","onImport","info","setInfo","isInvalid","setInvalid","showError","output","lz","JSON","stringify","navigator","clipboard","writeText","readText","clipboardContents","isArray","Alert","severity","LOCAL_STORAGE_KEY","clearAppState","window","localStorage","removeItem","DEBUG","DEFAULT_STATE","App","setStateRaw","useEffect","stored","getItem","savedState","setState","newState","setItem","computeBtnDisbled","some","every","ScopedCssBaseline","Container","justifyContent","pt","href","rel","TopLevelErrorBoundary","hasError","errorInfo","this","props","onClearLocalStorage","Component","ReactDOM","render","StrictMode","location","reload","document","getElementById"],"mappings":"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","file":"static/js/main.16832011.chunk.js","sourcesContent":["import { AssertionError } from 'assert';\nimport * as convert from 'color-convert';\nimport { range } from 'remeda';\nimport seedrandom from 'seedrandom';\nimport {\n  Color,\n  Coord,\n  Dimensions,\n  Image,\n  ImageData,\n  Random,\n  TransformFn,\n  TransformFnOpts,\n} from './types';\n\n/**\n * Converts a Pixel into a hex string like '#00FF00'\n */\nexport const toHexColor = ([r, g, b]: Color) => {\n  const toHexValue = (c: number) => {\n    const s = c.toString(16).toUpperCase();\n    return s.length === 2 ? s : '0' + s;\n  };\n\n  return `#${toHexValue(r)}${toHexValue(g)}${toHexValue(b)}`;\n};\n\nexport const fromHexColor = (hex: string): Color => [\n  parseInt(hex.toUpperCase().substr(1, 2), 16),\n  parseInt(hex.toUpperCase().substr(3, 2), 16),\n  parseInt(hex.toUpperCase().substr(5, 2), 16),\n  255,\n];\n\nexport const isHexColor = (s: string) => /^#[0-9A-F]{6}$/.test(s);\n\n/**\n * Our transformation functions allow for an alpha channel, but gifs do not.\n * All pixels are either fully solid or fully transparent.\n * This function returns true if the color's alpha is below a certain threshold.\n */\nexport const isTransparent = (pixel: Color) => pixel[3] < 64;\n\nexport const randomColor = (random: seedrandom.prng): Color => [\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  Math.floor(random.int32() * 256),\n  255,\n];\n\nexport const getAveragePixelValue = ([r, g, b]: Color) =>\n  Math.round((r + g + b) / 3);\n\nexport const clamp = (n: number, min: number, max: number) =>\n  Math.max(Math.min(n, max), min);\n\nexport const clampColor = ([r, g, b, a]: Color): Color => [\n  clamp(r, 0, 255),\n  clamp(g, 0, 255),\n  clamp(b, 0, 255),\n  clamp(a, 0, 255),\n];\n\nexport const TRANSPARENT_COLOR: Color = [0, 0, 0, 0];\n\nexport const getPixelFromSource = (\n  dimensions: Dimensions,\n  image: ImageData,\n  coord: Coord\n): Color => {\n  const [width, height] = dimensions;\n  const [x, y] = coord;\n  if (x < 0 || x >= width || y < 0 || y >= height) {\n    return TRANSPARENT_COLOR; // Default to transparent if an invalid coordinate\n  }\n\n  const idx = getImageIndex(dimensions, x, y);\n  return [image[idx], image[idx + 1], image[idx + 2], image[idx + 3]];\n};\n\n/**\n * Asserts that a given value is truthy. Uses TypeScript 3.7 assertion types.\n *\n * @example\n * ```ts\n * const foo: string|undefined = getSomeData();\n * asert(foo, 'foo must be defined');\n * console.log(foo.length); // OK\n * ```\n */\nexport function assert(\n  condition: unknown,\n  message = 'Unexpected falsy value'\n): asserts condition {\n  if (!condition) {\n    throw new AssertionError({ message, actual: condition });\n  }\n}\n\n/********** Mapping Utils ***********/\n// Maps all frames from the original image into new frames.\n// Assumes all mapped frames are the same dimension as the original image.\nexport const mapFrames = (\n  image: Image,\n  cb: (\n    imageData: ImageData,\n    frameIndex: number,\n    frameCount: number\n  ) => ImageData\n): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((frame, idx) => cb(frame, idx, image.frames.length)),\n});\n\n/**\n * Maps the coordinates in a given shape into an image\n */\nexport const mapCoords = (\n  dimensions: Dimensions,\n  cb: (coord: Coord) => Color\n): ImageData => {\n  const [width, height] = dimensions;\n  const transformedImageData = new Uint8Array(width * height * 4);\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const c = clampColor(cb([x, y]));\n      const idx = getImageIndex(dimensions, x, y);\n      transformedImageData[idx] = c[0];\n      transformedImageData[idx + 1] = c[1];\n      transformedImageData[idx + 2] = c[2];\n      transformedImageData[idx + 3] = c[3];\n    }\n  }\n  return transformedImageData;\n};\n\n/**\n * Combines mapFrames and mapCoords into one function.\n * Used for transforming each pixel in an image into another pixel.\n */\nexport const mapImage = <T>(\n  cb: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) =>\n      mapCoords(image.dimensions, (coord) =>\n        cb({\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress: frameIndex / frameCount,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      )\n    );\n};\n\n/**\n * Similar to mapImage, but the first argument pre-computes some things for\n *  each frame, which is then passed to the second callback function.\n * This is useful for performance (only compute things every frame rather than every pixel),\n *  and also allows you to generate some random value that will be the same for every frame.\n */\nexport const mapImageWithPrecompute = <T, R>(\n  compute: (args: {\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n  }) => R,\n  cb: (args: {\n    computed: R;\n    image: Image;\n    dimensions: Dimensions;\n    random: Random;\n    parameters: T;\n    coord: Coord;\n    frameCount: number;\n    frameIndex: number;\n    /** Between 0 and 1 */\n    animationProgress: number;\n    getSrcPixel: (coord: Coord) => Color;\n  }) => Color\n): TransformFn<T> => {\n  return ({ image, random, parameters }: TransformFnOpts<T>) =>\n    mapFrames(image, (imageData, frameIndex, frameCount) => {\n      const animationProgress = frameIndex / frameCount;\n      const computed = compute({\n        image,\n        dimensions: image.dimensions,\n        random,\n        parameters,\n        frameCount,\n        frameIndex,\n        animationProgress,\n      });\n\n      return mapCoords(image.dimensions, (coord) =>\n        cb({\n          computed,\n          image,\n          dimensions: image.dimensions,\n          random,\n          parameters,\n          coord,\n          frameCount,\n          frameIndex,\n          animationProgress,\n          getSrcPixel: (c: Coord) =>\n            getPixelFromSource(image.dimensions, imageData, c),\n        })\n      );\n    });\n};\n\nexport const getImageIndex = ([width]: Dimensions, x: number, y: number) =>\n  (x + y * width) * 4;\n\n/**\n * Change the dimensions of the image, scaling it to make it fit the new dimensions\n */\nexport const scaleImage = (args: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const { image, newWidth, newHeight } = args;\n  const [width, height] = image.dimensions;\n  const xRatio = width / newWidth;\n  const yRatio = height / newHeight;\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        // Simple nearest-neighbor image scaling.\n        // Arguably the worst of the scaling algorithms, but it's quick,\n        //  and we're generally dealing with small images anyhow.\n        const srcX = Math.floor(x * xRatio);\n        const srcY = Math.floor(y * yRatio);\n\n        const color = getPixel({\n          image,\n          frameIndex,\n          coord: [srcX, srcY],\n        });\n        setPixel({\n          image: newImage,\n          frameIndex,\n          color,\n          coord: [x, y],\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\n/**\n * Will change the image dimensions without altering the scale.\n * If the new dimensions are larger, the image will be centered.\n * If the new dimensions are smaller, it'll be cropped\n */\nexport const resizeImage = ({\n  image,\n  newWidth,\n  newHeight,\n}: {\n  image: Image;\n  newWidth: number;\n  newHeight: number;\n}): Image => {\n  const [sourceWidth, sourceHeight] = image.dimensions;\n\n  const xPadding = Math.round((newWidth - sourceWidth) / 2);\n  const yPadding = Math.round((newHeight - sourceHeight) / 2);\n\n  const newImage = createNewImage({\n    dimensions: [newWidth, newHeight],\n    frameCount: image.frames.length,\n  });\n\n  for (\n    let frameIndex = 0;\n    frameIndex < newImage.frames.length;\n    frameIndex += 1\n  ) {\n    for (let y = 0; y < newHeight; y += 1) {\n      for (let x = 0; x < newWidth; x += 1) {\n        const color: Color =\n          x > xPadding &&\n          x < newWidth - xPadding &&\n          y > yPadding &&\n          y < newHeight - yPadding\n            ? getPixel({\n                image,\n                frameIndex,\n                coord: [x - xPadding, y - yPadding],\n              })\n            : TRANSPARENT_COLOR;\n        setPixel({\n          image: newImage,\n          frameIndex,\n          coord: [x, y],\n          color,\n        });\n      }\n    }\n  }\n\n  return newImage;\n};\n\nexport const createNewImage = (args: {\n  frameCount: number;\n  dimensions: Dimensions;\n}): Image => ({\n  dimensions: args.dimensions,\n  frames: range(0, args.frameCount).map(\n    // 4 == bytes used per color (RGBA)\n    () => new Uint8Array(args.dimensions[0] * args.dimensions[1] * 4)\n  ),\n});\n\nexport const duplicateImage = (image: Image): Image => ({\n  dimensions: image.dimensions,\n  frames: image.frames.map((f) => new Uint8Array(f)),\n});\n\nexport const getPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n}) =>\n  getPixelFromSource(\n    args.image.dimensions,\n    args.image.frames[args.frameIndex],\n    args.coord\n  );\n\nexport const setPixel = (args: {\n  image: Image;\n  frameIndex: number;\n  coord: Coord;\n  color: Color;\n}) => {\n  const idx = getImageIndex(\n    args.image.dimensions,\n    args.coord[0],\n    args.coord[1]\n  );\n  const frame = args.image.frames[args.frameIndex];\n  frame[idx] = args.color[0];\n  frame[idx + 1] = args.color[1];\n  frame[idx + 2] = args.color[2];\n  frame[idx + 3] = args.color[3];\n};\n\n/**\n * Calculate a value between v1 and v2, determined by percent.\n * @param percent Between 0 and 100. 0 is all v1, and 100 is all v2.\n */\nexport const weightedValue = (percent: number, v1: number, v2: number) =>\n  (1 - percent / 100) * v1 + (percent / 100) * v2;\n\n/**\n * Shift the hue of the pixel towards a certain color, by a certain amount percentage\n * @param hue [0, 360)\n * @param amount [0, 100]\n */\nexport const shiftTowardsHue = (\n  [r, g, b, a]: Color,\n  hue: number,\n  amount: number\n): Color => {\n  const [, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([\n    hue,\n    weightedValue(amount, s, 100),\n    l,\n  ]);\n  return [\n    weightedValue(amount, r, newR),\n    weightedValue(amount, g, newG),\n    weightedValue(amount, b, newB),\n    a,\n  ];\n};\n\n/**\n * Adds the given amount to the hue of the color.\n * Amount should be between 0 and 360\n */\nexport const shiftHue = ([r, g, b, a]: Color, amount: number): Color => {\n  const [h, s, l] = convert.rgb.hsl([r, g, b]);\n  const [newR, newG, newB] = convert.hsl.rgb([(h + amount) % 360, s, l]);\n  return [newR, newG, newB, a];\n};\n\n/**\n * Returns the angle in degrees (0 to 360) betwee the two coordinates\n */\nexport const calculateAngle = (c1: Coord, c2: Coord): number => {\n  const xRelCenter = c2[0] - c1[0];\n  const yRelCenter = c2[1] - c1[1];\n  return (360 + (Math.atan2(yRelCenter, xRelCenter) * 180) / Math.PI) % 360;\n};\n\n/**\n * Turn a hue value (0 - 360) into a Color\n */\nexport const colorFromHue = (hue: number): Color => [\n  ...convert.hsl.rgb([hue, 100, 50]),\n  255,\n];\n\nexport const adjustSaturation = (color: Color, amount: number): Color => {\n  const [r, g, b, a] = color;\n  const [h, s, l] = convert.rgb.hsl(r, g, b);\n  const newSat = weightedValue(Math.abs(amount), s, amount >= 0 ? 100 : 0);\n  const [newR, newG, newB] = convert.hsl.rgb([h, newSat, l]);\n  return [newR, newG, newB, a];\n};\n\n// Amount: -100 to 100\nexport const adjustBrightness = (color: Color, amount: number): Color => {\n  const d = (amount / 100) * 128;\n  const [r, g, b, a] = color;\n  return clampColor([r + d, g + d, b + d, a]);\n};\n\n// Amount: -100 to 100\nexport const adjustContrast = (color: Color, amount: number): Color => {\n  const d = amount / 100 + 1;\n  const [r, g, b, a] = color;\n  return clampColor([\n    d * (r - 128) + 128,\n    d * (g - 128) + 128,\n    d * (b - 128) + 128,\n    a,\n  ]);\n};\n\n/**\n * Returns number between 0 and 1, where 1 is the largest difference and 0 is no difference\n */\nexport const colorDiff = (c1: Color, c2: Color): number => {\n  // Red-mean color diff algorithm\n  // https://en.wikipedia.org/wiki/Color_difference\n  const deltaRed = c1[0] - c2[0];\n  const deltaBlue = c1[1] - c2[1];\n  const deltaGreen = c1[2] - c2[2];\n  const rSomething = (c1[0] + c2[0]) / 2;\n\n  const rComponent = (2 + rSomething / 256) * deltaRed * deltaRed;\n  const bComponent = (2 + (255 - rSomething) / 256) * deltaBlue * deltaBlue;\n  const gComponent = 4 * deltaGreen * deltaGreen;\n  // 765 = ~ difference between black and white pixels\n  return Math.sqrt(rComponent + bComponent + gComponent) / 765;\n};\n","// @ts-ignore\nimport getPixels from 'get-pixels';\n// @ts-ignore\nimport gifEncoder from 'gif-encoder';\nimport seedrandom from 'seedrandom';\nimport { Color, Dimensions, Image, ImageData, TransformInput } from './types';\nimport {\n  fromHexColor,\n  getPixelFromSource,\n  isTransparent,\n  randomColor,\n  toHexColor,\n} from './utils';\n\ninterface RunArgs {\n  inputDataUrl: string;\n  transformList: TransformInput<any>[];\n  fps: number;\n  onImageFinished: () => void;\n}\n\ninterface ImageResult {\n  gif: string;\n  width: number;\n  height: number;\n}\n\n// Returns a list of gif data URLs, for each transform\nexport const runTransforms = async ({\n  transformList,\n  inputDataUrl,\n  fps,\n  onImageFinished,\n}: RunArgs): Promise<ImageResult[]> => {\n  const random = seedrandom(inputDataUrl);\n\n  const originalImage = await readImage(inputDataUrl);\n\n  const results: ImageResult[] = [];\n  let currentImage = originalImage;\n\n  for (const transformInput of transformList) {\n    const result = transformInput.transform.fn({\n      image: currentImage,\n      parameters: transformInput.params,\n      random,\n    });\n\n    const transparentColor = getTransparentColor(result, random);\n\n    // Transform any of our transparent pixels to what our gif understands to be transparent\n    const image = encodeTransparency(result.frames, transparentColor);\n\n    const gif = await createGif(\n      result.dimensions,\n      image,\n      transparentColor,\n      fps\n    );\n\n    onImageFinished();\n\n    currentImage = result;\n    results.push({\n      gif,\n      width: result.dimensions[0],\n      height: result.dimensions[1],\n    });\n  }\n\n  return results;\n};\n\n/**\n * Each pixel in our image has an alpha channel, but gifs don't.\n * We transform each pixel that appears transparent to be a designated transparent color.\n */\nconst encodeTransparency = (\n  frames: ImageData[],\n  transparentColor: Color | undefined\n): ImageData[] => {\n  const image = frames.map((frame) => {\n    const img = new Uint8Array(frame.length);\n    for (let i = 0; i < frame.length; i += 4) {\n      if (transparentColor && frame[i + 3] < 128) {\n        // Anything more than halfway transparent is considered transparent\n        img[i] = transparentColor[0];\n        img[i + 1] = transparentColor[1];\n        img[i + 2] = transparentColor[2];\n        img[i + 3] = transparentColor[3];\n      } else {\n        img[i] = frame[i];\n        img[i + 1] = frame[i + 1];\n        img[i + 2] = frame[i + 2];\n        img[i + 3] = 255; // Gifs don't do transparency, I dunno why they take in an alpha value...\n      }\n    }\n    return img;\n  });\n\n  return image;\n};\n\nconst createGif = async (\n  dimensions: Dimensions,\n  frames: ImageData[],\n  transparentColor: Color | undefined,\n  fps: number\n): Promise<string> =>\n  new Promise<string>((resolve) => {\n    const [width, height] = dimensions;\n    const gif = new gifEncoder(width, height);\n\n    gif.setFrameRate(fps);\n    gif.setRepeat(0); // Loop indefinitely\n    if (transparentColor) {\n      // Need to convert '#RRGGBB' to '0xRRGGBB'\n      const hexColor = toHexColor(transparentColor).slice(1);\n      gif.setTransparent(`0x${hexColor}`);\n    }\n\n    // gif.setQuality(10);\n    gif.writeHeader();\n\n    let data: any[] = [];\n    gif.on('data', (chunk: any) => {\n      data.push(chunk);\n    });\n    gif.on('end', () => {\n      const dataUrl = URL.createObjectURL(\n        new Blob(data, { type: 'image/gif' })\n      );\n      resolve(dataUrl);\n    });\n\n    frames.forEach((f) => {\n      gif.addFrame(f);\n    });\n\n    gif.finish();\n  });\n\nexport const readImage = (dataUrl: string): Promise<Image> =>\n  new Promise<Image>((res, rej) =>\n    getPixels(\n      dataUrl,\n      (err: Error, results: { shape: number[]; data: ImageData }) => {\n        if (err) {\n          return rej(err);\n        }\n\n        if (results.shape.length === 3) {\n          // Single frame\n          return res({\n            frames: [Uint8Array.from(results.data)],\n            dimensions: [results.shape[0], results.shape[1]],\n          });\n        }\n\n        // Multiple frames, need to slice up the image data into numFrames slices\n        const [numFrames, width, height] = results.shape;\n        const sliceSize = width * height * 4;\n        const frames: Uint8Array[] = [];\n        for (let i = 0; i < numFrames; i += 1) {\n          frames.push(\n            results.data.subarray(i * sliceSize, (i + 1) * sliceSize)\n          );\n        }\n        return res({\n          frames,\n          dimensions: [width, height],\n        });\n      }\n    )\n  );\n\nconst getTransparentColor = (\n  image: Image,\n  random: seedrandom.prng\n): Color | undefined => {\n  let hasTransparent = false;\n  const seenPixels = new Set<string>();\n  const [width, height] = image.dimensions;\n  let attempt = toHexColor([0, 255, 0, 255]); // Just start with green for now, since it's a likely candidate\n  image.frames.forEach((frame) => {\n    for (let y = 0; y < height; y += 1) {\n      for (let x = 0; x < width; x += 1) {\n        const px = getPixelFromSource(image.dimensions, frame, [x, y]);\n        if (isTransparent(px)) {\n          hasTransparent = true;\n        } else {\n          const hex = toHexColor(px);\n          seenPixels.add(hex);\n          if (hex === attempt) {\n            // Uh oh, can't use our current pick for transparent because it exists in the image already\n            attempt = findRandomColorNotInSet(random, seenPixels);\n          }\n        }\n      }\n    }\n  });\n  return hasTransparent ? fromHexColor(attempt) : undefined;\n};\n\nconst findRandomColorNotInSet = (\n  random: seedrandom.prng,\n  set: Set<string>,\n  attempts = 0\n): string => {\n  const col = toHexColor(randomColor(random));\n  if (attempts > 2000) {\n    // Just give up in order to prevent a stack overflow or something...\n    return col;\n  }\n  return set.has(col)\n    ? findRandomColorNotInSet(random, set, attempts + 1)\n    : col;\n};\n","import { Icon, Tooltip } from '@material-ui/core';\nimport React from 'react';\n\ninterface TooltipProps {\n  description?: string;\n}\n\nexport const HelpTooltip: React.FC<TooltipProps> = ({ description }) =>\n  description ? (\n    <Tooltip title={description}>\n      <Icon fontSize=\"small\" color=\"action\">\n        help\n      </Icon>\n    </Tooltip>\n  ) : null;\n","import { Slider, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst SliderParam: React.FC<{\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, min, max, step, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{ paddingLeft: '8px', paddingRight: '8px' }}\n      >\n        <Slider\n          aria-label={name}\n          value={value}\n          step={step}\n          valueLabelDisplay=\"off\"\n          getAriaValueText={(x) => x.toString()}\n          min={min}\n          max={max}\n          onChange={(e, value) =>\n            onChange({ valid: true, value: value as number })\n          }\n        />\n        <Typography variant=\"body2\">{value}</Typography>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function sliderParam(args: {\n  name: string;\n  min: number;\n  max: number;\n  step?: number;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue:\n      args.defaultValue !== undefined\n        ? { valid: true, value: args.defaultValue }\n        : { valid: false },\n    fn: (params) => {\n      return (\n        <SliderParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          min={args.min}\n          max={args.max}\n          step={args.step}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import seedrandom from 'seedrandom';\n\n/**\n * [R, G, B, A] in values 0 - 255 inclusive\n */\nexport type Color = [number, number, number, number];\n\n/**\n * [x, y]\n */\nexport type Coord = [number, number];\n\n/**\n * [width, height]\n */\nexport type Dimensions = [number, number];\n\n/**\n * A one-dimensional array of pixels.\n * A 3x2 image would contain 24 (6*4) numbers, and would look like this:\n *  [\n *    r1,g1,b1,a1, r2,g2,b2,a2, r3,g3,b3,a3,\n *    r4,g4,b4,a4, r5,g5,b5,a5, r6,g6,b6,a6\n *  ]\n *\n * [0, 0] = index 0\n * [1, 0] = index 4\n * [2, 0] = index 8\n * [0, 1] = index 12\n * [1, 1] = index 16\n * [2, 1] = index 20\n * To get pixel [x, y], do (x + y * width) * 4\n */\nexport type ImageData = Uint8Array;\n\n/**\n * The results of get-pixels processImage()\n */\nexport interface Image {\n  dimensions: Dimensions;\n  frames: ImageData[];\n}\n\nexport type Random = seedrandom.prng;\n\nexport interface TransformFnOpts<Params> {\n  /**\n   * The image we're trying to transform\n   */\n  image: Image;\n\n  /**\n   * Use to generate \"random\" numbers. It's seeded, so that subsequent calls will yield the same value on the same image.\n   */\n  random: Random;\n\n  /**\n   * User-passed in parameters.\n   */\n  parameters: Params;\n}\n\nexport type ParamValue<T> = { valid: true; value: T } | { valid: false };\n\nexport interface Parameter<T> {\n  name: string;\n  defaultValue: T;\n  ele: JSX.Element;\n}\n\nexport interface Params<T> {\n  value: ParamValue<T>;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nexport type ParamFunction<T = any> = {\n  name: string;\n  defaultValue: ParamValue<T>;\n  fn: (params: Params<T>) => JSX.Element;\n};\n\nexport type TransformFn<Params> = (opts: TransformFnOpts<Params>) => Image;\n\ntype ParamType<Type> = Type extends ParamFunction<infer X> ? X : never;\n\nexport interface Transform<T extends readonly ParamFunction<any>[]> {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled: boolean;\n}\n\nexport interface TransformWithParams<T extends readonly ParamFunction<any>[]> {\n  transformName: string;\n  paramsValues: ParamValue<T>[];\n}\n\nexport interface TransformInput<T extends ParamFunction<any>[]> {\n  transform: Transform<T>;\n  params: T;\n}\n\nexport const buildTransform = <T extends readonly ParamFunction<any>[]>(args: {\n  name: string;\n  params: T;\n  description?: string;\n  fn: TransformFn<{ [P in keyof T]: ParamType<T[P]> }>;\n  disabled?: boolean;\n}): Transform<T> => ({\n  name: args.name,\n  params: args.params,\n  description: args.description,\n  fn: args.fn,\n  disabled: args.disabled ?? false,\n});\n\nexport interface AppState {\n  baseImage?: string;\n  transforms: {\n    transformName: string;\n    paramsValues: ParamValue<any>[];\n    computedImage?: string;\n  }[];\n  fps: number;\n  dirty: boolean;\n}\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst IntParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const intParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseInt(s, 10);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be an integer' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <IntParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { range } from 'remeda';\nimport { buildTransform, Image } from '../domain/types';\nimport {\n  adjustBrightness,\n  adjustContrast,\n  adjustSaturation,\n  getPixelFromSource,\n  mapCoords,\n  mapFrames,\n  scaleImage,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const adjustImage = buildTransform({\n  name: 'Adjust Image',\n  description: 'Leave a parameter at 0 if you want to not change it',\n  params: [\n    sliderParam({\n      name: 'Number of Frames',\n      description:\n        'Set how many frames of animation there will be. Leave at 0 to not change the current frame count.',\n      defaultValue: 0,\n      min: 0,\n      max: 60,\n    }),\n    intParam({\n      name: 'Width',\n      description:\n        'Leave at 0 to not change the width. If height is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Leave at 0 to not change the height. If width is changed, the image will keep the same aspect ratio.',\n      defaultValue: 0,\n      min: 0,\n    }),\n    sliderParam({\n      name: 'Brightness',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Contrast',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n    sliderParam({\n      name: 'Saturation',\n      min: -100,\n      max: 100,\n      step: 5,\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: ({\n    image,\n    parameters: [\n      frameCount,\n      resizeToWidth,\n      resizeToHeight,\n      brightness,\n      contrast,\n      saturation,\n    ],\n  }) => {\n    const hasFrameCount = frameCount !== 0;\n\n    const [oldWidth, oldHeight] = image.dimensions;\n\n    const hasScaleChange = resizeToWidth > 0 || resizeToHeight > 0;\n\n    // If we're changing one of width/height, then we'll scale the other one to match the same aspect ratio.\n    const newWidth =\n      hasScaleChange && resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      hasScaleChange && resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n\n    console.log({ oldWidth, oldHeight, newWidth, newHeight });\n\n    // Use this to figure out when we should optimally resize the image\n    const isBiggerImage = newWidth * newHeight > oldWidth * oldHeight;\n\n    let currImage = image;\n\n    if (hasFrameCount && frameCount < image.frames.length) {\n      // Reducing the number of frames, so do that first so we have fewer pixels to change\n      currImage = setFrameCount(currImage, frameCount);\n    }\n\n    // If making a smaller image, might as well do the brightness/contrast after making it smaller\n    if (hasScaleChange && !isBiggerImage) {\n      currImage = scaleImage({\n        image: currImage,\n        newWidth,\n        newHeight,\n      });\n    }\n\n    currImage = mapFrames(currImage, (imageData) =>\n      mapCoords(currImage.dimensions, (coord) => {\n        let currColor = getPixelFromSource(\n          currImage.dimensions,\n          imageData,\n          coord\n        );\n\n        if (brightness !== 0) {\n          currColor = adjustBrightness(currColor, brightness);\n        }\n\n        if (contrast !== 0) {\n          currColor = adjustContrast(currColor, contrast);\n        }\n\n        if (saturation !== 0) {\n          currColor = adjustSaturation(currColor, saturation);\n        }\n\n        return currColor;\n      })\n    );\n\n    // If the image will be made bigger, we'll run that after adjusting the brightness/contrast\n    if (hasScaleChange && isBiggerImage) {\n      currImage = scaleImage({ image: currImage, newWidth, newHeight });\n    }\n\n    // Finally change the number of frames if we're adding frames\n    if (hasFrameCount && frameCount > image.frames.length) {\n      currImage = setFrameCount(currImage, frameCount);\n    }\n\n    return currImage;\n  },\n});\n\nconst setFrameCount = (image: Image, frameCount: number): Image => {\n  const currentFrames = image.frames;\n\n  // Resulting image will contain frameCount frames.\n  // If the original image had less than that, then we'll copy the last frame until we have enough.\n  // If the original has more frames, then we'll discard the last ones.\n  return {\n    dimensions: image.dimensions,\n    frames: range(0, frameCount).map((i) =>\n      currentFrames[i]\n        ? currentFrames[i]\n        : currentFrames[currentFrames.length - 1]\n    ),\n  };\n};\n","import {\n  Box,\n  Button,\n  ClickAwayListener,\n  Collapse,\n  Icon,\n  Stack,\n} from '@material-ui/core';\nimport React from 'react';\n\ninterface ExpandableProps {\n  mainEle: JSX.Element;\n}\n\nexport const Expandable: React.FC<ExpandableProps> = ({\n  mainEle,\n  children,\n}) => {\n  const [collapsed, setCollapsed] = React.useState(true);\n\n  return (\n    <ClickAwayListener onClickAway={() => setCollapsed(true)}>\n      <Box>\n        <Button\n          onClick={() => setCollapsed(!collapsed)}\n          style={{ textTransform: 'none', color: 'black' }}\n        >\n          <Stack direction=\"row\" spacing={4}>\n            <div>{mainEle}</div>\n            <Icon>{collapsed ? 'expand_less' : 'expand_more'}</Icon>\n          </Stack>\n        </Button>\n        <Collapse in={!collapsed}>{children}</Collapse>\n      </Box>\n    </ClickAwayListener>\n  );\n};\n","import { Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { SketchPicker } from 'react-color';\nimport { Expandable } from '../components/Expandable';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { Color, ParamFunction, ParamValue } from '../domain/types';\nimport { fromHexColor, toHexColor } from '../domain/utils';\n\nconst ColorBox: React.FC<{ color: Color }> = ({ color }) => (\n  <div\n    style={{\n      width: '1.5em',\n      height: '1.5em',\n      backgroundColor: toHexColor(color),\n    }}\n  />\n);\n\nconst ColorPickerParam: React.FC<{\n  name: string;\n  value?: Color;\n  description?: string;\n  onChange: (v: ParamValue<Color>) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Expandable\n      mainEle={\n        <Stack direction=\"row\" spacing={4}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n          {value && <ColorBox color={value} />}\n        </Stack>\n      }\n    >\n      <SketchPicker\n        disableAlpha={true}\n        presetColors={[]}\n        color={value ? toHexColor(value) : undefined}\n        onChangeComplete={(c) =>\n          onChange({ valid: true, value: fromHexColor(c.hex) })\n        }\n      />\n    </Expandable>\n  );\n};\n\nexport function colorPickerParam(args: {\n  name: string;\n  defaultValue?: Color;\n  description?: string;\n}): ParamFunction<Color> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <ColorPickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { fromHexColor, isTransparent, mapImage } from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\n\nexport const backgroundColor = buildTransform({\n  name: 'Background Color',\n  description: 'Change all transparent pixles to the given color',\n  params: [\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [color] }) => {\n    const p = getSrcPixel(coord);\n    return isTransparent(p) ? color : p;\n  }),\n});\n","import { Button, Icon, Stack } from '@material-ui/core';\nimport React from 'react';\n\ninterface ImagePickerProps {\n  currentImageUrl?: string;\n  name?: string;\n  width?: number;\n  height?: number;\n  onChange: (imageUrl: string) => void;\n}\n\nexport const ImagePicker: React.FC<ImagePickerProps> = ({\n  currentImageUrl,\n  name,\n  onChange,\n}) => (\n  <Stack spacing={4}>\n    <Button\n      startIcon={<Icon>image</Icon>}\n      sx={{ maxWidth: '300px' }}\n      variant=\"contained\"\n      component=\"label\"\n    >\n      {name}\n      <input\n        type=\"file\"\n        hidden\n        accept=\"image/png,image/jpg,image/jpeg,image/gif\"\n        name=\"source-png\"\n        onChange={async (event) => {\n          const files = Array.from(event.target.files ?? []);\n          const file = files[0];\n          if (file) {\n            // Will be undefined if user clicked the cancel button\n            const baseImage = await readFile(file);\n            onChange(baseImage);\n          }\n        }}\n      />\n    </Button>\n    {currentImageUrl && (\n      <img\n        style={{ maxWidth: '300px', maxHeight: 'auto' }}\n        src={currentImageUrl}\n        alt=\"Source\"\n      ></img>\n    )}\n  </Stack>\n);\n\nconst readFile = (file: File) =>\n  new Promise<string>((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result as string);\n    reader.readAsDataURL(file);\n  });\n","import {\n  FormControl,\n  FormControlLabel,\n  Radio,\n  RadioGroup,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst RadioParam: React.FC<{\n  name: string;\n  options: readonly { name: string; value: any }[];\n  value?: any;\n  description?: string;\n  onChange: (v: ParamValue<any>) => void;\n}> = ({ name, options, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl component=\"fieldset\">\n        <RadioGroup\n          aria-label={name}\n          defaultValue={value}\n          onChange={(event) =>\n            onChange({ valid: true, value: event.target.value })\n          }\n        >\n          {options.map((t) => (\n            <FormControlLabel\n              value={t.value}\n              control={<Radio />}\n              label={t.name}\n            />\n          ))}\n        </RadioGroup>\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport function radioParam<T>(args: {\n  name: string;\n  options: readonly { name: string; value: T }[];\n  description?: string;\n  defaultValue?: T;\n}): ParamFunction<T> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <RadioParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          options={args.options}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport {\n  getPixel,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n  resizeImage,\n} from '../domain/utils';\nimport { imagePickerParam } from '../params/imagePickerParam';\nimport { radioParam } from '../params/radioParam';\n\nexport const backgroundImage = buildTransform({\n  name: 'Background Image',\n  description: 'Select another image to be used as a background or foreground',\n  params: [\n    imagePickerParam({\n      name: 'Image',\n    }),\n    radioParam({\n      name: 'Type',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n  ] as const,\n  fn: ({ image, parameters }) => {\n    const otherImage = resizeImage({\n      image: parameters[0].image,\n      newWidth: image.dimensions[0],\n      newHeight: image.dimensions[1],\n    });\n    const type = parameters[1];\n\n    return mapFrames(image, (data, frameIndex) => {\n      return mapCoords(image.dimensions, (coord) => {\n        const frameProgress = frameIndex / image.frames.length;\n        const otherImageFrame = Math.floor(\n          frameProgress * otherImage.frames.length\n        );\n        const otherImageSrc = getPixel({\n          image: otherImage,\n          frameIndex: otherImageFrame,\n          coord,\n        });\n\n        const src = getPixel({\n          image,\n          frameIndex,\n          coord,\n        });\n\n        if (type === 'background') {\n          // Only print the other image if the src image is transparent here\n          return isTransparent(src) ? otherImageSrc : src;\n        } else {\n          return isTransparent(otherImageSrc) ? src : otherImageSrc;\n        }\n      });\n    });\n  },\n});\n","import React from 'react';\nimport { ImagePicker } from '../components/ImagePicker';\nimport { readImage } from '../domain/run';\nimport { Image, ParamFunction } from '../domain/types';\n\ninterface ImagePickerParamsProps {\n  name: string;\n}\n\nexport function imagePickerParam({\n  name,\n}: ImagePickerParamsProps): ParamFunction<{ dataUrl: string; image: Image }> {\n  return {\n    name,\n    defaultValue: { valid: false },\n    fn: (params) => (\n      <ImagePicker\n        currentImageUrl={\n          params.value.valid ? params.value.value.dataUrl : undefined\n        }\n        name={name}\n        width={64}\n        height={64}\n        onChange={async (dataUrl) => {\n          const image = await readImage(dataUrl);\n          params.onChange({ valid: true, value: { dataUrl, image } });\n        }}\n      />\n    ),\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const bounce = buildTransform({\n  name: 'Bounce',\n  description: 'Make the image bounce up and down',\n  params: [\n    intParam({\n      name: 'Bounce Speed',\n      description: 'Positive number',\n      defaultValue: 5,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [speed] }) => ({\n      yOffset: Math.round(speed * Math.sin(animationProgress * 2 * Math.PI)),\n    }),\n    ({ computed: { yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x, y + yOffset])\n  ),\n});\n","import { concat, drop, pipe, reverse } from 'remeda';\nimport { buildTransform } from '../domain/types';\n\nexport const bounceAnimation = buildTransform({\n  name: 'Bounce Animation',\n  description: 'When the animation finishes, it will be replayed in reverse',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: concat(\n      image.frames,\n      pipe(image.frames, drop(1), reverse(), drop(1))\n    ),\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const circle = buildTransform({\n  name: 'Circle',\n  description: 'Make the image move in a circular pattern',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [radius] }) => ({\n      xOffset: Math.round(radius * Math.sin(-2 * Math.PI * animationProgress)),\n      yOffset: Math.round(radius * Math.cos(-2 * Math.PI * animationProgress)),\n    }),\n    ({ computed: { xOffset, yOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y + yOffset])\n  ),\n});\n","import {\n  Button,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\ninterface VariableLengthProps<T> {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  value?: T[];\n  description?: string;\n  onChange: (v: ParamValue<T>) => void;\n}\n\nconst VariableLengthParam: React.FC<VariableLengthProps<any>> = ({\n  name,\n  newParamText,\n  createNewParam,\n  value,\n  description,\n  onChange,\n}) => {\n  const [params, setParams] = React.useState<\n    { param: ParamFunction<any>; pValue: any }[]\n  >(\n    value === undefined\n      ? []\n      : value.map((v, idx) => ({ param: createNewParam(), pValue: v }))\n  );\n  return (\n    <Paper>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={1}>\n          <Typography variant=\"body2\">{name}</Typography>\n          <HelpTooltip description={description} />\n        </Stack>\n        {params.map(({ param, pValue }, idx) => {\n          const ele = param.fn({\n            value: { valid: true, value: pValue },\n            onChange: (newValue) => {\n              if (newValue.valid) {\n                const p = params.map((oldP, i) => {\n                  if (idx === i) {\n                    return {\n                      param,\n                      pValue: newValue.value,\n                    };\n                  }\n                  return oldP;\n                });\n                setParams(p);\n                onChange({\n                  valid: true,\n                  value: p.map((n) => n.pValue),\n                });\n              }\n            },\n          });\n\n          return (\n            <Stack direction=\"row\" key={`${name}-${idx}`}>\n              <IconButton\n                onClick={() => {\n                  const newParams = params.filter((x, i) => i !== idx);\n                  setParams(newParams);\n                  onChange({\n                    valid: true,\n                    value: newParams.map((n) => n.pValue),\n                  });\n                }}\n              >\n                <Icon>delete</Icon>\n              </IconButton>\n              {ele}\n            </Stack>\n          );\n        })}\n        <Button\n          variant=\"contained\"\n          onClick={() => {\n            const p = createNewParam();\n            const newParams = [\n              ...params,\n              {\n                param: p,\n                pValue: p.defaultValue.valid ? p.defaultValue.value : undefined,\n              },\n            ];\n            setParams(newParams);\n            if (p.defaultValue.valid) {\n              onChange({\n                valid: true,\n                value: newParams.map((n) => n.pValue),\n              });\n            }\n          }}\n        >\n          {newParamText}\n        </Button>\n      </Stack>\n    </Paper>\n  );\n};\n\nexport function variableLengthParam<T>(args: {\n  name: string;\n  newParamText: string;\n  createNewParam: () => ParamFunction<T>;\n  description?: string;\n  defaultValue?: T[];\n}): ParamFunction<T[]> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <VariableLengthParam\n          name={args.name}\n          newParamText={args.newParamText}\n          value={params.value.valid ? params.value.value : undefined}\n          createNewParam={args.createNewParam}\n          description={args.description}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport {\n  fromHexColor,\n  getAveragePixelValue,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colors = buildTransform({\n  name: 'Colors',\n  description: 'Make the image flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      chosenColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { chosenColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (isTransparent(srcPixel)) {\n        return [0, 0, 0, 0];\n      }\n\n      const gray = getAveragePixelValue(srcPixel);\n\n      return [\n        (gray * chosenColor[0]) / 255,\n        (gray * chosenColor[1]) / 255,\n        (gray * chosenColor[2]) / 255,\n        255,\n      ];\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF8D8B',\n  '#FED689',\n  '#88FF89',\n  '#87FFFF',\n  '#8BB5FE',\n  '#D78CFF',\n  '#FF8CFF',\n  '#FF68F7',\n  '#FE6CB7',\n  '#FF6968',\n].map(fromHexColor);\n\nexport const colorsBackground = buildTransform({\n  name: 'Colors Background',\n  description: 'Transparent pixels will flash different colors',\n  params: [\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [colors] }) => ({\n      bgColor: colors[Math.floor(animationProgress * colors.length)],\n    }),\n    ({ computed: { bgColor }, coord, getSrcPixel }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      // Make the transparent parts colorful\n      if (isTransparent(srcPixel)) {\n        return bgColor;\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import {\n  FormControl,\n  FormHelperText,\n  Stack,\n  TextField,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\ntype ParsedParam<T> =\n  | { valid: true; value: T }\n  | { valid: false; reason: string };\n\nconst FloatParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  parse: (s: string) => ParsedParam<number>;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, parse, onChange }) => {\n  const [val, setVal] = React.useState(\n    value === undefined ? undefined : value.toString()\n  );\n  const [invalidText, setInvalidText] = React.useState('');\n\n  const onBlur = () => {\n    if (val === undefined) {\n      // Only if no default value provided and no changes have happened\n      return;\n    }\n\n    if (value && val === value.toString()) {\n      return; // Don't fire an onChange event if things haven't changed\n    }\n    const n = parse(val);\n    if (n.valid) {\n      setInvalidText('');\n    } else {\n      setInvalidText(n.reason);\n    }\n    onChange(n);\n  };\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          error={!!invalidText}\n          value={val}\n          onBlur={onBlur}\n          onChange={(e) => {\n            setVal(e.target.value);\n          }}\n        />\n        {invalidText && <FormHelperText>{invalidText}</FormHelperText>}\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const floatParam = (args: {\n  name: string;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  description?: string;\n}): ParamFunction<number> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => {\n    const { min, max } = args;\n    const parse = (s: string): ParsedParam<number> => {\n      const n = parseFloat(s);\n      if (isNaN(n) || n.toString() !== s) {\n        return { valid: false, reason: 'Must be a number' };\n      }\n      if (min !== undefined && n < min) {\n        return {\n          valid: false,\n          reason: `Must be greater than or equal to ${min}`,\n        };\n      }\n      if (max !== undefined && n > max) {\n        return { valid: false, reason: `Must be less than or equal to ${max}` };\n      }\n      return { valid: true, value: n };\n    };\n\n    return (\n      <FloatParam\n        name={args.name}\n        description={args.description}\n        parse={parse}\n        onChange={params.onChange}\n        value={params.value.valid ? params.value.value : undefined}\n      />\n    );\n  },\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const doubleVision = buildTransform({\n  name: 'Double Vision',\n  description: 'See the image in double',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: amplitude * Math.sin(-2 * Math.PI * animationProgress),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) => {\n      const dir = x % 2 === 0 ? -1 : 1;\n      return getSrcPixel([x + Math.round(dir * xOffset), y]);\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const expand = buildTransform({\n  name: 'Expand',\n  description: 'Make the image grow and shrink',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      animationProgress,\n      parameters: [radius],\n    }) => ({\n      dist: Math.cos(animationProgress * 2 * Math.PI) * radius,\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, dist },\n      dimensions: [width, height],\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      // Kind of follows the same algorithm as resize, except the amount is dynamic\n      const xRatio = (x - centerX) / width;\n      const yRatio = (y - centerY) / height;\n\n      const xOffset = Math.floor(dist * xRatio);\n      const yOffset = Math.round(dist * yRatio);\n      return getSrcPixel([x - xOffset, y - yOffset]);\n    }\n  ),\n});\n","import { buildTransform, Coord, Image } from '../domain/types';\nimport { mapImage, setPixel, TRANSPARENT_COLOR } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const fill = buildTransform({\n  disabled: true,\n  name: 'Fill Transparent',\n  description:\n    'Makes transparent all pixels of similar color surrounding a point',\n  params: [\n    sliderParam({\n      name: 'Tolerance',\n      defaultValue: 50,\n      min: 0,\n      max: 100,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [tolerance] }) => {\n    const matchP = getSrcPixel([0, 0]);\n\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    return [0, 0, 0, 0];\n  }),\n});\n\nconst fillFn = (image: Image, frameIndex: number, coord: Coord) => {\n  const visited = (() => {\n    const set = new Set<string>();\n    return {\n      set: (x: number, y: number) => {\n        set.add(`${x}-${y}`);\n      },\n      has: (x: number, y: number) => set.has(`${x}-${y}`),\n    };\n  })();\n\n  const set = (x: number, y: number) =>\n    setPixel({\n      image,\n      frameIndex,\n      color: TRANSPARENT_COLOR,\n      coord: [x - 1, y],\n    });\n\n  const s: { x1: number; x2: number; y: number; dy: number }[] = [];\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1], dy: 1 });\n  s.push({ x1: coord[0], x2: coord[0], y: coord[1] - 1, dy: -1 });\n\n  while (s.length > 0) {\n    const n = s.pop()!;\n    let x = n.x1;\n    let y = n.y;\n    if (visited.has(x, y)) {\n      while (visited.has(x - 1, y)) {\n        set(x - 1, y);\n        x = x - 1;\n      }\n    }\n\n    if (x < n.x1) {\n      s.push({ x1: x, x2: n.x1 - 1, y: y - n.dy, dy: n.dy * -1 });\n    }\n\n    while (n.x1 < n.x2) {\n      while (visited.has(n.x1, y)) {\n        set(n.x1, y);\n      }\n    }\n  }\n};\n\n/*\nfn fill(x, y):\n  if not Inside(x, y) then return\n  let s = new empty queue or stack\n  Add (x, x, y, 1) to s\n  Add (x, x, y - 1, -1) to s\n  while s is not empty:\n    Remove an (x1, x2, y, dy) from s\n    let x = x1\n    if Inside(x, y):\n      while Inside(x - 1, y):\n        Set(x - 1, y)\n        x = x - 1\n    if x < x1:\n      Add (x, x1-1, y-dy, -dy) to s\n    while x1 < x2:\n      while Inside(x1, y):\n        Set(x1, y)\n        x1 = x1 + 1\n      Add (x, x1 - 1, y+dy, dy) to s\n      if x1 - 1 > x2:\n        Add (x2 + 1, x1 - 1, y-dy, -dy)\n      while x1 < x2 and not Inside(x1, y):\n        x1 = x1 + 1\n      x = x1\n*/\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\n// Probably still needs work -- the inner pixels get all funky still\nexport const fisheye = buildTransform({\n  name: 'Fisheye',\n  description: 'Make the image grow and shrink in a distorted fashion',\n  params: [\n    intParam({\n      name: 'Radius',\n      description: 'Positive Number',\n      defaultValue: 10,\n      min: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      animationProgress,\n      dimensions: [width, height],\n      parameters: [radius],\n    }) => {\n      const expanding = animationProgress < 0.5;\n      return {\n        dist: (expanding ? animationProgress : 1 - animationProgress) * radius,\n        centerX: width / 2,\n        centerY: height / 2,\n      };\n    },\n    ({ computed: { dist, centerX, centerY }, coord: [x, y], getSrcPixel }) => {\n      const angle = Math.atan2(centerY - y, centerX - x);\n\n      const xOffset = Math.round(dist * Math.cos(angle));\n      const yOffset = Math.round(dist * Math.sin(angle));\n      return getSrcPixel([x + xOffset, y + yOffset]);\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { adjustSaturation, mapImage } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nconst MAX_GRID_SIZE = 64;\n\nexport const grid = buildTransform({\n  name: 'Grid',\n  description: 'Removes the color from all pixels not aligned with a grid',\n  params: [\n    sliderParam({\n      name: 'Grid Size',\n      description: 'The length of each square in the grid',\n      defaultValue: 24,\n      min: 2,\n      max: MAX_GRID_SIZE,\n      step: 2,\n    }),\n    sliderParam({\n      name: 'Grid Angle',\n      defaultValue: 45,\n      min: 0,\n      max: 90,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [gridSize, gridAngle] }) => {\n    const p = getSrcPixel(coord);\n    const [x, y] = coord;\n\n    let isOnGrid = false;\n    if (gridAngle % 90 === 0) {\n      // Vertical/Horizonal lines\n      isOnGrid = x % gridSize === 0 || y % gridSize === 0;\n    } else {\n      // Threshold should be between 0.13 and 0.03, smaller for larger grid sizes.\n      // Larger threshold = thicker lines.\n      const threshold =\n        ((MAX_GRID_SIZE - gridSize) / MAX_GRID_SIZE) * 0.1 + 0.03;\n\n      const onGrid = (angleDegrees: number) => {\n        const n = (1 / gridSize) * (y - Math.tan(toRad(angleDegrees)) * x);\n        return Math.abs(Math.round(n) - n) < threshold;\n      };\n\n      isOnGrid = onGrid(gridAngle) || onGrid(gridAngle + 90);\n    }\n\n    return isOnGrid ? p : adjustSaturation(p, -100);\n  }),\n});\n\nconst toRad = (degrees: number) => (degrees * Math.PI) / 180;\n","import { Stack, Typography } from '@material-ui/core';\nimport * as convert from 'color-convert';\nimport React from 'react';\nimport { HuePicker } from 'react-color';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\nimport { toHexColor } from '../domain/utils';\n\nconst HuePickerParam: React.FC<{\n  name: string;\n  value?: number;\n  description?: string;\n  onChange: (v: ParamValue<number>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const hexColor =\n    value === undefined\n      ? undefined\n      : toHexColor([...convert.hsl.rgb([value, 255, 255]), 255]);\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <HuePicker\n        color={hexColor}\n        onChangeComplete={({ hsl }) => onChange({ valid: true, value: hsl.h })}\n      />\n    </Stack>\n  );\n};\n\nexport function huePickerParam(args: {\n  name: string;\n  defaultValue?: number;\n  description?: string;\n}): ParamFunction<number> {\n  return {\n    name: args.name,\n    defaultValue: args.defaultValue\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n    fn: (params) => {\n      return (\n        <HuePickerParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueChange = buildTransform({\n  name: 'Hue Change',\n  description: 'Change the hue of the image to some other color',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [newHue, amount] }) =>\n    shiftTowardsHue(getSrcPixel(coord), newHue, amount)\n  ),\n});\n","import { FormControl, Stack, TextField, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst TextParam: React.FC<{\n  name: string;\n  value?: string;\n  description?: string;\n  onChange: (v: ParamValue<string>) => void;\n}> = ({ name, value, description, onChange }) => {\n  const [val, setVal] = React.useState(value);\n\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\">{name}</Typography>\n        <HelpTooltip description={description} />\n      </Stack>\n      <FormControl>\n        <TextField\n          value={val}\n          onChange={(e) => setVal(e.target.value)}\n          onBlur={() =>\n            onChange(val ? { valid: true, value: val } : { valid: false })\n          }\n        />\n      </FormControl>\n    </Stack>\n  );\n};\n\nexport const textParam = (args: {\n  name: string;\n  description?: string;\n  defaultValue?: string;\n}): ParamFunction<string> => ({\n  name: args.name,\n  defaultValue:\n    args.defaultValue !== undefined\n      ? { valid: true, value: args.defaultValue }\n      : { valid: false },\n  fn: (params) => (\n    <TextParam\n      name={args.name}\n      description={args.description}\n      onChange={params.onChange}\n      value={params.value.valid ? params.value.value : undefined}\n    />\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage, shiftHue } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const hueShift = buildTransform({\n  name: 'Hue Shift',\n  description: 'Shift the hue of each pixel in the image by some amount',\n  params: [\n    sliderParam({\n      name: 'Amount',\n      description: 'How much to shift the hue of each pixel',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n  ] as const,\n  fn: mapImage(({ coord, getSrcPixel, parameters: [amount] }) =>\n    shiftHue(getSrcPixel(coord), (amount / 100) * 360)\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { isTransparent, mapImage, shiftTowardsHue } from '../domain/utils';\nimport { huePickerParam } from '../params/huePickerParam';\n\nexport const hueShiftPulse = buildTransform({\n  name: 'Hue Shift Pulse',\n  description: 'Shift the hue to the given value in a pulsating manner',\n  params: [\n    huePickerParam({\n      name: 'Hue',\n      defaultValue: 180,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, frameCount, frameIndex, parameters: [hue] }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      if (isBackground) {\n        return srcPixel;\n      }\n\n      const amount = Math.abs(Math.sin(Math.PI * (frameIndex / frameCount)));\n      return shiftTowardsHue(srcPixel, hue, amount * 360);\n    }\n  ),\n});\n","import seedrandom from 'seedrandom';\nimport { buildTransform, Color } from '../domain/types';\nimport {\n  getPixelFromSource,\n  isTransparent,\n  mapCoords,\n  mapFrames,\n} from '../domain/utils';\nimport { textParam } from '../params/textParam';\n\nconst lightningIntensities: Color[] = [\n  [0, 15, 40, 255], // dark color\n  [150, 150, 175, 255],\n  [180, 180, 205, 255],\n  [210, 210, 235, 255],\n];\n\nexport const lightning = buildTransform({\n  name: 'Lightning',\n  description: 'Make the background look like a thunderstorm',\n  params: [\n    textParam({\n      name: 'Random Seed',\n      description:\n        'Can be anything. Will determine the randomness of the lightning.',\n      defaultValue: 'lightning',\n    }),\n  ] as const,\n  fn: ({ image, parameters: [seed] }) => {\n    const random = seedrandom(seed);\n    return mapFrames(image, (data) => {\n      const i = random();\n      const flashIntensity = i < 0.9 ? 0 : i < 0.95 ? 1 : i < 0.98 ? 2 : 3;\n\n      return mapCoords(image.dimensions, (coord) => {\n        const src = getPixelFromSource(image.dimensions, data, coord);\n\n        if (isTransparent(src)) {\n          return lightningIntensities[flashIntensity];\n        }\n\n        if (flashIntensity > 0) {\n          // We're flashing, so brighten up the image a little\n          const icf = 1.02 * flashIntensity;\n          return [src[0] * icf, src[1] * icf, src[2] * icf, src[3]];\n        }\n\n        // No lightning\n        return src;\n      });\n    });\n  },\n});\n","import * as convert from 'color-convert';\nimport { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const nuke = buildTransform({\n  name: 'Nuke',\n  description: 'Oh no...',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const threshold = animationProgress * 255;\n    const [r, g, b, a] = getSrcPixel(coord);\n    const [h, s, l] = convert.rgb.hsl(r, g, b);\n    const [newR, newG, newB] = convert.hsl.rgb([h, s, l > threshold ? l : 0]);\n    return [newR, newG, newB, l > threshold ? a : 0];\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImage,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const party = buildTransform({\n  name: 'Party',\n  description: 'Shift the hue of the image over the course of the animation',\n  params: [\n    radioParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description: 'How strong the effect is',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n    }),\n    sliderParam({\n      name: 'Shift Speed',\n      description: 'Controls how quickly it shifts through the various colors',\n      min: 1,\n      max: 12,\n      defaultValue: 1,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      animationProgress,\n      parameters: [type, amount, shiftSpeed],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n      const isBackground = isTransparent(srcPixel);\n\n      const newH = (animationProgress * shiftSpeed * 360) % 360;\n\n      if (isBackground && type === 'background') {\n        return colorFromHue(newH);\n      }\n\n      if (!isBackground && type === 'foreground') {\n        return shiftTowardsHue(srcPixel, newH, amount);\n      }\n\n      return srcPixel;\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { isTransparent, mapImage, shiftHue } from '../domain/utils';\n\nexport const partyTwo = buildTransform({\n  name: 'Party Two',\n  description:\n    'Shift the hue of each individual pixel over the course of the animation',\n  params: [],\n  fn: mapImage(({ coord, getSrcPixel, animationProgress }) => {\n    const srcPixel = getSrcPixel(coord);\n    const isBackground = isTransparent(srcPixel);\n\n    return isBackground\n      ? srcPixel\n      : shiftHue(srcPixel, animationProgress * 360);\n  }),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const pinwheel = buildTransform({\n  name: 'Pinwheel',\n  description: 'Create a pinwheel of colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'Colors for the pinwheel',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ parameters: [groupCount, colors, offsetX, offsetY] }) => {\n      const ribbonCount = colors.length * groupCount;\n      const ribbonArcDegrees = Math.round(360 / ribbonCount);\n      // Need to make sure ribbonCount is always a multiple of the number of images, otherwise we\n      //  won't get a smooth transition.\n      // We'll cut off colors from the end of the list until we get an even multiple.\n      let colorsLength = colors.length;\n      while ((ribbonCount / colorsLength).toFixed(2).slice(-2) !== '00') {\n        colorsLength -= 1;\n      }\n\n      return {\n        colorsLength,\n        ribbonArcDegrees,\n      };\n    },\n    ({\n      computed: { ribbonArcDegrees, colorsLength },\n      coord,\n      dimensions,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, colors, offsetX, offsetY],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const center: Coord = [\n        dimensions[0] / 2 + offsetX,\n        dimensions[1] / 2 - offsetY,\n      ];\n      const pointAngle = calculateAngle(coord, center);\n\n      const colorIdx = Math.floor(pointAngle / ribbonArcDegrees) % colorsLength;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorsLength) + colorIdx) %\n        colorsLength;\n      return colors[idx];\n    }\n  ),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport {\n  calculateAngle,\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const pinwheelParty = buildTransform({\n  name: 'Pinwheel Party',\n  description: 'Create a pinwheel of party colors',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the pinwheel',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the pinwheel',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({\n      dimensions: [width, height],\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n    }) => {\n      const center: Coord = [width / 2 + offsetX, height / 2 - offsetY];\n      return { center };\n    },\n    ({\n      computed: { center },\n      coord,\n      animationProgress,\n      getSrcPixel,\n      parameters: [groupCount, type, amount],\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      const isBackground = isTransparent(srcPixel);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return srcPixel;\n      }\n\n      const pointAngle = calculateAngle(coord, center);\n      const newH = (pointAngle * groupCount + animationProgress * 360) % 360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(srcPixel, newH, amount);\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildTransform } from '../domain/types';\nimport {\n  fromHexColor,\n  isTransparent,\n  mapImageWithPrecompute,\n} from '../domain/utils';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { intParam } from '../params/intParam';\nimport { sliderParam } from '../params/sliderParam';\nimport { variableLengthParam } from '../params/variableLengthParam';\n\nconst DEFAULT_COLORS = [\n  '#FF0000',\n  '#FF9600',\n  '#FFFF00',\n  '#00FF00',\n  '#00FF96',\n  '#00FFFF',\n  '#0000FF',\n  '#B400FF',\n].map(fromHexColor);\n\nexport const radiance = buildTransform({\n  name: 'Radiance',\n  description: 'Radiate colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each color is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    variableLengthParam({\n      name: 'Colors',\n      newParamText: 'New Color',\n      description: 'The colors that make up each ring',\n      defaultValue: DEFAULT_COLORS,\n      createNewParam: () =>\n        colorPickerParam({\n          name: 'Color',\n        }),\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], parameters: [groupCount, colors] }) => ({\n      colorList: range(0, groupCount).flatMap(() => colors),\n      centerX: width / 2,\n      centerY: height / 2,\n    }),\n    ({\n      computed: { centerX, centerY, colorList },\n      dimensions: [width, height],\n      coord,\n      animationProgress,\n      parameters: [_groupCount, _colors, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const srcPixel = getSrcPixel(coord);\n\n      if (!isTransparent(srcPixel)) {\n        return srcPixel;\n      }\n\n      // Make the transparent parts colorful\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const maxDist = Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      );\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const colorIdx =\n        Math.floor((1 - distFromCenter / maxDist) * colorList.length) %\n        colorList.length;\n\n      // Increment colorIdx based on current frame progress\n      const idx =\n        (Math.floor(animationProgress * colorList.length) + colorIdx) %\n        colorList.length;\n      return colorList[idx];\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport {\n  colorFromHue,\n  isTransparent,\n  mapImageWithPrecompute,\n  shiftTowardsHue,\n} from '../domain/utils';\nimport { intParam } from '../params/intParam';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const radianceParty = buildTransform({\n  name: 'Radiance Party',\n  description: 'Radiate party colors out in rings',\n  params: [\n    sliderParam({\n      name: 'Group Count',\n      description: 'How many times each rainbow is repeated',\n      defaultValue: 1,\n      min: 1,\n      max: 24,\n    }),\n    radioParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Amount',\n      description:\n        'How strong the effect is. Only applies when type = foreground.',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 75,\n    }),\n    intParam({\n      name: 'Offset X',\n      description: 'Change the horizontal center of the radiance',\n      defaultValue: 0,\n    }),\n    intParam({\n      name: 'Offset Y',\n      description: 'Change the vertical center of the radiance',\n      defaultValue: 0,\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height] }) => ({\n      centerX: width / 2,\n      centerY: height / 2,\n      maxDist: Math.sqrt(\n        (width / 2) * (width / 2) + (height / 2) * (height / 2)\n      ),\n    }),\n    ({\n      computed: { centerX, centerY, maxDist },\n      coord,\n      animationProgress,\n      parameters: [groupCount, type, amount, offsetX, offsetY],\n      getSrcPixel,\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      const [x, y] = coord;\n      const xRelCenter = x - centerX - offsetX;\n      const yRelCenter = y - centerY + offsetY;\n\n      const distFromCenter = Math.sqrt(\n        yRelCenter * yRelCenter + xRelCenter * xRelCenter\n      );\n\n      const newH =\n        ((1 - distFromCenter / maxDist) * 360 * groupCount +\n          360 * animationProgress) %\n        360;\n\n      return isBackground\n        ? colorFromHue(newH)\n        : shiftTowardsHue(src, newH, amount);\n    }\n  ),\n});\n","import { range } from 'remeda';\nimport { buildTransform } from '../domain/types';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const repeatAnimation = buildTransform({\n  name: 'Repeat Animation',\n  description: 'Repeats the current animation some number of times',\n  params: [\n    sliderParam({\n      name: 'Number of Repeats',\n      defaultValue: 1,\n      min: 1,\n      max: 50,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [numRepeats] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * (numRepeats + 1)).map(\n      (i) => image.frames[i % image.frames.length]\n    ),\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { resizeImage as resizeImageUtil } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const resizeImage = buildTransform({\n  name: 'Resize Image',\n  description:\n    'Change the dimensions of the image. ' +\n    'If bigger than original, the extra space will be transparent. ' +\n    'If smaller, the image will be cropped. ',\n  params: [\n    intParam({\n      name: 'Width',\n      description:\n        'Set to 0 when height is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n    intParam({\n      name: 'Height',\n      description:\n        'Set to 0 when width is set to non-zero to keep the same aspect ratio',\n      defaultValue: 128,\n      min: 0,\n    }),\n  ] as const,\n  fn: ({ image, parameters: [resizeToWidth, resizeToHeight] }) => {\n    const [oldWidth, oldHeight] = image.dimensions;\n    const newWidth =\n      resizeToWidth === 0\n        ? Math.ceil((oldWidth / oldHeight) * resizeToHeight)\n        : resizeToWidth;\n    const newHeight =\n      resizeToHeight === 0\n        ? Math.ceil((oldHeight / oldWidth) * resizeToWidth)\n        : resizeToHeight;\n    return resizeImageUtil({\n      image,\n      newWidth,\n      newHeight,\n    });\n  },\n});\n","import { reverse } from 'remeda';\nimport { buildTransform } from '../domain/types';\n\nexport const reverseAnimation = buildTransform({\n  name: 'Reverse Animation',\n  description: 'Reverses the animation',\n  params: [],\n  fn: ({ image }) => ({\n    dimensions: image.dimensions,\n    frames: reverse(image.frames),\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\nimport { intParam } from '../params/intParam';\n\nexport const ripple = buildTransform({\n  name: 'Ripple',\n  description: 'Create a ripple effect, like water',\n  params: [\n    floatParam({\n      name: 'Amplitude',\n      defaultValue: 10,\n      description: 'How strong the ripple effect should be',\n    }),\n    intParam({\n      name: 'Period',\n      defaultValue: 2,\n      min: 0,\n      description: 'How many ripples you want. Positive number.',\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress }) => ({\n      shift: animationProgress * 2 * Math.PI,\n    }),\n    ({\n      computed: { shift },\n      coord: [x, y],\n      dimensions: [, height],\n      parameters: [amplitude, period],\n      getSrcPixel,\n    }) => {\n      const offset = Math.round(\n        amplitude * Math.sin((y / height) * period * Math.PI + shift)\n      );\n\n      return getSrcPixel([x + offset, y]);\n    }\n  ),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const rotate = buildTransform({\n  name: 'Rotate',\n  description: 'Make the image rotate about the center point',\n  params: [\n    radioParam({\n      name: 'Direction',\n      defaultValue: -1,\n      options: [\n        { name: 'Clockwise', value: -1 },\n        { name: 'Counter-Clockwise', value: 1 },\n      ],\n    }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [sign] }) => {\n      const amount = animationProgress * (sign || 1);\n      return {\n        cos: Math.cos(2 * Math.PI * amount),\n        sin: Math.sin(2 * Math.PI * amount),\n      };\n    },\n    ({\n      dimensions: [width, height],\n      coord: [x, y],\n      computed: { cos, sin },\n      getSrcPixel,\n    }) => {\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const xRelCenter = x - centerX;\n      const yRelCenter = y - centerY;\n\n      const newCoord: Coord = [\n        Math.round(centerX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(centerY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildTransform, Coord } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\n\nexport const roxbury = buildTransform({\n  name: 'Roxbury',\n  description: \"Baby, don't hurt me\",\n  params: [],\n  fn: mapImageWithPrecompute(\n    ({ dimensions: [width, height], animationProgress }) => {\n      // 4 phases:\n      //  0 -> freeze\n      //  1 -> rotate clockwise\n      //  2 -> freeze\n      //  3 -> rotate counter-clockwise\n      const phase = Math.floor(animationProgress * 4);\n      const phaseIdx = (animationProgress - phase / 4) * 4;\n\n      const maxAngle = (Math.PI / 2) * 0.2; // 40% of 90 degrees\n\n      const angle =\n        phase === 0\n          ? 0\n          : phase === 1\n          ? phaseIdx * maxAngle // Rotate clockwise\n          : phase === 2\n          ? maxAngle // Freeze!\n          : (1 - phaseIdx) * maxAngle; // Rotate counter-clockwise\n\n      return {\n        angle,\n        cos: Math.cos(-angle * 1.35),\n        sin: Math.sin(-angle * 1.35),\n        rotatePointX: width * 0.25,\n        rotatePointY: height * 0.7,\n      };\n    },\n    ({\n      computed: { angle, cos, sin, rotatePointX, rotatePointY },\n      coord: [x, y],\n      getSrcPixel,\n    }) => {\n      const xRelCenter = Math.floor(x - rotatePointX + 8 * Math.sin(angle));\n      const yRelCenter = Math.floor(y - rotatePointY + 8 * Math.cos(angle));\n\n      const newCoord: Coord = [\n        Math.round(rotatePointX + xRelCenter * cos - yRelCenter * sin),\n        Math.round(rotatePointY + yRelCenter * cos + xRelCenter * sin),\n      ];\n\n      return getSrcPixel(newCoord);\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImageWithPrecompute } from '../domain/utils';\nimport { floatParam } from '../params/floatParam';\n\nexport const shake = buildTransform({\n  name: 'Shake',\n  description: 'Make the image shake back and forth',\n  params: [\n    floatParam({ name: 'Amplitude', defaultValue: 10, min: 0 }),\n  ] as const,\n  fn: mapImageWithPrecompute(\n    ({ animationProgress, parameters: [amplitude] }) => ({\n      xOffset: Math.round(\n        amplitude * Math.cos(animationProgress * 2 * Math.PI)\n      ),\n    }),\n    ({ computed: { xOffset }, coord: [x, y], getSrcPixel }) =>\n      getSrcPixel([x + xOffset, y])\n  ),\n});\n","import { range } from 'remeda';\nimport { buildTransform } from '../domain/types';\nimport { getPixelFromSource, mapCoords } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\n\nexport const slowAnimation = buildTransform({\n  name: 'Slow Animation',\n  description: 'Attempts to slow the animation by adding intermediate frames',\n  params: [\n    radioParam({\n      name: 'Interpolation Type',\n      options: [\n        { name: 'Basic', value: 'basic' },\n        { name: 'Smooth', value: 'smooth' },\n      ],\n      defaultValue: 'basic',\n      description:\n        'With basic interpolation, frames are simply duplicated. ' +\n        'With smooth interpolation, intermediate frames are the average of their surrounding frames.',\n    }),\n  ],\n  fn: ({ image, parameters: [type] }) => ({\n    dimensions: image.dimensions,\n    frames: range(0, image.frames.length * 2 - 1).map((i) => {\n      // IE: if OF frame count = 4 (with indexes [0, 1, 2, 3])\n      // Result = [0, 0+1, 1, 1+2, 2, 2+3, 3], 3+4, 4]\n\n      // Even numbered frames are just the original frames\n      if (i % 2 === 0) {\n        return image.frames[i / 2];\n      }\n\n      const ogFrameIdx = (i - 1) / 2;\n\n      if (type === 'basic') {\n        // Intermediate frame is simply the previous OG frame\n        return image.frames[ogFrameIdx];\n      }\n\n      // Smooth interpolation means intermediate frames are an average of the surrounding frames\n      return mapCoords(image.dimensions, (coord) => {\n        const [r1, g1, b1, a1] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx],\n          coord\n        );\n        const [r2, g2, b2, a2] = getPixelFromSource(\n          image.dimensions,\n          image.frames[ogFrameIdx + 1],\n          coord\n        );\n        return [(r1 + r2) / 2, (g1 + g2) / 2, (b1 + b2) / 2, (a1 + a2) / 2];\n      });\n    }),\n  }),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\n\nexport const spin = buildTransform({\n  disabled: true,\n  name: 'Spin',\n  description: 'Make the image spin in a 3D-like way',\n  params: [],\n  fn: mapImage(\n    ({ image, coord: [x, y], frameCount, frameIndex, getSrcPixel }) => {\n      const centerX = image.dimensions[0] / 2;\n      const idx = frameIndex / frameCount;\n      // 0% -> 0\n      // 25% -> Pi / 2\n      // 50% -> Pi\n      // 75% -> 3/2 * Pi\n      // 100% -> 2 * Pi\n      const angle = 2 * Math.PI * idx;\n      const newX = Math.round(centerX + x * Math.cos(angle));\n      return getSrcPixel([newX, y]);\n    }\n  ),\n});\n\n/*\nx = centerX\nnewX = centerX\n\nx = 0, idx = 0, angle = cos(0) = 1, relX = centerX - 0\n  newX = 0\nx = 0, idx = 25%, angle = cos(45deg) ~ 0.5, relX = centerX - 0\n  newX = centerX - cos(45) * x\nx = 0, idx = 50%, angle = cos(90deg) = 0, relX = centerX - 0\n  newX = (centerX - 0)\n\nx = 25%, idx = 25%, angle ~ 0.5, relX = centerX - 0\n  newX = centerX - angle * x\n*/\n","import { buildTransform } from '../domain/types';\nimport { isTransparent, mapImage } from '../domain/utils';\nimport { radioParam } from '../params/radioParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const staticc = buildTransform({\n  name: 'Static',\n  description: 'Adds random static to the image',\n  params: [\n    radioParam({\n      name: 'Type',\n      description: 'Whether to apply the party to the foreground or background',\n      defaultValue: 'background',\n      options: [\n        {\n          name: 'Background',\n          value: 'background',\n        },\n        {\n          name: 'Foreground',\n          value: 'foreground',\n        },\n      ],\n    }),\n    sliderParam({\n      name: 'Strength',\n      description: 'Higher number increases the amount of static pixels',\n      defaultValue: 25,\n      min: 5,\n      max: 100,\n      step: 5,\n    }),\n  ],\n  fn: mapImage(\n    ({ coord, getSrcPixel, parameters: [type, strength], random }) => {\n      const src = getSrcPixel(coord);\n\n      const isBackground = isTransparent(src);\n\n      if (type === 'foreground' ? isBackground : !isBackground) {\n        return src;\n      }\n\n      if (isBackground && type === 'background') {\n        const inverse = Math.ceil(random() * 100) < strength;\n        const grey = Math.ceil(random() * 255);\n\n        return inverse ? [grey, grey, grey, 255] : src;\n      }\n\n      const isStatic = Math.ceil(random() * 100) < strength;\n      const grey = Math.ceil(random() * 255);\n\n      return isStatic ? [grey, grey, grey, src[3]] : src;\n    }\n  ),\n});\n","import { Checkbox, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { HelpTooltip } from '../components/HelpTooltip';\nimport { ParamFunction, ParamValue } from '../domain/types';\n\nconst CheckboxParam: React.FC<{\n  name: string;\n  value?: boolean;\n  description?: string;\n  onChange: (v: ParamValue<boolean>) => void;\n}> = ({ name, value, description, onChange }) => {\n  return (\n    <Stack spacing={1}>\n      <Stack direction=\"row\" spacing={1}>\n        <Typography variant=\"body2\" paddingTop=\"0.5rem\">\n          {name}\n        </Typography>\n        <span style={{ paddingTop: '0.5rem' }}>\n          <HelpTooltip description={description} />\n        </span>\n        <Checkbox\n          aria-label={name}\n          checked={value}\n          onChange={(e, value) => onChange({ valid: true, value })}\n        />\n      </Stack>\n    </Stack>\n  );\n};\n\nexport function checkboxParam(args: {\n  name: string;\n  defaultValue?: boolean;\n  description?: string;\n}): ParamFunction<boolean> {\n  return {\n    name: args.name,\n    defaultValue:\n      args.defaultValue !== undefined\n        ? { valid: true, value: args.defaultValue }\n        : { valid: false },\n    fn: (params) => {\n      return (\n        <CheckboxParam\n          name={args.name}\n          value={params.value.valid ? params.value.value : undefined}\n          onChange={params.onChange}\n          description={args.description}\n        />\n      );\n    },\n  };\n}\n","import { buildTransform } from '../domain/types';\nimport { fromHexColor, mapImage, colorDiff } from '../domain/utils';\nimport { checkboxParam } from '../params/checkboxParam';\nimport { colorPickerParam } from '../params/colorPickerParam';\nimport { sliderParam } from '../params/sliderParam';\n\nexport const transparency = buildTransform({\n  name: 'Transparency',\n  description: 'Set certain pixels to be transparent',\n  params: [\n    checkboxParam({\n      name: 'Matches are Transparent',\n      description:\n        'If checked, then pixels matching this color will be made transparent. If not checked, non-matching pixels are transparent.',\n      defaultValue: true,\n    }),\n    colorPickerParam({\n      name: 'Color',\n      defaultValue: fromHexColor('#000000'),\n    }),\n    sliderParam({\n      name: 'Tolerance',\n      description:\n        'A higher number will mean colors that are \"close\" to the chosen color will be transparent. (0 - 100)',\n      defaultValue: 10,\n      min: 0,\n      max: 100,\n      step: 5,\n    }),\n  ] as const,\n  fn: mapImage(\n    ({\n      coord,\n      getSrcPixel,\n      parameters: [matchesTransparent, selectedColor, tolerance],\n    }) => {\n      const src = getSrcPixel(coord);\n\n      const withinTolerance = colorDiff(src, selectedColor) * 100 <= tolerance;\n\n      if (matchesTransparent ? withinTolerance : !withinTolerance) {\n        return [src[0], src[1], src[2], 0];\n      }\n      return src;\n    }\n  ),\n});\n","import { buildTransform } from '../domain/types';\nimport { mapImage } from '../domain/utils';\nimport { intParam } from '../params/intParam';\n\nexport const transpose = buildTransform({\n  name: 'Transpose',\n  description: 'Move the image left or right, up or down',\n  params: [\n    intParam({ name: 'X', defaultValue: 0 }),\n    intParam({ name: 'Y', defaultValue: 0 }),\n  ] as const,\n  fn: mapImage(({ coord: [x, y], getSrcPixel, parameters: [transX, transY] }) =>\n    getSrcPixel([x + transX, y + transY])\n  ),\n});\n","import { pipe, reject, sortBy } from 'remeda';\nimport { ParamFunction, Transform } from '../domain/types';\nimport { assert } from '../domain/utils';\nimport { adjustImage } from './adjust-image';\nimport { backgroundColor } from './background-color';\nimport { backgroundImage } from './background-image';\nimport { bounce } from './bounce';\nimport { bounceAnimation } from './bounce-animation';\nimport { circle } from './circle';\nimport { colors } from './colors';\nimport { colorsBackground } from './colors-background';\nimport { doubleVision } from './double-vision';\nimport { expand } from './expand';\nimport { fill } from './fill';\nimport { fisheye } from './fisheye';\nimport { grid } from './grid';\nimport { hueChange } from './hue-change';\nimport { hueShift } from './hue-shift';\nimport { hueShiftPulse } from './hue-shift-pulse';\nimport { lightning } from './lightning';\nimport { nuke } from './nuke';\nimport { party } from './party';\nimport { partyTwo } from './party-two';\nimport { pinwheel } from './pinwheel';\nimport { pinwheelParty } from './pinwheel-party';\nimport { radiance } from './radiance';\nimport { radianceParty } from './radiance-party';\nimport { repeatAnimation } from './repeat-animation';\nimport { resizeImage } from './resize-image';\nimport { reverseAnimation } from './reverse-animation';\nimport { ripple } from './ripple';\nimport { rotate } from './rotate';\nimport { roxbury } from './roxbury';\nimport { shake } from './shake';\nimport { slowAnimation } from './slow-animation';\nimport { spin } from './spin';\nimport { staticc } from './static';\nimport { transparency } from './transparency';\nimport { transpose } from './transpose';\n\nexport const POSSIBLE_TRANSFORMS = pipe(\n  [\n    adjustImage,\n    backgroundColor,\n    backgroundImage,\n    bounce,\n    bounceAnimation,\n    circle,\n    colors,\n    colorsBackground,\n    doubleVision,\n    expand,\n    fill,\n    fisheye,\n    grid,\n    hueChange,\n    hueShift,\n    hueShiftPulse,\n    lightning,\n    nuke,\n    party,\n    partyTwo,\n    pinwheel,\n    pinwheelParty,\n    radiance,\n    radianceParty,\n    repeatAnimation,\n    resizeImage,\n    reverseAnimation,\n    ripple,\n    rotate,\n    roxbury,\n    shake,\n    slowAnimation,\n    spin,\n    staticc,\n    transparency,\n    transpose,\n  ],\n  sortBy((x) => x.name),\n  reject((x) => x.disabled)\n);\n\nexport const transformByName = (\n  name: string\n): Transform<readonly ParamFunction<any>[]> => {\n  const t = POSSIBLE_TRANSFORMS.find((t) => t.name === name);\n  assert(t, `Could not find matching transform: ${name}`);\n  return t as any as Transform<readonly ParamFunction<any>[]>;\n};\n","import {\n  Button,\n  CircularProgress,\n  Divider,\n  Grid,\n  Icon,\n  LinearProgress,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { runTransforms } from '../domain/run';\nimport { AppState, TransformInput } from '../domain/types';\nimport { assert } from '../domain/utils';\nimport { sliderParam } from '../params/sliderParam';\nimport { transformByName } from '../transforms';\n\ninterface ComputeBoxProps {\n  computeDisabled: boolean;\n  appState: AppState;\n  onFpsChange: (fps: number) => void;\n  onComputed: () => void;\n}\n\ntype ComputeState =\n  | {\n      loading: false;\n      results: { transformName: string; gif: string }[];\n      computeTime: number | undefined;\n    }\n  | { loading: true };\n\nconst DEFAULT_FPS = 20;\nconst fpsParam = sliderParam({\n  name: 'Frames per Second',\n  defaultValue: DEFAULT_FPS,\n  min: 1,\n  max: 60,\n});\n\nexport const ComputeBox: React.FC<ComputeBoxProps> = ({\n  computeDisabled,\n  appState,\n  onFpsChange,\n  onComputed,\n}) => {\n  const [computeState, setComputeState] = React.useState<ComputeState>({\n    loading: false,\n    results: [],\n    computeTime: undefined,\n  });\n  const [progress, setProgress] = React.useState<number | undefined>();\n\n  return (\n    <Stack spacing={1}>\n      <Typography variant=\"h5\">Create Gif</Typography>\n\n      <div style={{ maxWidth: '300px' }}>\n        {fpsParam.fn({\n          value: { valid: true, value: appState.fps },\n          onChange: (x) => {\n            if (x.valid) {\n              onFpsChange(x.value);\n            }\n          },\n        })}\n      </div>\n      <Button\n        variant=\"contained\"\n        sx={{ maxWidth: '300px' }}\n        endIcon={\n          !computeState.loading && appState.dirty ? (\n            <Icon>priority_high</Icon>\n          ) : undefined\n        }\n        disabled={computeDisabled}\n        onClick={async () => {\n          const transformInputs = appState.transforms.map(\n            (t): TransformInput<any> => ({\n              transform: transformByName(t.transformName),\n              params: t.paramsValues.map((p) => {\n                assert(p.valid, 'Got non-valid when compute box was clicked');\n                return p.value;\n              }),\n            })\n          );\n          setComputeState({ loading: true });\n          setTimeout(async () => {\n            try {\n              assert(\n                appState.baseImage,\n                'No source image, this button should be disabled!'\n              );\n              const start = Date.now();\n              let currIdx = 0;\n              const timings: number[] = [];\n              setProgress(0);\n              const results = await runTransforms({\n                inputDataUrl: appState.baseImage,\n                transformList: transformInputs,\n                fps: appState.fps,\n                onImageFinished: () => {\n                  timings[currIdx] = Date.now() - start;\n                  currIdx += 1;\n                  setProgress((currIdx / transformInputs.length) * 100);\n                },\n              });\n              const computeTime = Math.ceil((Date.now() - start) / 1000);\n              setComputeState({\n                loading: false,\n                computeTime,\n                results: results.map((result, idx) => ({\n                  transformName: appState.transforms[idx].transformName,\n                  gif: result.gif,\n                })),\n              });\n\n              // Google analytics\n              timings.forEach((timingValue, idx) => {\n                ga('send', {\n                  hitType: 'timing',\n                  timingCategory: 'computeStep',\n                  timingVar: appState.transforms[idx].transformName,\n                  timingValue,\n                });\n              });\n              ga('send', {\n                hitType: 'timing',\n                timingCategory: 'computeTotal',\n                timingVar: appState.transforms.length,\n                timingValue: computeTime,\n              });\n\n              setProgress(undefined);\n              onComputed();\n            } catch (err) {\n              console.error(err);\n              console.error((err as any).stack);\n            }\n          });\n        }}\n      >\n        {computeState.loading ? (\n          <CircularProgress color=\"inherit\" />\n        ) : (\n          'Compute'\n        )}\n      </Button>\n      {progress !== undefined && (\n        <LinearProgress variant=\"determinate\" value={progress} />\n      )}\n      {!computeState.loading && computeState.computeTime !== undefined && (\n        <>\n          <Divider />\n          <Typography variant=\"caption\">\n            Compute Time: {computeState.computeTime} second(s)\n          </Typography>\n        </>\n      )}\n\n      {!computeState.loading && computeState.results.length > 0 && (\n        <>\n          <Divider />\n          <Grid\n            container\n            spacing={2}\n            padding={1}\n            columns={{ xs: 4, sm: 8, md: 12 }}\n          >\n            {computeState.results.map(({ gif, transformName }, idx) => (\n              <Grid item xs={4} sm={4} md={4} key={`${transformName}-${idx}`}>\n                <Typography variant=\"subtitle2\">{transformName}</Typography>\n                <img\n                  src={gif}\n                  alt={`gif-${transformName}-${idx}`}\n                  style={{ maxWidth: '300px', maxHeight: 'auto' }}\n                ></img>\n              </Grid>\n            ))}\n          </Grid>\n        </>\n      )}\n    </Stack>\n  );\n};\n","import {\n  Autocomplete,\n  Divider,\n  FormControl,\n  Icon,\n  IconButton,\n  Paper,\n  Stack,\n  TextField,\n  Tooltip,\n  Typography,\n} from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, ParamValue, Transform } from '../domain/types';\n\ninterface SelectedTransform {\n  transform: Transform<any>;\n  paramValues: ParamValue<any>[];\n}\n\ninterface ImageTransformProps {\n  selectedTransform: SelectedTransform;\n  possibleTransforms: Transform<any>[];\n  index: number;\n  onSelect: (selected: SelectedTransform) => void;\n  onRemove: () => void;\n  onMoveLeft?: () => void;\n  onMoveRight?: () => void;\n}\n\nexport const ImageTransform: React.FC<ImageTransformProps> = ({\n  selectedTransform,\n  possibleTransforms,\n  index,\n  onSelect,\n  onRemove,\n  onMoveLeft,\n  onMoveRight,\n}) => {\n  return (\n    <Paper style={{ padding: 8 }} elevation={3}>\n      <Stack spacing={1}>\n        <Stack direction=\"row\" spacing={2}>\n          <Typography variant=\"subtitle1\">{index + 1}</Typography>\n          <Tooltip title=\"Delete transform\">\n            <IconButton aria-label=\"delete\" onClick={onRemove}>\n              <Icon>delete</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform left\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveLeft}\n              disabled={!onMoveLeft}\n            >\n              <Icon>chevron_left</Icon>\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Move transform right\">\n            <IconButton\n              aria-label=\"delete\"\n              onClick={onMoveRight}\n              disabled={!onMoveRight}\n            >\n              <Icon>chevron_right</Icon>\n            </IconButton>\n          </Tooltip>\n        </Stack>\n        <Stack direction=\"row\" spacing={4}>\n          <FormControl fullWidth>\n            <Autocomplete\n              disableClearable\n              value={selectedTransform.transform.name}\n              options={possibleTransforms.map((t) => t.name)}\n              onChange={(event, newTransformName) => {\n                const t = possibleTransforms.find(\n                  (t) => t.name === newTransformName\n                )!;\n                // Reset all the params when you select a new transform\n                onSelect({\n                  transform: t,\n                  paramValues: t.params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                });\n              }}\n              renderInput={(params) => (\n                <TextField {...params} label=\"Transform\" />\n              )}\n            />\n          </FormControl>\n        </Stack>\n        {selectedTransform.transform.description && (\n          <Typography variant=\"caption\">\n            {selectedTransform.transform.description}\n          </Typography>\n        )}\n        {selectedTransform.transform.params.length > 0 && (\n          <Typography variant=\"subtitle1\">Parameters</Typography>\n        )}\n        <Stack divider={<Divider />} spacing={2}>\n          {selectedTransform.transform.params.map(\n            // Create elements for each of the parameters for the selectect transform.\n            // Each of these would get an onChange event so we know when the user has\n            //  selected a value.\n            (param: ParamFunction<any>, idx: number) => {\n              const ele = param.fn({\n                value: selectedTransform.paramValues[idx],\n                onChange: (v) => {\n                  onSelect({\n                    ...selectedTransform,\n                    paramValues: selectedTransform.paramValues.map((x, i) => {\n                      if (i === idx) {\n                        return v;\n                      }\n                      return x;\n                    }),\n                  });\n                },\n              });\n              return (\n                <React.Fragment\n                  key={`${selectedTransform.transform.name}-${param.name}`}\n                >\n                  {ele}\n                </React.Fragment>\n              );\n            }\n          )}\n        </Stack>\n      </Stack>\n    </Paper>\n  );\n};\n","import { Button, Grid, Icon, Stack, Typography } from '@material-ui/core';\nimport React from 'react';\nimport { ParamFunction, Transform, TransformWithParams } from '../domain/types';\nimport { transformByName } from '../transforms';\nimport { ImageTransform } from './ImageTransform';\n\ninterface TransformListProps {\n  currentTransforms: TransformWithParams<any>[];\n  possibleTransforms: Transform<any>[];\n  onTransformsChange: (t: TransformWithParams<any>[]) => void;\n}\n\nexport const ImageTransformList: React.FC<TransformListProps> = ({\n  currentTransforms,\n  possibleTransforms,\n  onTransformsChange,\n}) => (\n  <Stack spacing={1}>\n    <Typography variant=\"h5\">Image Transforms</Typography>\n    <Grid\n      container\n      spacing={2}\n      padding={1}\n      columns={{ xs: 4, sm: 8, md: 12 }}\n      rowSpacing={4}\n    >\n      {currentTransforms.map((t, tIdx) => (\n        <Grid item xs={4} sm={4} md={4} key={`${t.transformName}-${tIdx}`}>\n          <ImageTransform\n            index={tIdx}\n            possibleTransforms={possibleTransforms}\n            selectedTransform={{\n              transform: transformByName(t.transformName),\n              paramValues: t.paramsValues,\n            }}\n            onRemove={() =>\n              onTransformsChange(\n                currentTransforms.filter((nextT, newIdx) => newIdx !== tIdx)\n              )\n            }\n            onMoveLeft={\n              tIdx > 0\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx - 1) {\n                          // This is the next item in the list\n                          return currentTransforms[newIdx + 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the previous item\n                          return currentTransforms[tIdx - 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onMoveRight={\n              tIdx < currentTransforms.length - 1\n                ? () =>\n                    onTransformsChange(\n                      currentTransforms.map((nextT, newIdx) => {\n                        if (newIdx === tIdx + 1) {\n                          // This is the previous item in the list\n                          return currentTransforms[newIdx - 1];\n                        } else if (tIdx === newIdx) {\n                          // This is the next item\n                          return currentTransforms[tIdx + 1];\n                        } else {\n                          return nextT;\n                        }\n                      })\n                    )\n                : undefined\n            }\n            onSelect={(selected) =>\n              onTransformsChange(\n                currentTransforms.map((nextT, nextTIdx) => {\n                  if (tIdx === nextTIdx) {\n                    // This is the one we just changed\n                    return {\n                      transformName: selected.transform.name,\n                      paramsValues: selected.paramValues,\n                      computedImage: undefined,\n                    };\n                  }\n                  // Reset all the images if we changed anything\n                  return {\n                    transformName: nextT.transformName,\n                    paramsValues: nextT.paramsValues,\n                    computedImage: undefined,\n                  };\n                })\n              )\n            }\n          />\n        </Grid>\n      ))}\n      <Grid item xs={4} sm={4} md={4}>\n        <Stack spacing={4}>\n          <Button\n            fullWidth={false}\n            variant=\"contained\"\n            startIcon={<Icon>add</Icon>}\n            onClick={() =>\n              onTransformsChange([\n                ...currentTransforms,\n                {\n                  transformName: possibleTransforms[0].name,\n                  paramsValues: possibleTransforms[0].params.map(\n                    (p: ParamFunction<any>) => p.defaultValue\n                  ),\n                },\n              ])\n            }\n          >\n            New Transform\n          </Button>\n        </Stack>\n      </Grid>\n    </Grid>\n  </Stack>\n);\n","import { Alert, Button, Icon, Stack, Typography } from '@material-ui/core';\nimport * as lz from 'lz-string';\nimport React from 'react';\nimport { AppState } from '../domain/types';\n\ninterface ImportExportProps {\n  state: AppState;\n  onImport: (o: AppState) => void;\n}\n\nexport const ImportExport: React.FC<ImportExportProps> = ({\n  state,\n  onImport,\n}) => {\n  const [info, setInfo] = React.useState<string | undefined>();\n  const [isInvalid, setInvalid] = React.useState(false);\n\n  const showInfo = (text: string) => {\n    setInfo(text);\n    setTimeout(() => setInfo(undefined), 2000);\n  };\n\n  const showError = () => {\n    setInvalid(true);\n    setTimeout(() => setInvalid(false), 2000);\n  };\n\n  return (\n    <Stack spacing={3}>\n      <Typography variant=\"h5\">Import/Export</Typography>\n      <Button\n        startIcon={<Icon>file_upload</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={() => {\n          const output = lz.compressToBase64(JSON.stringify(state));\n          navigator.clipboard.writeText(output);\n          showInfo('Copied to clipboard');\n        }}\n      >\n        Export to clipboard <br />\n        (With Source Image)\n      </Button>\n\n      <Button\n        startIcon={<Icon>file_download</Icon>}\n        sx={{ maxWidth: '300px' }}\n        variant=\"contained\"\n        onClick={async () => {\n          try {\n            const clipboardContents = await navigator.clipboard.readText();\n            if (!clipboardContents) {\n              showError();\n              return;\n            }\n            const data = JSON.parse(\n              lz.decompressFromBase64(clipboardContents)!\n            );\n            if (!Array.isArray(data.transforms)) {\n              showError();\n              return;\n            }\n            onImport(data);\n            setInvalid(false);\n          } catch (e) {\n            console.error(e);\n            showError();\n          }\n        }}\n      >\n        Import from clipboard\n      </Button>\n      {info && (\n        <Alert severity=\"info\" sx={{ maxWidth: '300px' }}>\n          {info}\n        </Alert>\n      )}\n      {isInvalid && (\n        <Alert severity=\"error\" sx={{ maxWidth: '300px' }}>\n          Error importing from clipboard\n        </Alert>\n      )}\n    </Stack>\n  );\n};\n","import { AppState } from './domain/types';\n\nconst LOCAL_STORAGE_KEY = 'partymoji-state';\n\nexport const getStoredAppState = (): AppState | undefined => {\n  try {\n    const stored = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (stored) {\n      const savedState = JSON.parse(stored);\n      if (Array.isArray(savedState.transforms)) {\n        return savedState;\n      }\n    }\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error loading state from local storage', err.stack || err);\n  }\n\n  return undefined;\n};\n\nexport const saveAppState = (state: AppState) => {\n  try {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error saving state to local storage', err.stack || err);\n  }\n};\n\nexport const clearAppState = () => {\n  try {\n    window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n  } catch (err) {\n    // @ts-ignore\n    console.error('Error clearing state from local storage', err.stack || err);\n  }\n};\n","import {\n  Button,\n  Container,\n  Divider,\n  Icon,\n  Paper,\n  Stack,\n  Typography,\n} from '@material-ui/core';\nimport ScopedCssBaseline from '@material-ui/core/ScopedCssBaseline';\nimport React from 'react';\n\nimport { ComputeBox } from './components/ComputeBox';\nimport { Help } from './components/Help';\nimport { ImagePicker } from './components/ImagePicker';\nimport { ImageTransformList } from './components/ImageTransformList';\nimport { ImportExport } from './components/ImportExport';\nimport { AppState } from './domain/types';\nimport * as localStorage from './localStorage';\nimport { POSSIBLE_TRANSFORMS, transformByName } from './transforms';\n\n// Set to true to print out the current state at the bottom of the page\nconst DEBUG = false;\n\nconst DEFAULT_STATE: AppState = {\n  dirty: false,\n  transforms: [],\n  baseImage: undefined,\n  fps: 20,\n};\n\nexport const App: React.FC = () => {\n  const [state, setStateRaw] = React.useState(DEFAULT_STATE);\n\n  React.useEffect(() => {\n    // If we have local storage state on startup, then reload that\n    const stored = localStorage.getStoredAppState();\n    if (stored) {\n      setStateRaw({ ...stored, dirty: true });\n    }\n  }, []);\n\n  const setState = (newState: AppState) => {\n    localStorage.saveAppState(newState);\n    setStateRaw(newState);\n  };\n\n  if (DEBUG) {\n    (window as any).STATE = state;\n  }\n\n  const computeBtnDisbled =\n    !state.baseImage ||\n    state.transforms.length === 0 ||\n    !state.dirty ||\n    state.transforms.some((t) => {\n      const params = transformByName(t.transformName).params;\n      return (\n        params.length > 0 && t.paramsValues.every((p) => p.valid === false)\n      );\n    });\n\n  return (\n    <>\n      <ScopedCssBaseline />\n      <Container>\n        <Stack spacing={4} justifyContent=\"space-evenly\" divider={<Divider />}>\n          <Typography variant=\"h2\" pt={4}>\n            Partymoji\n          </Typography>\n          <Stack spacing={4} divider={<Divider />}>\n            {DEBUG && (\n              <Paper style={{ padding: 16 }}>\n                <Help />\n              </Paper>\n            )}\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={1}>\n                <Typography variant=\"h5\">Source Image</Typography>\n                <ImagePicker\n                  name=\"Choose a source image\"\n                  currentImageUrl={state.baseImage}\n                  onChange={(baseImage) => {\n                    setState({\n                      ...state,\n                      baseImage,\n                      dirty: true,\n                    });\n                  }}\n                />\n              </Stack>\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImageTransformList\n                currentTransforms={state.transforms}\n                possibleTransforms={POSSIBLE_TRANSFORMS}\n                onTransformsChange={(transforms) =>\n                  setState({\n                    ...state,\n                    dirty: true,\n                    transforms,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ComputeBox\n                computeDisabled={computeBtnDisbled}\n                appState={state}\n                onFpsChange={(fps) =>\n                  setState({\n                    ...state,\n                    fps,\n                    dirty: true,\n                  })\n                }\n                onComputed={() =>\n                  setState({\n                    ...state,\n                    dirty: false,\n                  })\n                }\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <ImportExport\n                state={state}\n                onImport={(newState) => setState({ ...newState, dirty: true })}\n              />\n            </Paper>\n            <Paper style={{ padding: 16 }}>\n              <Stack spacing={3}>\n                <Typography variant=\"h5\">Clear State</Typography>\n                <Typography variant=\"body1\">\n                  Clicking this button will clear the source image and all\n                  transforms\n                </Typography>\n                <Button\n                  startIcon={<Icon>clear</Icon>}\n                  sx={{ maxWidth: '300px' }}\n                  variant=\"contained\"\n                  onClick={() => {\n                    localStorage.clearAppState();\n                    setStateRaw(DEFAULT_STATE);\n                  }}\n                >\n                  Clear State\n                </Button>\n              </Stack>\n            </Paper>\n            {DEBUG && (\n              <div>\n                <code>{JSON.stringify(state, null, 2)}</code>\n              </div>\n            )}\n            <a\n              href=\"https://github.com/MikeyBurkman/partymoji\"\n              target=\"_blank\"\n              rel=\"noreferrer\"\n            >\n              <img\n                src=\"https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg\"\n                width={64}\n                height={64}\n                alt=\"Github Link\"\n              ></img>\n            </a>\n          </Stack>\n        </Stack>\n      </Container>\n    </>\n  );\n};\n","import { Button, Icon, Stack, Typography } from '@material-ui/core';\nimport React, { ErrorInfo } from 'react';\n\ninterface Props {\n  onClearLocalStorage: () => void;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class TopLevelErrorBoundary extends React.Component<Props, State> {\n  public state: State = {\n    hasError: false,\n  };\n\n  static getDerivedStateFromError(error: Error): State {\n    console.error(error);\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Uncaught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <Stack spacing={1}>\n          <Typography variant=\"h2\">Oh no!</Typography>\n          <Typography variant=\"body1\">\n            There seems to have been an issue\n          </Typography>\n          <Typography variant=\"body2\">\n            If refreshing the page doesn't fix things, click the below button to\n            clear local storage\n          </Typography>\n          <Button\n            variant=\"contained\"\n            sx={{ maxWidth: '300px' }}\n            endIcon={<Icon>priority_high</Icon>}\n            startIcon={<Icon>priority_high</Icon>}\n            onClick={this.props.onClearLocalStorage}\n          >\n            Clear storage and reload\n          </Button>\n        </Stack>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './App';\nimport { TopLevelErrorBoundary } from './components/TopLevelErrorBoundary';\nimport * as localStorage from './localStorage';\n\nReactDOM.render(\n  <React.StrictMode>\n    <TopLevelErrorBoundary\n      onClearLocalStorage={() => {\n        localStorage.clearAppState();\n        window.location.reload();\n      }}\n    >\n      <App />\n    </TopLevelErrorBoundary>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}